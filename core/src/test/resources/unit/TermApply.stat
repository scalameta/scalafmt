40 columns                              |
<<< one arg chained (state explosion)
a(b).c(d).e(f).g(h).i(j).k { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa }
>>>
a(b).c(d).e(f).g(h).i(j).k {
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
}
<<< avoid dead ends
function(
    firstCall(a, b, c, d, e, f, g, h),
    secondCall("very long argument string"));
>>>
function(
    firstCall(a, b, c, d, e, f, g, h),
    secondCall(
        "very long argument string"));
<<< Presentation
MyObject(config.getBoolean("shortKey"),
         config.getString("reallyReallyReallyLongKey"),
         liveAnalysis.check(options.has("live"),
                            options.has("analysis")))
>>>
MyObject(
    config.getBoolean("shortKey"),
    config.getString(
        "reallyReallyReallyLongKey"),
    liveAnalysis
      .check(options.has("live"),
             options.has("analysis")))
<<< optimalAt memoization is by split prefix
new Compiler(
    primitives.options.has("primitives"),
    minify.options.has("minify"),
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
>>>
new Compiler(
    primitives.options
      .has("primitives"),
    minify.options.has("minify"),
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
<<< Prune redundant branches
new Compiler(
    assertions.options.has("checked-mode"),
    annotations.options.has("annotations"),
    primitives.options.has("primitives"),
    minify.options.has("minify"),
    preserve.options.has("preserve"),
    liveAnalysis.check(options.has("live"), options.has("analysis")),
    multi.options.has("multi"),
    sourceMap.options.has("source-map"));
>>>
new Compiler(
    assertions.options
      .has("checked-mode"),
    annotations.options
      .has("annotations"),
    primitives.options
      .has("primitives"),
    minify.options.has("minify"),
    preserve.options.has("preserve"),
    liveAnalysis
      .check(options.has("live"),
             options.has("analysis")),
    multi.options.has("multi"),
    sourceMap.options
      .has("source-map"));
<<< comment after (
var list = List( // comment
  function(a: A, b: B, c: C)
)
>>>
var list = List( // comment
    function(a: A, b: B, c: C))
<<< long
var list = List(
  function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C)
);
>>>
var list = List(
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C));
<<< Single line with block {}
function(a, b, c, {
    case Foo("a", 1) => Foo("b", 2)
  })
>>>
function(a, b, c, {
  case Foo("a", 1) => Foo("b", 2)
})
<<< MUST NOT use automatic formatting 1 alexandru/scala-best-practices
val dp = new DispatchPlan(Set(filteredAssets), start =
  startDate, end = endDate, product, scheduleMap, availabilityMap,
  Set(activationIntervals), contractRepository, priceRepository)
>>>
val dp = new DispatchPlan(
    Set(filteredAssets),
    start = startDate,
    end = endDate,
    product,
    scheduleMap,
    availabilityMap,
    Set(activationIntervals),
    contractRepository,
    priceRepository)
<<< SKIP MUST NOT use automatic formatting 2 alexandru/scala-best-practices
val result = service.something(param1, param2, param3, param4).map(transform)
>>>
val result = service
  .something(param1, param2, param3, param4)
  .map(transform)
<<< SKIP One arg per line
Seq(
  Split(Space, 0), // End files with trailing newline
  Split(Newline, 1)
)
>>>
Seq(
    Split(Space, 0), // End files with trailing newline
    Split(Newline, 1)
)
