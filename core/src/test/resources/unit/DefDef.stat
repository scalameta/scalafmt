40 columns                              |
<<< single line
def log(split: Split): String = "aasplit"
>>>
def log(split: Split): String =
  "aasplit"
<<< def gets 2x newline
{val x = 1
def log(split: Split): String = "aasplit"
}
>>>
{
  val x = 1

  def log(split: Split): String =
    "aasplit"
}
<<< override def gets 2x newline
object a {val x = 1
override def log(a: Split): String = "aasplit"
}
>>>
object a {
  val x = 1

  override def log(a: Split): String =
    "aasplit"
}
<<< with type
def identity[T](t: T): T =   t
>>>
def identity[T](t: T): T = t
<<< def kill?
      def hasExplicitJSEncoding =
        sym.hasAnnotation(JSNameAnnotation) ||
        sym.hasAnnotation(JSBracketAccessAnnotation) ||
        sym.hasAnnotation(JSBracketCallAnnotation)
>>>
def hasExplicitJSEncoding =
  sym
    .hasAnnotation(JSNameAnnotation) ||
  sym.hasAnnotation(
      JSBracketAccessAnnotation) ||
  sym.hasAnnotation(
      JSBracketCallAnnotation)
<<< curried functions
def format_![T <: Tree](code: String, a: Int)(implicit ev: Parse[T]): String
>>>
def format_![T <: Tree](code: String,
    a: Int)(implicit ev: Parse[T]): String
<<< curried functions defn
def format_![T <: Tree](code: String, a: Int)(implicit ev: Parse[T]): String = 1
>>>
def format_![T <: Tree](code: String,
    a: Int)(implicit ev: Parse[T]): String =
  1
