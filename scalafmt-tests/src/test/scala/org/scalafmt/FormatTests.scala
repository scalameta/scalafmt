package org.scalafmt

import java.io.File

import munit.FunSuite
import org.scalafmt.Error.{Incomplete, SearchStateExploded}
import org.scalafmt.rewrite.FormatTokensRewrite
import org.scalafmt.sysops.FileOps
import org.scalafmt.util._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._
import scala.concurrent.{Await, Future}
import scala.meta.parsers.ParseException

// TODO(olafur) property test: same solution without optimization or timeout.

class FormatTests extends FunSuite with CanRunTests with FormatAssertions {
  import LoggerOps._
  lazy val onlyUnit = UnitTests.tests.exists(_.only)
  lazy val onlyManual = !onlyUnit && ManualTests.tests.exists(_.only)
  lazy val onlyOne = tests.exists(_.only)

  override def ignore(t: DiffTest): Boolean = false

  override val tests = {
    if (onlyManual) ManualTests.tests
    else UnitTests.tests
  }

  tests
    .sortBy(x => (x.loc.path, x.loc.line))
    .withFilter(testShouldRun)
    .foreach(runTest(run))

  def run(t: DiffTest): Unit = {
    // @note munit assertions take an implicit Location generated by macros at compile time
    // this line makes them instead throw a useful exception pointing to the right stat file
    implicit val loc = t.loc
    val debug = new Debug(onlyOne)
    val runner = t.style.runner
    val result = Scalafmt.formatCode(
      t.original,
      t.style.copy(runner = scalafmtRunner(runner, debug)),
      filename = t.filename
    )
    debug.printTest()
    val obtained = result.formatted match {
      case Formatted.Failure(e)
          if t.style.onTestFailure.nonEmpty &&
            e.getMessage.contains(t.style.onTestFailure) =>
        t.expected
      case Formatted.Failure(e: Incomplete) => e.formattedCode
      case Formatted.Failure(e: SearchStateExploded) =>
        logger.elem(e)
        e.partialOutput
      case Formatted.Failure(e) => throw FormatException(e, t.original)
      case Formatted.Success(code) => code
    }
    debugResults += saveResult(t, obtained, debug)
    val debug2 = new Debug(onlyOne)
    val result2 = Scalafmt.formatCode(
      obtained,
      t.style.copy(runner = scalafmtRunner(runner, debug2)),
      filename = t.filename
    )
    debug2.printTest()
    val result2Either = result2.formatted.toEither
    def getFormattedAgain(failOK: Boolean) = result2Either match {
      case Left(e: ParseException) if !failOK =>
        "test does not parse: " + parseException2Message(e, obtained)
      case Left(e) => throw FormatException(e, obtained)
      case Right(code) => code
    }
    val formattedAgain = getFormattedAgain(onlyManual)
    if (onlyManual)
      assertEquals(formattedAgain, obtained, "Idempotency violated")
    else {
      assertEquals(
        if (formattedAgain == obtained || result2Either.isLeft) formattedAgain
        else "Idempotency violated\n" + formattedAgain,
        t.expected
      )
    }
    if (
      result2Either.isRight &&
      t.style.rewrite.rules.isEmpty &&
      FormatTokensRewrite.getEnabledFactories(t.style).isEmpty &&
      !t.style.assumeStandardLibraryStripMargin &&
      !FileOps.isMarkdown(t.filename) &&
      t.style.onTestFailure.isEmpty
    )
      assertFormatPreservesAst(
        t.filename,
        t.original,
        obtained,
        result.config.runner
      )
  }

  def testShouldRun(t: DiffTest): Boolean = !onlyOne || t.only

  override def afterAll(): Unit = {
    logger.debug(s"Total explored: ${Debug.explored}")
    val results = debugResults.result()
    // TODO(olafur) don't block printing out test results.
    // I don't want to deal with scalaz's Tasks :'(
    val k = for {
      _ <- Future(
        FileOps.writeFile(
          s"target${File.separator}index.html",
          Report.heatmap(results)
        )
      )
    } yield ()
    // Travis exits right after running tests.
    if (sys.env.contains("TRAVIS")) Await.ready(k, 20.seconds)
  }
}
