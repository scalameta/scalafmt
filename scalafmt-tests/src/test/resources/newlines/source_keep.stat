align.preset = none
maxColumn = 40
newlines.source = keep
runner.optimizer.forceConfigStyleMinSpan = 50
binPack.parentConstructors = OnelineIfPrimaryOneline
<<< 1.1: block, if-else, line too long
if (true) {      println(aaaaaaaaaaaaaaaaaaaaaaaaaa)}
>>>
if (true) {
  println(aaaaaaaaaaaaaaaaaaaaaaaaaa)
}
<<< 1.2: block, if-else, egyptian curlies
object a {
if (a) {
println("bbb") } else c
}
>>>
object a {
  if (a) {
    println("bbb")
  } else c
}
<<< 1.3: block, if, non-egyptian curlies
object a {
if (a)
{
println("bbb")
}
else
{
c
}}
>>>
object a {
  if (a) {
    println("bbb")
  } else {
    c
  }
}
<<< 1.4: block #1043
object a {
      if ('0' <= c && c <= '9') { c - '0' }
      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }
      else if ('a' <= c && c <= 'f') { c - 'a' + 10 }
      else {
       -1  }}
>>>
object a {
  if ('0' <= c && c <= '9') { c - '0' }
  else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else {
    -1
  }
}
<<< 1.5: block #1043 with lines joined
object a {
      if ('0' <= c && c <= '9') { c - '0' }      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }  else if ('a' <= c && c <= 'f') { c - 'a' + 10 }      else {
                                                            -1
}}
>>>
object a {
  if ('0' <= c && c <= '9') { c - '0' }
  else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else {
    -1
  }
}
<<< 1.6: block, try-catch, line too long
object a {
try { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa } catch { case b => }
}
>>>
object a {
  try {
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  } catch { case b => }
}
<<< 1.7: block, try-catch, no breaks
object a {
try { a } catch { case b => ; case c => } finally { d }
}
>>>
object a {
  try { a }
  catch { case b => ; case c => }
  finally { d }
}
<<< 1.8: block, try-catch, with breaks
object a {
try {
 a } catch {
  case b => ; case c => } finally {
   d }
}
>>>
object a {
  try {
    a
  } catch {
    case b => ; case c =>
  } finally {
    d
  }
}
<<< 1.9: block, try-catch, with breaks, top-level
try {
 a } catch {
  case b => ; case c => } finally {
   d }
>>>
try {
  a
} catch {
  case b => ; case c =>
} finally {
  d
}
<<< 1.a: block, class
object a {
class a {
 type b = Int
}
}
>>>
object a {
  class a {
    type b = Int
  }
}
<<< 1.b: block, trait and object
object a {
trait b {
 type c = Int
}
object b {
def apply(c: Int) = { new d(c)
}
}}
>>>
object a {
  trait b {
    type c = Int
  }
  object b {
    def apply(c: Int) = { new d(c) }
  }
}
<<< 1.c: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user")
    } should have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.1: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.2: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should
       have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should
    have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.3: block followed by an infix, overflowing if no break
newlines.afterInfix = keep
maxColumn = 80
===
object a {
    the[Exception] thrownBy
       { SizeUtils.calculate(segments, "user") } should
       have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should
    have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.d: if-else, no curlies
if (a)
println("bbb") else if (b) b else
 c
>>>
if (a)
  println("bbb")
else if (b) b
else
  c
<<< 2.1: def one-line body
def a = b
>>>
def a = b
<<< 2.2: def one-line block body
object a {
def a = { b; c }
}
>>>
object a {
  def a = { b; c }
}
<<< 2.3: def one-line block body with a break
object a {
def a =
 { b; c }
}
>>>
object a {
  def a = { b; c }
}
<<< 2.4: def multiline-line block body with a break
object a {
def a =
 {
  b;c }}
>>>
object a {
  def a = {
    b; c
  }
}
<<< 2.5: def multiline-line block body with a break
object a {
def a = {
  b;c }
}
>>>
object a {
  def a = {
    b; c
  }
}
<<< 2.6 #1747: one line with else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 = if (a > 10) { Some(a) } else { None }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 = if (a > 10) { Some(a) }
  else { None }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
  else { None }
}
<<< 2.7 #1747: one line without else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
<<< 2.8 #1747: split on then with else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  else
    None
  val ok2 = if (a > 10) {
    Some(a)
  } else {
    None
  }
  val ok3 = if (aaaa > 10000) {
     Some(aaaa)
  }
  else {
    None
  }
}
>>>
object a {
  val ok1 = if (a > 10)
    Some(a)
  else
    None
  val ok2 = if (a > 10) {
    Some(a)
  } else {
    None
  }
  val ok3 = if (aaaa > 10000) {
    Some(aaaa)
  } else {
    None
  }
}
<<< 2.9 #1747: split on else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a) else
    None
  val ok2 = if (a > 10) { Some(a) } else {
    None
  }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else {
    None
  }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a)
  else
    None
  val ok2 = if (a > 10) { Some(a) }
  else {
    None
  }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
  else {
    None
  }
}
<<< 2.10 #1747: split on then without else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  val ok2 = if (a > 10) {
    Some(a) }
  val ok3 = if (aaaa > 10000) {
    Some(aaaa) }
}
>>>
object a {
  val ok1 = if (a > 10)
    Some(a)
  val ok2 = if (a > 10) {
    Some(a)
  }
  val ok3 = if (aaaa > 10000) {
    Some(aaaa)
  }
}
<<< 2.11 #1747: split on if
maxColumn = 60
===
object a {
  val ok1 =
    if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) } else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 =
    if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) }
    else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
    else { None }
}
<<< 2.12 #1747: split on if without else
maxColumn = 60
===
object a {
  val ok1 =
    if (a > 10) Some(a)
  val ok2 =
    if (a > 10) { Some(a) }
  val ok3 =
   if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 =
    if (a > 10) Some(a)
  val ok2 =
    if (a > 10) { Some(a) }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
}
<<< 2.13 val with for/yield
maxColumn = 80
===
val attributes =
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.2 val with for/yield, redundant braces
maxColumn = 80
rewrite.rules = [RedundantBraces]
===
val attributes = {
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
}
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.3 val with for/yield, redundant parens
maxColumn = 80
rewrite.rules = [RedundantParens]
===
val attributes = (
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
)
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.4 def with for/yield
maxColumn = 80
===
def attributes =
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.5 def with for/yield, redundant braces
maxColumn = 80
rewrite.rules = [RedundantBraces]
===
def attributes = {
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
}
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.6 def with for/yield, redundant parens
maxColumn = 80
rewrite.rules = [RedundantParens]
===
def attributes = (
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
)
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.14 val with short for/yield
maxColumn = 80
===
val attributes = for (i ← 1 to count)
 yield i
>>>
val attributes = for (i ← 1 to count)
  yield i
<<< 2.15 val with literal apply
object a {
   val a =
    b(
      0x1F, // ID1
       0x8B, // ID2
       8, // CM = Deflate
       0, // FLG
       0, // MTIME 1
       0, // MTIME 2
       0, // MTIME 3
       0, // MTIME 4
       0, // XFL
       0 // OS
    )
 }
>>>
object a {
  val a =
    b(
      0x1f, // ID1
      0x8b, // ID2
      8, // CM = Deflate
      0, // FLG
      0, // MTIME 1
      0, // MTIME 2
      0, // MTIME 3
      0, // MTIME 4
      0, // XFL
      0 // OS
    )
}
<<< 2.16 val with apply and comment
danglingParentheses.preset = false
===
val a =
  Set(
    "b" // ...
  )
>>>
val a =
  Set(
    "b" // ...
  )
<<< 2.17 val with apply-apply-select
val aaaaa = bbbbb.asss(as).ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb.asss(as).ccccc(
  ddddd,
  eeeee,
  fffff
) // comment
<<< 2.18 val with apply-apply
val aaaaa = (getSomeLongerFunction(c))(as)
>>>
val aaaaa =
  (getSomeLongerFunction(c))(as)
<<< 2.19 val with apply-select-select
val aaaaa = bbbbb.asss.ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb.asss.ccccc(
  ddddd,
  eeeee,
  fffff
) // comment
<<< 2.20 val with apply-select-select
val nested =
  promiseIntercept(new Actor {
    def receive = {
      case _ ⇒
    }
  })(result)
>>>
val nested =
  promiseIntercept(new Actor {
    def receive = {
      case _ ⇒
    }
  })(result)
<<< 2.21 val with apply type
  val deployment = system
    .asInstanceOf[ActorSystemImpl]
    .provider
    .deployer
    .lookup(service.split("/").drop(1))
>>>
val deployment = system
  .asInstanceOf[ActorSystemImpl]
  .provider
  .deployer
  .lookup(service.split("/").drop(1))
<<< 2.22
maxColumn = 80
===
val augassign: P[Ast.operator] = P(
    "+=".!.map(_ => Ast.operator.Add) |
    "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) |
    "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) |
    "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) |
    "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) |
    "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
  )
>>>
val augassign: P[Ast.operator] = P(
  "+=".!.map(_ => Ast.operator.Add) |
    "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) |
    "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) |
    "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) |
    "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) |
    "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
)
<<< 3.1: def non-config-style, long
def a( ccccccccccccccccc:Int,
 ddddddddddddddddd:String,
  eeeeeeeeeeeeeeeee:Long) = true
>>>
def a(
    ccccccccccccccccc: Int,
    ddddddddddddddddd: String,
    eeeeeeeeeeeeeeeee: Long
) = true
<<< 3.2: def non-config-style, short
def a( b:Int,
 c:String,
  d:Long) = true
>>>
def a(b: Int, c: String, d: Long) = true
<<< 3.3: apply non-config-style, no breaks on ( and )
val a = b(c, d,
  efgh)
>>>
val a = b(c, d, efgh)
<<< 3.4: apply non-config-style, no break on (, break on )
val a = b(c,
 d,
  efgh
)
>>>
val a = b(c, d, efgh)
<<< 3.5: apply non-config-style, break on (, no break on )
val a = b(
c,
 d,
  efgh)
>>>
val a = b(
  c,
  d,
  efgh
)
<<< 3.6: apply config-style, break on ( and )
val a = b(
c,
 d,
  efgh
  )
>>>
val a = b(
  c,
  d,
  efgh
)
<<< 3.7: apply non-config-style, force
val a = b( cccccccccccccc, dddddddddddddd,  eeeeeeeeeeeeee)
>>>
val a = b(
  cccccccccccccc,
  dddddddddddddd,
  eeeeeeeeeeeeee
)
<<< 3.8: apply non-config-style, too long
val a = b( ccccccccccc, ddddddddddd,  eeeeeeeeeee)
>>>
val a = b(
  ccccccccccc,
  ddddddddddd,
  eeeeeeeeeee
)
<<< 3.9: single-arg multi-line apply, possible config-style
a.b(foo {
    val bar = baz
    qux
  }
)
>>>
a.b(foo {
  val bar = baz
  qux
})
<<< 3.10 enclosed, infix on the right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
  terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  val terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
  terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
<<< 3.11 enclosed, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (for (i ← 1 to n) yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  (for (i ← 1 to n) yield {
    val man = context.watch(context.system.actorOf(Props[Terminater]))
    man ! "run"
    man
  })
}
<<< 3.12 enclosed, followed by select
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(promiseIntercept({
        throw new IllegalStateException("Ur state be b0rked");
        new InnerActor
      })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
>>>
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(promiseIntercept({
        throw new IllegalStateException("Ur state be b0rked");
        new InnerActor
      })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
<<< 3.12.2 enclosed, followed by select
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(
        promiseIntercept({
          throw new IllegalStateException("Ur state be b0rked");
          new InnerActor
        })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
>>>
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(
        promiseIntercept({
          throw new IllegalStateException("Ur state be b0rked");
          new InnerActor
        })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
<<< 3.13 enclosed, followed by select and infix
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] { in.readObject
  }).getMessage should ===(
    "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
      " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
>>>
object a {
  (intercept[java.lang.IllegalStateException] {
    in.readObject
  }).getMessage should ===(
    "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
      " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
<<< 3.14 enclosed, assignment, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
      in.readObject } )
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
<<< 3.15 enclosed, assignment, infix on left
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject } ) ++ 2
}
>>>
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }) ++ 2
}
<<< 3.16 enclosed, assignment, infix on right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject
    })
}
>>>
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject })
}
<<< 3.17 enclosed, assignment, infix in middle
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject }) ++ 3
}
>>>
object a {
  val a =
    2 ++ (intercept[java.lang.IllegalStateException] { in.readObject }) ++ 3
}
<<< 3.18 enclosed, assignment, by itself, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
<<< 3.19 enclosed, assignment, infix on left, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  }) ++ 2
}
<<< 3.20 enclosed, assignment, infix on right, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject    }  )
}
>>>
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    })
}
<<< 3.21 enclosed, assignment, infix in middle, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] { in.readObject
    }  ) ++ 3
}
>>>
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }) ++ 3
}
<<< 3.22 enclosed, assignment, by itself, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = (intercept[
    java.lang.IllegalStateException] {
    in.readObject
  })
}
<<< 3.23 enclosed, assignment, infix on left, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }) ++ 2
}
>>>
object a {
  val a = (
    intercept[
      java.lang.IllegalStateException] {
      in.readObject
    }) ++ 2
}
<<< 3.24 enclosed, assignment, infix on right, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject }
  )
}
>>>
object a {
  val a = 2 ++ (intercept[
    java.lang.IllegalStateException] {
    in.readObject
  })
}
<<< 3.25 enclosed, assignment, infix in middle, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] {
    in.readObject
  }) ++ 3
}
>>>
object a {
  val a = 2 ++ (intercept[
    java.lang.IllegalStateException] {
    in.readObject
  }) ++ 3
}
<<< 3.26 enclosed, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    (supervisor
      .ask(AwaitActivation(endpoint))(timeout))
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(endpoint: ActorRef)(implicit
    timeout: Timeout,
    executor: ExecutionContext
): Future[ActorRef] =
  (supervisor
    .ask(AwaitActivation(endpoint))(timeout))
    .map[ActorRef]({
      case EndpointActivated(`endpoint`) ⇒ endpoint
      case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
    })
<<< 3.27 enclosed in block, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    {supervisor
      .ask(AwaitActivation(endpoint))(timeout)}
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(endpoint: ActorRef)(implicit
    timeout: Timeout,
    executor: ExecutionContext
): Future[ActorRef] = {
  supervisor
    .ask(AwaitActivation(endpoint))(timeout)
}
  .map[ActorRef]({
    case EndpointActivated(`endpoint`) ⇒ endpoint
    case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
  })
<<< 3.28 apply with optimal token
maxColumn = 80
danglingParentheses.preset = false
===
case class AttributeInfo(symbol : Symbol, typeRef : Type, value : Option[Any],
  values : Seq[String ~ Any]) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
>>>
case class AttributeInfo(
    symbol: Symbol,
    typeRef: Type,
    value: Option[Any],
    values: Seq[
      String ~ Any]) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
<<< 3.29 apply with optimal token
maxColumn = 80
===
Multipart.FormData.BodyPart.Strict(
  "userfile",
  HttpEntity(`application/pdf`, ByteString("filecontent")),
  Map("filename" -> "test€.dat"),
  List(
    RawHeader("Content-Transfer-Encoding", "binary"),
    RawHeader("Content-Additional-1", "anything"),
    RawHeader("Content-Additional-2", "really-anything"))
)
>>>
Multipart.FormData.BodyPart.Strict(
  "userfile",
  HttpEntity(`application/pdf`, ByteString("filecontent")),
  Map("filename" -> "test€.dat"),
  List(
    RawHeader("Content-Transfer-Encoding", "binary"),
    RawHeader("Content-Additional-1", "anything"),
    RawHeader("Content-Additional-2", "really-anything")
  )
)
<<< 3.30: apply with single-arg assign; open nl, close nonl
object foo {
val a = b(c = d)
val a = b(c =
  d)
val a = b(
  c =  d)
val a = b(
  c =  d
  )
}
>>>
object foo {
  val a = b(c = d)
  val a = b(c =
    d
  )
  val a = b(
    c = d
  )
  val a = b(
    c = d
  )
}
<<< 3.31
object a {
  val b: Bbbbb[Seq[Ccccc]] = writable[Seq[Ccccc]]
}
>>>
object a {
  val b: Bbbbb[Seq[Ccccc]] =
    writable[Seq[Ccccc]]
}
<<< 4.1: annotation with newlines
maxColumn = 50
optIn.annotationNewlines = true
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot @deprecated class B(
      @annot @deprecated private implicit val x: Int
  ) extends A {
    @annot override def foo = 1

    @annot
    override def bar = { 1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(
        @annot @deprecated x: Int
    ) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(
      value =
        "foo",
      someInt = 5
    ) @annot3
    @deprecated(value =
      "bar"
    ) def bar2 = 1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
<<< 4.2: annotation without newlines
maxColumn = 50
optIn.annotationNewlines = false
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot @deprecated
  class B(
      @annot @deprecated private implicit val x: Int
  ) extends A {
    @annot override def foo = 1

    @annot
    override def bar = { 1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/
    @annot5 @deprecated
    def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot
    @annot2(
      value =
        "foo",
      someInt = 5
    ) @annot3
    @deprecated(value =
      "bar"
    ) def bar2 = 1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
<<< 4.2.1 annotation !annotationNewlines
align.preset = none
optIn.annotationNewlines = false
===
object a {
  @Ignore @Test def foo(): Unit = {
     val bar = baz
  }
  @Ignore @Test def fooFooFoo(): Unit = {
     val bar = baz
  }
}
>>>
object a {
  @Ignore @Test def foo(): Unit = {
    val bar = baz
  }
  @Ignore @Test
  def fooFooFoo(): Unit = {
    val bar = baz
  }
}
<<< 4.3: #938 flag false, newline no
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.4: #938 flag true, newline no
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.5: #938 flag false, newline yes
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a {
  self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.6: #938 flag true, newline yes
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a {
 self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.7: #938 flag true, newline no, line too long
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { selfaaaaaaaaaaaaaaaa =>
    blah
}
>>>
trait a {
  selfaaaaaaaaaaaaaaaa =>
  blah
}
<<< 4.8 flag true, annot in param
optIn.annotationNewlines = true
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
)
object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1
      x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 => 3
      case <A>2</A> => 2
    }
  }
}
<<< 4.9 flag false, annot in param
optIn.annotationNewlines = false
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
)
object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1 x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 => 3
      case <A>2</A> => 2
    }
  }
}
<<< 4.10
maxColumn = 80
===
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]]],
     val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
     val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
     val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]])
     extends BaseEngine[EI, Q, P, A]
>>>
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]
    ]],
    val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
    val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
    val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]]
) extends BaseEngine[EI, Q, P, A]
<<< 5.1: case statements
a match {
  case b =>
    bb
  case c => cc
   ccc
  case d =>
   dd
   ddd
  case e =>
  case f => ff
}
>>>
a match {
  case b =>
    bb
  case c =>
    cc
    ccc
  case d =>
    dd
    ddd
  case e =>
  case f => ff
}
<<< 5.2 #1518
a match {
  case b: C => d.e match {
    case f => "g"
  }
}
>>>
a match {
  case b: C => d.e match {
      case f => "g"
    }
}
<<< 6.1: chain, no break
val a = b.c.d.e().f.g.h()
>>>
val a = b.c.d.e().f.g.h()
<<< 6.2: chain, break on =
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a =
  b.c
    .d.e(f)
    .g.h { i => j }
    .k().l({ m => n }, o)
<<< 6.2.1: chain, break on =, fold
newlines.selectChains = fold
===
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a =
  b.c.d.e(f).g.h { i => j }.k()
    .l({ m => n }, o)
<<< 6.2.2: chain, break on =, unfold
newlines.selectChains = unfold
===
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a =
  b.c
    .d
    .e(f)
    .g
    .h { i => j }
    .k()
    .l({ m => n }, o)
<<< 6.3: chain, breaks in the middle
val a = b.c
 .d.e() .f
 .g .h()
>>>
val a = b.c
  .d.e().f
  .g.h()
<<< 6.4: chain without apply
maxColumn = 72
includeNoParensInSelectChains = true
===
object a {
created filter (ref ⇒
         !ref.isTerminated && !ref
          .asInstanceOf[ActorRefWithCell]
          .underlying.isInstanceOf[UnstartedCell]) should ===(
        Seq.empty[ActorRef])
}
>>>
object a {
  created filter (ref ⇒
    !ref.isTerminated && !ref
      .asInstanceOf[ActorRefWithCell]
      .underlying.isInstanceOf[UnstartedCell]
  ) should ===(
    Seq.empty[ActorRef]
  )
}
<<< 6.5: chain with delayed indent after break
maxColumn = 70
===
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc
    .union(algoPredicts).groupByKey().mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount")
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
>>>
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc
    .union(algoPredicts).groupByKey().mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount"
        )
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
<<< 7.1.1: enumerator and guard short, for long
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
<<< 7.1.2: enumerators and guard short, for long, parens
object a {
  for (i <- 0 until n;
        j <- 0 until n if i + j == v)
   yield (i, j)
}
>>>
object a {
  for (
    i <- 0 until n;
    j <- 0 until n if i + j == v
  )
    yield (i, j)
}
<<< 7.1.2: enumerator and guard short, for long, parens
object a {
  def a = for (a <- b; if cc < dd) yield a
}
>>>
object a {
  def a = for (a <- b; if cc < dd)
    yield a
}
<<< 7.2: enumerator short, guard long
maxColumn = 30
===
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(b: List[Int])
      : List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
<<< 7.3: enumerator and guard short, for short
for (a <- b.sortBy(c)
 if a > 0) yield x
>>>
for (
  a <- b.sortBy(c)
  if a > 0
) yield x
<<< 7.4: enumerator and guard long
maxColumn = 17
===
val k = for {
  _ <- aaa + bbb
    if !onlyOne
  _ <- Future(aaa)
    if !onlyOne
  _ <- Future(2)
} yield ()
>>>
val k = for {
  _ <- aaa + bbb
  if !onlyOne
  _ <-
    Future(aaa)
  if !onlyOne
  _ <- Future(2)
} yield ()
<<< 7.5: multiple consecutive guards
maxColumn = 80
===
val allOps = (
  for {
    c ← classes
    m ← c.getMethods if !Modifier.isStatic(m.getModifiers); if !ignore(m.getName)
    if !m.getName.contains("$"); if !materializing(m)
  } yield m.getName
).toSet
>>>
val allOps = (
  for {
    c ← classes
    m ← c.getMethods if !Modifier.isStatic(m.getModifiers);
    if !ignore(m.getName)
    if !m.getName.contains("$"); if !materializing(m)
  } yield m.getName
).toSet
<<< 7.6: for-yield with select chain
maxColumn = 80
===
object a {
for {
       (listenAddress, listenerPromise) ← wrappedTransport.listen
       // Enforce ordering between the signalling of "listen ready" to upstream
       // and initialization happening in interceptListen
      _ ←
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
     } yield (augmentScheme(listenAddress), upstreamListenerPromise)
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
}
>>>
object a {
  for {
    (listenAddress, listenerPromise) ← wrappedTransport.listen
    // Enforce ordering between the signalling of "listen ready" to upstream
    // and initialization happening in interceptListen
    _ ←
      listenerPromise
        .tryCompleteWith(
          interceptListen(listenAddress, upstreamListenerPromise.future1)
        )
        .future2
  } yield (augmentScheme(listenAddress), upstreamListenerPromise)
  listenerPromise
    .tryCompleteWith(
      interceptListen(listenAddress, upstreamListenerPromise.future1)
    )
    .future2
}
<<< 7.7: for-yield enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (mean
        + mean * mean * y * 0.5 / shape
        - 0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y)
    )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (mean
    + mean * mean * y * 0.5 / shape
    - 0.5 * mean / shape * math
      .sqrt(
        4 * mean * shape * y + mean * mean * y * y
      ))
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< 7.8: for-yield partially enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (mean
        + mean * mean * y * 0.5 / shape) -
        0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y)
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x =
    (mean
      + mean * mean * y * 0.5 / shape) -
      0.5 * mean / shape * math
        .sqrt(
          4 * mean * shape * y + mean * mean * y * y
        )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< 7.9: for-yield fully and partially enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = ((mean
        + mean * mean * y * 0.5 / shape) -
        0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y))
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x =
    ((mean
      + mean * mean * y * 0.5 / shape) -
      0.5 * mean / shape * math
        .sqrt(
          4 * mean * shape * y + mean * mean * y * y
        ))
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< keep ctor body with zero args
val foo = new Bar { () =>
  f(42)
}
>>>
val foo = new Bar { () =>
  f(42)
}
<<< keep ctor body with zero args
val foo = new Bar { () => f(42) }
>>>
val foo = new Bar { () => f(42) }
<<< keep ctor body with wildcard arg
val foo = Bar { _ =>
  println("a")
}
>>>
val foo = Bar { _ =>
  println("a")
}
<<< keep apply with zero args
val foo = Bar { () =>
  f(42)
}
>>>
val foo = Bar { () =>
  f(42)
}
<<< 8.1: infix with longer left ||
indent.main = 4
===
val a =
  1 + 2 * 3 && 4 ^ 5 || 6 op
    7 map {
      8 % 9
    }
>>>
val a =
    1 + 2 * 3 && 4 ^ 5 || 6 op
        7 map {
            8 % 9
        }
<<< 8.2: infix with shorter left ||
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
>>>
val a =
  1 + 2 * 3 || 4 ^ 5 && 6 op 7 map {
    8 % 9
  }
<<< 8.3: infix with longer left ||, narrow
maxColumn = 20
indent.main = 3
===
val a = 1 + 2 * 3 && 4 ^ 5 || 6 op 7 map { 8 % 9 }
>>>
val a =
   1 + 2 * 3 && 4 ^ 5 || 6 op 7 map {
      8 % 9
   }
<<< 8.4: infix with shorter left ||, narrow
maxColumn = 17
===
{
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
val b = { 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 } || somethinglong }
}
>>>
{
  val a =
    1 + 2 * 3 || 4 ^ 5 && 6 op 7 map {
      8 % 9
    }
  val b = {
    1 + 2 * 3 || 4 ^ 5 && 6 op 7 map {
      8 % 9
    } || somethinglong
  }
}
<<< 8.5: sequences of infix operations
maxColumn = 75
runner.optimizer.forceConfigStyleOnOffset = 1000
===
val strings = Seq(
    "MetricEvaluatorResult:",
    s"  # engine params evaluated: ${engineParamsScores.size}") ++
    Seq(
      "Optimal Engine Params:",
      s"  $bestEPStr",
      "Metrics:",
      s"  $metricHeader: ${bestScore.score}") ++
    otherMetricHeaders.zip(bestScore.otherScores).map {
      case (h, s) => s"  $h: $s"
    } ++
    outputPath.toSeq.map { p =>
      s"The best variant params can be found in $p"
    }
>>>
val strings = Seq(
  "MetricEvaluatorResult:",
  s"  # engine params evaluated: ${engineParamsScores.size}"
) ++
  Seq(
    "Optimal Engine Params:",
    s"  $bestEPStr",
    "Metrics:",
    s"  $metricHeader: ${bestScore.score}"
  ) ++
  otherMetricHeaders.zip(bestScore.otherScores).map {
    case (h, s) => s"  $h: $s"
  } ++
  outputPath.toSeq.map { p =>
    s"The best variant params can be found in $p"
  }
<<< 8.6: assignment with short expression
object a {
  plugins(service.pluginType) += service.pluginName -> service
}
>>>
object a {
  plugins(
    service.pluginType
  ) += service.pluginName -> service
}
<<< 8.7
maxColumn = 80
===
val json = ("event" -> data("event")) ~ ("entityType" -> "user") ~
       ("entityId" -> data("userId")) ~ ("targetEntityType" -> "item") ~
       ("targetEntityId" -> data("itemId")) ~
       ("eventTime" -> data("timestamp")) ~ ("properties" -> (("context" ->
       (("ip" -> data("context[ip]")) ~ ("prop1" -> data("context[prop1]")
         .toDouble) ~ ("prop2" -> data("context[prop2]")))) ~
       ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
       ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))))
>>>
val json = ("event" -> data("event")) ~ ("entityType" -> "user") ~
  ("entityId" -> data("userId")) ~ ("targetEntityType" -> "item") ~
  ("targetEntityId" -> data("itemId")) ~
  ("eventTime" -> data("timestamp")) ~ ("properties" -> (("context" ->
    (("ip" -> data("context[ip]")) ~ ("prop1" -> data("context[prop1]")
      .toDouble) ~ ("prop2" -> data("context[prop2]")))) ~
    ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
    ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))))
<<< 8.8
maxColumn = 80
===
override def hashCode: Int = 41 + fields.hashCode
>>>
override def hashCode: Int = 41 + fields.hashCode
<<< 8.9
maxColumn = 80
===
object a {
val fields = JField("engineVariant", JString(i.engineVariant)) ::
   JField("engineFactory", JString(i.engineFactory)) ::
     JField("batch", JString(i.batch)) ::
     JField("env", Extraction.decompose(i.env)(DefaultFormats))
}
>>>
object a {
  val fields = JField("engineVariant", JString(i.engineVariant)) ::
    JField("engineFactory", JString(i.engineFactory)) ::
    JField("batch", JString(i.batch)) ::
    JField("env", Extraction.decompose(i.env)(DefaultFormats))
}
<<< 8.10
maxColumn = 80
===
object a {
  def isReservedPrefix(name: String): Boolean =
      name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
>>>
object a {
  def isReservedPrefix(name: String): Boolean =
    name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
<<< 8.11
maxColumn = 80
===
Some(
  ("ip" -> data.get("context[ip]")) ~ (
  "prop1" ->
     data.get("context[prop1]").map(_.toDouble)
))
>>>
Some(
  ("ip" -> data.get("context[ip]")) ~ (
    "prop1" ->
      data.get("context[prop1]").map(_.toDouble)
  )
)
<<< 8.12
maxColumn = 80
===
val json = (estype -> ("properties" -> ("status" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("startTime" ->
      ("type" -> "date")) ~ ("endTime" -> ("type" -> "date")) ~ ("engineId" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVersion" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVariant" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineFactory" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("batch" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("dataSourceParams" -> ("type" -> "string") ~ ("index" ->
        "not_analyzed")) ~ ("preparatorParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~ ("algorithmsParams" -> ("type" ->
          "string") ~ ("index" -> "not_analyzed")) ~ ("servingParams" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("status" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed"))))
>>>
val json = (estype -> ("properties" -> ("status" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("startTime" ->
  ("type" -> "date")) ~ ("endTime" -> ("type" -> "date")) ~ ("engineId" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVersion" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVariant" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineFactory" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("batch" ->
  ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
  ("dataSourceParams" -> ("type" -> "string") ~ ("index" ->
    "not_analyzed")) ~ ("preparatorParams" -> ("type" -> "string") ~
    ("index" -> "not_analyzed")) ~ ("algorithmsParams" -> ("type" ->
    "string") ~ ("index" -> "not_analyzed")) ~ ("servingParams" ->
    ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("status" ->
    ("type" -> "string") ~ ("index" -> "not_analyzed"))))
<<< 8.13
val a = b match {
  case i: EngineInstance =>
    JObject(
      JField("id", JString(i.id)) ::
        JField("status", JString(i.status)) ::
        JField("startTime", JString(i.startTime.toString)) ::
        JField("endTime", JString(i.endTime.toString)) ::
        JField("engineId", JString(i.engineId)) ::
        JField("engineVersion", JString(i.engineVersion)) ::
        JField("engineVariant", JString(i.engineVariant)) ::
        JField("engineFactory", JString(i.engineFactory)) ::
        JField("batch", JString(i.batch)) ::
        JField("env", Extraction.decompose(i.env)(DefaultFormats)) ::
        JField(
          "sparkConf",
          Extraction.decompose(i.sparkConf)(DefaultFormats)) ::
        JField("dataSourceParams", JString(i.dataSourceParams)) ::
        JField("preparatorParams", JString(i.preparatorParams)) ::
        JField("algorithmsParams", JString(i.algorithmsParams)) ::
        JField("servingParams", JString(i.servingParams)) ::
        Nil)
}
>>>
val a = b match {
  case i: EngineInstance =>
    JObject(
      JField("id", JString(i.id)) ::
        JField(
          "status",
          JString(i.status)
        ) ::
        JField(
          "startTime",
          JString(i.startTime.toString)
        ) ::
        JField(
          "endTime",
          JString(i.endTime.toString)
        ) ::
        JField(
          "engineId",
          JString(i.engineId)
        ) ::
        JField(
          "engineVersion",
          JString(i.engineVersion)
        ) ::
        JField(
          "engineVariant",
          JString(i.engineVariant)
        ) ::
        JField(
          "engineFactory",
          JString(i.engineFactory)
        ) ::
        JField(
          "batch",
          JString(i.batch)
        ) ::
        JField(
          "env",
          Extraction.decompose(i.env)(
            DefaultFormats
          )
        ) ::
        JField(
          "sparkConf",
          Extraction.decompose(
            i.sparkConf
          )(DefaultFormats)
        ) ::
        JField(
          "dataSourceParams",
          JString(i.dataSourceParams)
        ) ::
        JField(
          "preparatorParams",
          JString(i.preparatorParams)
        ) ::
        JField(
          "algorithmsParams",
          JString(i.algorithmsParams)
        ) ::
        JField(
          "servingParams",
          JString(i.servingParams)
        ) ::
        Nil
    )
}
<<< 8.14
maxColumn = 80
===
private lazy val subNode: Parser[SubNode] = rep(' ') ~>
  ((opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ {
    name => AttrAppendSubNode(name)
  }) |
  (opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ {
    name => AttrRemoveSubNode(name)
  }) |    (opt('*') ~ '[' ~> attrName <~ ']' ^^ {
     name => AttrSubNode(name)
   }) |

   ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
   ('<' ~ '*' ~ '>') ^^ (a => SurroundKids()) |
   ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
   ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
   '*' ^^ (a => KidsSubNode()) |
   '^' ~ '*' ^^ (a => SelectThisNode(true)) |
   '^' ~ '^' ^^ (a => SelectThisNode(false)))
>>>
private lazy val subNode: Parser[SubNode] = rep(' ') ~>
  ((opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ {
    name => AttrAppendSubNode(name)
  }) |
    (opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ {
      name => AttrRemoveSubNode(name)
    }) | (opt('*') ~ '[' ~> attrName <~ ']' ^^ {
      name => AttrSubNode(name)
    }) |

    ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
    ('<' ~ '*' ~ '>') ^^ (a => SurroundKids()) |
    ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
    ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
    ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
    ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
    '*' ^^ (a => KidsSubNode()) |
    '^' ~ '*' ^^ (a => SelectThisNode(true)) |
    '^' ~ '^' ^^ (a => SelectThisNode(false)))
<<< 8.15
maxColumn = 80
===
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
   import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~
        ("properties" -> (("email" -> data("data[email]")) ~
          ("email_type" -> data("data[email_type]")) ~
          ("merges" -> (("EMAIL" -> data("data[merges][EMAIL]")) ~
            ("FNAME" -> data("data[merges][FNAME]"))) ~
            ("LNAME" -> data("data[merges][LNAME]")) ~
            ("INTERESTS" -> data.get("data[merges][INTERESTS]")))) ~
          ("ip_opt" -> data("data[ip_opt]")) ~
          ("ip_signup" -> data("data[ip_signup]")))
      json
  }
}
>>>
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
    import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~
        ("properties" -> (("email" -> data("data[email]")) ~
          ("email_type" -> data("data[email_type]")) ~
          ("merges" -> (("EMAIL" -> data("data[merges][EMAIL]")) ~
            ("FNAME" -> data("data[merges][FNAME]"))) ~
            ("LNAME" -> data("data[merges][LNAME]")) ~
            ("INTERESTS" -> data.get("data[merges][INTERESTS]")))) ~
          ("ip_opt" -> data("data[ip_opt]")) ~
          ("ip_signup" -> data("data[ip_signup]")))
    json
  }
}
<<< 8.16
maxColumn = 80
===
override def preRestart(cause: Throwable, msg: Option[Any]) {
       if (master ne null) {
        master ! "failed with " + cause + " while processing " + msg
       }
       context stop self
     }
>>>
override def preRestart(cause: Throwable, msg: Option[Any]) {
  if (master ne null) {
    master ! "failed with " + cause + " while processing " + msg
  }
  context stop self
}
<<< 8.17
maxColumn = 80
===
object a {
   def `media-range-def` =
     rule {
       "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) |
        '*' ~ push("*") ~ push("*")
     }
}
>>>
object a {
  def `media-range-def` =
    rule {
      "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) |
        '*' ~ push("*") ~ push("*")
    }
}
<<< 8.18
maxColumn = 80
===
object a {
  (people.map(p => (p.name, p.age))
  // c1
  returning people.map(_.id)
  // c2
  into ((nameAge, id) => Person(id, nameAge._1, nameAge._2))
  )
}
>>>
object a {
  (people.map(p => (p.name, p.age))
  // c1
    returning people.map(_.id)
    // c2
    into ((nameAge, id) => Person(id, nameAge._1, nameAge._2)))
}
<<< 8.19
maxColumn = 80
===
def `day-name` =
     rule(
       "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
        "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6))
>>>
def `day-name` =
  rule(
    "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
      "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6)
  )
<<< 8.20
maxColumn = 80
===
HttpResponse(
   StatusCodes.ServiceUnavailable,
   entity = "The server was not able " +
   "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
>>>
HttpResponse(
  StatusCodes.ServiceUnavailable,
  entity = "The server was not able " +
    "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
<<< 8.21
maxColumn = 80
===
private val allParams: Map[String, String] = mandatoryParams +
    (
      "data-config" ->
        dummyOptionalConfigPath,
      "max-sales-mappers" ->
        "10",
      "overwrite" ->
        null,
      "keep" -> dummyOptionalMaxVersionCount
    )
>>>
private val allParams: Map[String, String] = mandatoryParams +
  (
    "data-config" ->
      dummyOptionalConfigPath,
    "max-sales-mappers" ->
      "10",
    "overwrite" ->
      null,
    "keep" -> dummyOptionalMaxVersionCount
  )
<<< 8.22
maxColumn = 40
===
"Terminating(" + reason + ")" +
                   (toDie.toSeq.sorted mkString
                     (
                      "\n" +
                        indent +
                        "   |    toDie: ", "\n" + indent + "   |           ", ""
                     ))
>>>
"Terminating(" + reason + ")" +
  (toDie.toSeq.sorted mkString
    (
      "\n" +
        indent +
        "   |    toDie: ",
      "\n" + indent + "   |           ",
      ""
    ))
<<< 8.23
maxColumn = 80
===
val ret = (if (dailyStats.isEmpty)
                   0
                 else {
                   val yestStats = dailyStats.last
                   val yestNav = yestStats.nav
                   (nav -
                     yestNav) / nav - 1
                 })
>>>
val ret = (if (dailyStats.isEmpty)
             0
           else {
             val yestStats = dailyStats.last
             val yestNav = yestStats.nav
             (nav -
               yestNav) / nav - 1
           })
<<< 8.24
maxColumn = 80
===
def isErrorEnabled(logClass: Class[_], logSource: String) =
    (eventStream.logLevel >= ErrorLevel) &&
      Logger(logClass, logSource).isErrorEnabled
>>>
def isErrorEnabled(logClass: Class[_], logSource: String) =
  (eventStream.logLevel >= ErrorLevel) &&
    Logger(logClass, logSource).isErrorEnabled
<<< 8.25
maxColumn = 80
===
def getShort(implicit byteOrder: ByteOrder): Short = {
    if (byteOrder == ByteOrder.BIG_ENDIAN)
      ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
    else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
      ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
     else throw new IllegalArgumentException("Unknown byte order " + byteOrder)
   }
>>>
def getShort(implicit byteOrder: ByteOrder): Short = {
  if (byteOrder == ByteOrder.BIG_ENDIAN)
    ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
  else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
    ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
  else throw new IllegalArgumentException("Unknown byte order " + byteOrder)
}
<<< 8.26
maxColumn = 80
===
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m)) changeMembers(membersByAge - m + m) // replace
  }
>>>
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m)) changeMembers(membersByAge - m + m) // replace
  }
<<< 8.27
maxColumn = 80
===
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and
    (resultAfter must beEqualTo(None))
}
>>>
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and
    (resultAfter must beEqualTo(None))
}
<<< 8.28
object a {
  val b = qual1 op1 { 1 + 2 + 3 + 4 + 5 } op2
    111 * 222 * 333 * 444 * 555 op3
    { "1 / 2 / 3 / 4 / 5 / 6 / 7" }
}
>>>
object a {
  val b = qual1 op1 {
    1 + 2 + 3 + 4 + 5
  } op2
    111 * 222 * 333 * 444 * 555 op3 {
      "1 / 2 / 3 / 4 / 5 / 6 / 7"
    }
}
<<< 8.29
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
>>>
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
<<< 8.30
object a {
  json should be(
    """aaa bbb ccc ddd eee fff ggg"""
  )
}
>>>
object a {
  json should be(
    """aaa bbb ccc ddd eee fff ggg"""
  )
}
<<< 8.31 indent after comment
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
>>>
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
<<< #1334 1: continue chain indent after a comment
class Foo {
  val vv = v.aaa //
  //
.bbb
.ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
>>>
class Foo {
  val vv = v.aaa //
    //
    .bbb
    .ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
<<< #1334 2: continue chain indent after a comment, a bit longer
class Foo {
  val vv = v.aaa //
  .bbb //
  //
  .ccc //
  .ddd
  .eee()
}
>>>
class Foo {
  val vv = v.aaa //
    .bbb //
    //
    .ccc //
    .ddd
    .eee()
}
<<< #1334 3: continue chain indent after a comment with apply
class Foo {
  val vv = v.aaa //
  .bbb() //
  //
  .ccc //
  .ddd()
}
>>>
class Foo {
  val vv = v.aaa //
    .bbb() //
    //
    .ccc //
    .ddd()
}
<<< #1334 4: continue chain indent after a comment with apply, longer
indent.main = 4
===
class Foo {
  val vv = v.aaa //
  .bbb() //
  .ccc() //
  .ddd()
}
>>>
class Foo {
    val vv = v.aaa //
        .bbb() //
        .ccc() //
        .ddd()
}
<<< #1334 5: select and a block apply after a comment
     val a: Vector[Array[Double]] = b.c
     // similarUserFeatures may not contain the requested user
   .map { x =>
       similarUserFeatures.get(x)
     }.flatten
     // another comment
     .map { foo =>
       bar
       }
       .tail
>>>
val a: Vector[Array[Double]] = b.c
  // similarUserFeatures may not contain the requested user
  .map { x =>
    similarUserFeatures.get(x)
  }.flatten
  // another comment
  .map { foo =>
    bar
  }
  .tail
<<< #1334 6: multiple select and a match after a comment
val a: Vector[Array[Double]] = b.c
       // Only handle first case, others will be fixed on the next pass.
  .headOption
  .a match {
 case None =>
 case _ =>
}
>>>
val a: Vector[Array[Double]] = b.c
  // Only handle first case, others will be fixed on the next pass.
  .headOption
  .a match {
  case None =>
  case _ =>
}
<<< #1888 check presence of comment, lack of break
maxColumn = 80
===
object a {
  def b(c: D): E = {
    val a = b.c
      .foo(_.tree.tpe =:= typeOf[D])
      .flatMap { x =>
        x.tree.children.tail.map { case E(F(g)) => g.asInstanceOf[String] }
      }
      .headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
>>>
object a {
  def b(c: D): E = {
    val a = b.c
      .foo(_.tree.tpe =:= typeOf[D])
      .flatMap { x =>
        x.tree.children.tail.map { case E(F(g)) => g.asInstanceOf[String] }
      }
      .headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
<<< binpack call, always
binPack.callSite = always
optIn.configStyleArguments = false
===
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")), G(Some(Seq(h, i)), Some(Seq(j, k)), a.b, c.d, e.f.g, h.i.j)).foo
  }
}
>>>
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")),
        G(Some(Seq(h, i)),
          Some(Seq(j, k)), a.b, c.d,
          e.f.g, h.i.j)).foo
  }
}
<<< binpack call, oneline
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")), G(Some(Seq(h, i)), Some(Seq(j, k)), a.b, c.d, e.f.g, h.i.j)).foo
  }
}
>>>
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")),
        G(Some(Seq(h, i)),
          Some(Seq(j, k)), a.b, c.d,
          e.f.g, h.i.j)
      ).foo
  }
}
<<< binpack call, oneline, with syntaxNL, single arg
maxColumn = 60
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  val readOut = new ReadOnlyOutputDirectory("main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin)
}
>>>
object a {
  val readOut =
    new ReadOnlyOutputDirectory("main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin)
}
<<< binpack call, oneline, with syntaxNL, multiple args
maxColumn = 60
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  val readOut = new ReadOnlyOutputDirectory("main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin, "main.js.map" -> raw"""{
          |  "file": "main.js",
          |  "other key": 1
          |}""".stripMargin)
}
>>>
object a {
  val readOut = new ReadOnlyOutputDirectory(
    "main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin,
    "main.js.map" -> raw"""{
          |  "file": "main.js",
          |  "other key": 1
          |}""".stripMargin
  )
}
<<< binPack with named parameter values, danglingParentheses
binPack.preset = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
<<< binPack with named parameter values, !danglingParentheses
binPack.preset = true
optIn.configStyleArguments = false
danglingParentheses.callSite = false
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    ))
}
<<< literalsIncludeSimpleExpr with named parameter values, danglingParentheses
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
<<< literalsIncludeSimpleExpr with named parameter values, !danglingParentheses
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = false
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)))
}
<<< binPack.literals, danglingParentheses
maxColumn = 100
binPack.literalArgumentLists = true
binPack.literalsExclude = []
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  foo(
    bar.baz(Seq(
      Qux(
        "", 1, "par1", "2018-01-01", "2018-12-31", "2018-01-01", "2018-02-01", None, None, 1000,
        Some(0), Some(1), foo = Some("bar")
      )
    ))
  )
}
>>>
object a {
  foo(
    bar.baz(Seq(
      Qux(
        "", 1, "par1", "2018-01-01", "2018-12-31", "2018-01-01", "2018-02-01", None, None, 1000,
        Some(0), Some(1), foo = Some("bar")
      )
    ))
  )
}
<<< binPack.literals, danglingParentheses, avoid fold
maxColumn = 100
binPack.literalArgumentLists = true
binPack.literalsExclude = []
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
runner.optimizer.forceConfigStyleOnOffset = 150
===
object a {
  private val audience3 = apiAudience(
    3, "b_name", Sams, Inid, "2", "created-by-user2", "updated-by-user2"
  ).copy(
    updatedAt = nowDate.minusDays(15),
    audienceSizeOnsite = Some(3333),
    audienceSizeOffsite = Some(1)
  )
}
>>>
object a {
  private val audience3 = apiAudience(
    3, "b_name", Sams, Inid, "2", "created-by-user2", "updated-by-user2"
  ).copy(
    updatedAt = nowDate.minusDays(15),
    audienceSizeOnsite = Some(3333),
    audienceSizeOffsite = Some(1)
  )
}
<<< binPack indent expiresOn=Before when dangle
binPack.preset = true
optIn.configStyleArguments = false
===
object a {
   protected def foo[U](bar: String, baz: Seq[String] = Seq.empty)(
       f: HttpResponse => U
  ): U = qux
}
>>>
object a {
  protected def foo[U](bar: String,
      baz: Seq[String] = Seq.empty)(
      f: HttpResponse => U
  ): U = qux
}
<<< #1973 1
maxColumn = 25
indent.extendSite = 2
===
object a {
  object Foo
  extends Bar
  with Baz
}
>>>
object a {
  object Foo
    extends Bar with Baz
}
<<< #1973 2
maxColumn = 25
indent.extendSite = 2
===
object a {
  case class Foo(
    a: Boolean,
    b: String,
    c: String,
  )
  extends Bar
  with Baz
}
>>>
object a {
  case class Foo(
      a: Boolean,
      b: String,
      c: String
  ) extends Bar
    with Baz
}
<<< #1973 3
maxColumn = 25
indent.extendSite = 2
===
object a {
  trait Foo
  extends Bar
  with Baz
}
>>>
object a {
  trait Foo
    extends Bar with Baz
}
<<< #1989 1
maxColumn = 80
===
object a {
  val schema = StructType(
    Seq(
      StructField("fieldA", DataTypes.StringType),
      StructField("fieldB", DataTypes.StringType)
    ))
}
>>>
object a {
  val schema = StructType(
    Seq(
      StructField("fieldA", DataTypes.StringType),
      StructField("fieldB", DataTypes.StringType)
    )
  )
}
<<< #1989 2
maxColumn = 80
===
object a {
  val schema = StructType(Seq(
    StructField("fieldA", DataTypes.StringType),
    StructField("fieldB", DataTypes.StringType)
  ))
}
>>>
object a {
  val schema = StructType(Seq(
    StructField("fieldA", DataTypes.StringType),
    StructField("fieldB", DataTypes.StringType)
  ))
}
<<< def followed by comment, break, wrap
maxColumn = 100
comments.wrap = trailing
===
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  def foo(bar: Int): Int =
    /* comment line 1 comment line 2 */
    baz
}
<<< def followed by comment, break, no wrap
maxColumn = 100
comments.wrap = no
===
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
<<< def followed by comment, no break
maxColumn = 100
comments.wrap = trailing
===
object a {
  def foo(bar: Int): Int = /* comment */
    baz
}
>>>
object a {
  def foo(bar: Int): Int = /* comment */
    baz
}
<<< val followed by comment, break, wrap
maxColumn = 100
comments.wrap = trailing
===
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  val foo: Int =
    /* comment line 1 comment line 2 */
    baz
}
<<< val followed by comment, break, no wrap
maxColumn = 100
comments.wrap = no
===
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
<<< val followed by comment, no break
maxColumn = 100
comments.wrap = trailing
===
object a {
  val foo: Int = /* comment */
    baz
}
>>>
object a {
  val foo: Int = /* comment */
    baz
}
<<< #2113 if-apply 1
object a {
  if (a) Seq(a,
    b
  )
  else Seq(
    a,
    b
  )
}
>>>
object a {
  if (a) Seq(a, b)
  else Seq(
    a,
    b
  )
}
<<< #2113 if-apply 2
maxColumn = 30
===
object a {
  if (a) Seq(
    aaaaaaaaaa, bbbbbbbbbb)
  else Seq(
    aaaaaaaaaa, bbbbbbbbbb)
}
>>>
object a {
  if (a) Seq(
    aaaaaaaaaa,
    bbbbbbbbbb
  )
  else Seq(
    aaaaaaaaaa,
    bbbbbbbbbb
  )
}
<<< #2113 def 1
maxColumn = 72
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) { // c1
      d.name should be("dir" + step)
      validate(d.parent, step - 1)
    }
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) { // c1
      d.name should be("dir" + step)
      validate(d.parent, step - 1)
    }
}
<<< #2113 def 2
maxColumn = 100
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) // c1
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) // c1
    d.name should be("dir" + step)
}
<<< #2113 def 3
maxColumn = 70
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) /* c1 */
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) /* c1 */
      d.name should be("dir" + step)
}
<<< #2113 def 4
object a {
  def validate(d: Directory): Unit = if (step != 0)
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: Directory): Unit =
    if (step != 0)
      d.name should be("dir" + step)
}
<<< #2113 def 5
maxColumn = 80
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) /* c1 */ { /* c2 */
    d.name should be("dir" + step)
  }
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
}
<<< #2113 case 1
object a {
  a match {
    case a => d.name.should.be_dir("step1", "step2")
  }
}
>>>
object a {
  a match {
    case a => d.name.should.be_dir(
        "step1",
        "step2"
      )
  }
}
<<< #2113 case 2
object a {
  a match {
    case a => d.name.should.be_dir("step1", "plus", "step2")
  }
}
>>>
object a {
  a match {
    case a => d.name.should.be_dir(
        "step1",
        "plus",
        "step2"
      )
  }
}
<<< #2113 case 3
object a {
  a match {
    case a => d.name.should.be("dir").plus("step1", "step2")
  }
}
>>>
object a {
  a match {
    case a =>
      d.name.should.be("dir").plus(
        "step1",
        "step2"
      )
  }
}
<<< #2113 case 4
object a {
  a match {
    case a => d.name should be("dir")
  }
}
>>>
object a {
  a match {
    case a => d.name should be("dir")
  }
}
<<< #2113 case 5
object a {
  a match {
    case a => d.name should be("dir" + step)
  }
}
>>>
object a {
  a match {
    case a =>
      d.name should be("dir" + step)
  }
}
<<< #2113 case 6
object a {
  a match {
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 case 7
object a {
  a match {
    case a => if (step != 0) /* c1 */
      d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */)
      d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ {
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a => if (step != 0) /* c1 */
        d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */ )
        d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
        d.name should be("dir" + step)
      }
    case a => if (step != 0) /* c1 */ {
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 case 7, beforeMultiline = fold
newlines.beforeMultiline = fold
===
object a {
  a match {
    case a => if (step != 0) /* c1 */
      d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */)
      d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ {
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a => if (step != 0) /* c1 */
        d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */ )
        d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
        d.name should be("dir" + step)
      }
    case a => if (step != 0) /* c1 */ {
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 case 7, beforeMultiline = unfold
newlines.beforeMultiline = unfold
===
object a {
  a match {
    case a => if (step != 0) /* c1 */
      d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */)
      d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ {
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a =>
      if (step != 0) /* c1 */
        d.name should be("dir" + step)
    case a =>
      if (step != 0 /* c1 */ )
        d.name should be("dir" + step)
    case a =>
      if (step != 0) { /* c1 */
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ {
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 original
maxColumn = 80
===
object a {
  if (!someBooleanValue) Command.invalid
  else if (someIntValue != 1) Command.invalid
  else someCollection.get(args.head) match {
      case it @ Some(_) =>
        someService.setSomeValue(it)
        Command.success
      case None => Command.invalid
    }
}
>>>
object a {
  if (!someBooleanValue) Command.invalid
  else if (someIntValue != 1) Command.invalid
  else someCollection.get(args.head) match {
    case it @ Some(_) =>
      someService.setSomeValue(it)
      Command.success
    case None => Command.invalid
  }
}
<<< #2137
pubSubMessage match {
  case message: IngestionMessage => (
    foo.bar.baz
  ) /* very long winded comment */
  case message: IngestionMessage =>
    (foo) /* comment */
  case message: IngestionMessage => (foo.bar.baz)
  case message: UploadMessage => {
    val services = makeUploadServices()

    UploadSubscriber(services).processEff(message)
  }
  case message: IngestionMessage => (
      IngestionSubscriber.defaultServices
    ).processEff.message()
}
>>>
pubSubMessage match {
  case message: IngestionMessage => (
    foo.bar.baz
  ) /* very long winded comment */
  case message: IngestionMessage =>
    (foo) /* comment */
  case message: IngestionMessage => (
    foo.bar.baz
  )
  case message: UploadMessage => {
    val services = makeUploadServices()

    UploadSubscriber(
      services
    ).processEff(message)
  }
  case message: IngestionMessage => (
      IngestionSubscriber.defaultServices
    ).processEff.message()
}
<<< #2137 tuple with ->, match
maxColumn = 20
===
a match {
  case (k, v) => (k -> v)
}
>>>
a match {
  case (k, v) =>
    (k -> v)
}
<<< #2137 tuple with ->, partial func
maxColumn = 20
===
a {
  case (k, v) => (k -> v)
}
>>>
a {
  case (k, v) =>
    (k -> v)
}
<<< #2137 non-matching parens
a match {
  case (k, v) => () => k(v)
}
>>>
a match {
  case (k, v) => () => k(v)
}
<<< #2137 empty parens
maxColumn = 17
===
a match {
  case (k, v) => ()
}
>>>
a match {
  case (k, v) =>
    ()
}
<<< #2158 for with guard
maxColumn = 70
danglingParentheses.preset = false
===
object a {
  for (method <- e.getMethods if break && method.hasModifierProperty("static")) {
    // noop
  }
}
>>>
object a {
  for (method <- e.getMethods
    if break && method.hasModifierProperty("static")) {
    // noop
  }
}
<<< #2158 val and no val
object a {
  val bbb = c match {
    case _ =>
  }
  bbb = c match {
    case _ =>
  }
}
>>>
object a {
  val bbb = c match {
    case _ =>
  }
  bbb = c match {
    case _ =>
  }
}
<<< #2219
a match {
  case ( Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux"
       ) =>
    (if (foo) (foo) + bar
    else foo + (bar)) + (baz)
  case ( Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux" ) => (foo)
}
>>>
a match {
  case (Root / "foo"
      | Root / "bar"
      | Root / "baz" / _ / "qux"
      ) =>
    (if (foo) (foo) + bar
     else foo + (bar)) + (baz)
  case (Root / "foo"
      | Root / "bar"
      | Root / "baz" / _ / "qux") => (
    foo
  )
}
<<< #2219 with spaces
spaces.inParentheses = true
===
a match {
  case (Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux"
       ) =>
    (if (foo) (foo) + bar
    else foo + (bar)) + (baz)
  case (Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux") => (foo)
}
>>>
a match {
  case ( Root / "foo"
      | Root / "bar"
      | Root / "baz" / _ / "qux"
      ) =>
    ( if (foo) ( foo ) + bar
      else foo + ( bar ) ) + ( baz )
  case ( Root / "foo"
      | Root / "bar"
      | Root / "baz" / _ / "qux" ) => (
    foo
  )
}
<<< #2250
danglingParentheses.callSite = true
===
object a {
  val a = foo(
     bar = baz =>
       qux(b =
         c
      )
   )
}
>>>
object a {
  val a = foo(
    bar = baz =>
      qux(b =
        c
      )
  )
}
<<< #2400 forceBeforeMultilineAssign = never
newlines.forceBeforeMultilineAssign = never
===
class Test {
  val a = foo(
    1,
    2
  )
  val a = functionCall(
    111,
    222
  )
  val a = /* c */ functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
>>>
class Test {
  val a = foo(
    1,
    2
  )
  val a = functionCall(
    111,
    222
  )
  val a = /* c */ functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
<<< #2400 forceBeforeMultilineAssign = any
newlines.forceBeforeMultilineAssign = any
===
class Test {
  val a = foo(
    1,
    2
  )
  val a = functionCall(
    111,
    222
  )
  val a = /* c */ functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
>>>
class Test {
  val a =
    foo(
      1,
      2
    )
  val a =
    functionCall(
      111,
      222
    )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
<<< #2400 infix forceBeforeMultilineAssign = never
newlines.forceBeforeMultilineAssign = never
maxColumn = 25
===
class Test {
  val foo = bar +
    baz * qux + 1 + 2
}
>>>
class Test {
  val foo = bar +
    baz * qux + 1 + 2
}
<<< #2400 infix forceBeforeMultilineAssign = any
newlines.forceBeforeMultilineAssign = any
maxColumn = 25
===
class Test {
  val foo = bar +
    baz * qux + 1 + 2
}
>>>
class Test {
  val foo =
    bar +
      baz * qux + 1 + 2
}
<<< #2400 nesting forceBeforeMultilineAssign = topMember
maxColumn = 27
newlines.forceBeforeMultilineAssign = topMember
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() = barBar(
          bazBaz,
          quxQux
        )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = anyMember
maxColumn = 27
newlines.forceBeforeMultilineAssign = anyMember
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo =
          barBar(
            bazBaz,
            quxQux
          )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = any
maxColumn = 27
newlines.forceBeforeMultilineAssign = any
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
      for {
        foo <- barBar(bazBaz, quxQux)
        foo = barBar(bazBaz, quxQux)
      } yield foo
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo =
          barBar(
            bazBaz,
            quxQux
          )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
      for {
        foo <-
          barBar(
            bazBaz,
            quxQux
          )
        foo =
          barBar(
            bazBaz,
            quxQux
          )
      } yield foo
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = def
maxColumn = 27
newlines.forceBeforeMultilineAssign = def
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = never
maxColumn = 27
newlines.forceBeforeMultilineAssign = never
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
      for {
        foo <- barBar(bazBaz, quxQux)
        foo = barBar(bazBaz, quxQux)
      } yield foo
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() = barBar(
          bazBaz,
          quxQux
        )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
      for {
        foo <- barBar(
          bazBaz,
          quxQux
        )
        foo = barBar(
          bazBaz,
          quxQux
        )
      } yield foo
    }
  }
}
<<< #2422
runner.dialect = scala3
===
type T = A1 & A2 | A3 & A4 | A5 & A6 | A7 & A8 | A9 & A10[T10] |
  A11 & A12 | A13 & A14 | A15 & A16 | A17 & A18 | A19 & A20[T20] |
  A21 & A22 | A23 & A24 | A25 & A26 | A27 & A28 | A29 & A30[T30] |
  A31 & A32 | A33 & A34 | A35 & A36 | A37 & A38 | A39 & A40[T40] |
  A41 & A42 | A43 & A44 | A45 & A46 | A47 & A48 | A49 & A50[T50] |
  A51 & A52 | A53 & A54 | A55 & A56 | A57 & A58 | A59 & A60[T60] |
  A61 & A62 | A63 & A64 | A65 & A66 | A67 & A68 | A69 & A70[T70]
>>>
type T =
  A1 & A2 | A3 & A4 | A5 & A6 | A7 & A8 | A9 & A10[
    T10
  ] |
    A11 & A12 | A13 & A14 | A15 & A16 | A17 & A18 | A19 & A20[
      T20
    ] |
    A21 & A22 | A23 & A24 | A25 & A26 | A27 & A28 | A29 & A30[
      T30
    ] |
    A31 & A32 | A33 & A34 | A35 & A36 | A37 & A38 | A39 & A40[
      T40
    ] |
    A41 & A42 | A43 & A44 | A45 & A46 | A47 & A48 | A49 & A50[
      T50
    ] |
    A51 & A52 | A53 & A54 | A55 & A56 | A57 & A58 | A59 & A60[
      T60
    ] |
    A61 & A62 | A63 & A64 | A65 & A66 | A67 & A68 | A69 & A70[
      T70
    ]
<<< #2422 with comments
runner.dialect = scala3
===
type T = A1 & A2 | A3 & A4 | A5 & A6 /* c1 */ | /* c2 */ A7 & A8 | A9 & A10[T10] |
  A11 & A12 | A13 & A14 | A15 & A16 /* c1 */ | /* c2 */ A17 & A18 | A19 & A20[T20] |
  A21 & A22 | A23 & A24 | A25 & A26 /* c1 */ | /* c2 */ A27 & A28 | A29 & A30[T30] |
  A31 & A32 | A33 & A34 | A35 & A36 /* c1 */ | /* c2 */ A37 & A38 | A39 & A40[T40] |
  A41 & A42 | A43 & A44 | A45 & A46 /* c1 */ | /* c2 */ A47 & A48 | A49 & A50[T50] |
  A51 & A52 | A53 & A54 | A55 & A56 /* c1 */ | /* c2 */ A57 & A58 | A59 & A60[T60] |
  A61 & A62 | A63 & A64 | A65 & A66 /* c1 */ | /* c2 */ A67 & A68 | A69 & A70[T70]
>>>
type T =
  A1 & A2 | A3 & A4 | A5 & A6 /* c1 */ | /* c2 */ A7 & A8 | A9 & A10[
    T10
  ] |
    A11 & A12 | A13 & A14 | A15 & A16 /* c1 */ | /* c2 */ A17 & A18 | A19 & A20[
      T20
    ] |
    A21 & A22 | A23 & A24 | A25 & A26 /* c1 */ | /* c2 */ A27 & A28 | A29 & A30[
      T30
    ] |
    A31 & A32 | A33 & A34 | A35 & A36 /* c1 */ | /* c2 */ A37 & A38 | A39 & A40[
      T40
    ] |
    A41 & A42 | A43 & A44 | A45 & A46 /* c1 */ | /* c2 */ A47 & A48 | A49 & A50[
      T50
    ] |
    A51 & A52 | A53 & A54 | A55 & A56 /* c1 */ | /* c2 */ A57 & A58 | A59 & A60[
      T60
    ] |
    A61 & A62 | A63 & A64 | A65 & A66 /* c1 */ | /* c2 */ A67 & A68 | A69 & A70[
      T70
    ]
<<< #2226
object Class extends Base
   with Trait1
   with Trait2 {

}
>>>
object Class
    extends Base
    with Trait1
    with Trait2 {}
<<< #2561 scala 2: defn, no align
align.preset = none
newlines.beforeOpenParenDefnSite = source
indent.extraBeforeOpenParenDefnSite = 3
newlines.sometimesBeforeColonInMethodReturnType = true
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc(foo1: String)(foo2: String): String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (implicit foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
     (foo1: String)
     (
         foo2: String,
         foo3: String,
         foo4: Map[String, Map[
           String,
           Map[String, String]
         ]]
     ) // this line doesn't fit
     (foo5: String) {
  def fooFunc(foo1: String)
       (foo2: String): String = ???
  def fooFunc
       (foo1: String)
       (foo2: String)
       (foo3: String)
       (foo4: String)
       (foo5: String)
       : (
           String,
           String,
           String,
           String
       ) = ???
  def notAnInterestingFunction
       (foo1: String)
       (
           foo2: String,
           foo3: String,
           foo4: Map[String, Map[
             String,
             Map[String, String]
           ]]
       ) // this line doesn't fit
       (foo5: String)
       (implicit
           foo6: Int,
           foo7: Int,
           foo8: Int,
           foo9: Int,
           foo10: Int,
           foo11: Int,
           foo12: Int
       ) // this line also doesn't fit
       : (
           String,
           String,
           String,
           String
       ) = ???
}
<<< #2561 scala 2: defn, align
align.preset = none
align.openParenDefnSite = true
newlines.beforeOpenParenDefnSite = keep
newlines.sometimesBeforeColonInMethodReturnType = true
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)(foo2: String): String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (implicit foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
  (foo1: String)
  (foo2: String,
   foo3: String,
   foo4: Map[
     String,
     Map[String, Map[String, String]]
   ]
  ) // this line doesn't fit
  (foo5: String) {
  def fooFunc
    (foo1: String)(foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) =
    ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String,
     foo3: String,
     foo4: Map[
       String,
       Map[String, Map[String, String]]
     ]
    ) // this line doesn't fit
    (foo5: String)
    (implicit
        foo6: Int,
        foo7: Int,
        foo8: Int,
        foo9: Int,
        foo10: Int,
        foo11: Int,
        foo12: Int
    ) // this line also doesn't fit
    : (String, String, String, String) =
    ???
}
<<< #2561 scala 3: defn, no align
align.preset = none
runner.dialect = scala3
newlines.beforeOpenParenDefnSite = keep
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)(foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (using foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
  (foo1: String)
  (
      foo2: String,
      foo3: String,
      foo4: Map[
        String,
        Map[String, Map[String, String]]
      ]
  ) // this line doesn't fit
  (foo5: String) {
  def fooFunc
    (foo1: String)(foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) =
    ???
  def notAnInterestingFunction
    (foo1: String)
    (
        foo2: String,
        foo3: String,
        foo4: Map[String, Map[
          String,
          Map[String, String]
        ]]
    ) // this line doesn't fit
    (foo5: String)
    (using
        foo6: Int,
        foo7: Int,
        foo8: Int,
        foo9: Int,
        foo10: Int,
        foo11: Int,
        foo12: Int
    ) // this line also doesn't fit
    : (String, String, String, String) =
    ???
}
<<< #2561 scala 3: defn, align
align.preset = none
align.openParenDefnSite = true
runner.dialect = scala3
newlines.beforeOpenParenDefnSite = source
indent.significant = 3
indent.extraBeforeOpenParenDefnSite = 3
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc(foo1: String)(foo2: String):
    String
  def fooFunc(foo1: String)(foo2: String):
    String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String):
    (String, String, String, String)
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String):
    (String, String, String, String) =
    bar
    baz
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (using foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
     (foo1: String)
     (foo2: String,
      foo3: String,
      foo4: Map[
        String,
        Map[String, Map[String, String]]
      ]
     ) // this line doesn't fit
     (foo5: String) {
  def fooFunc(foo1: String)
    (foo2: String): String
  def fooFunc(foo1: String)
       (foo2: String): String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String)
  def fooFunc
        (foo1: String)
        (foo2: String)
        (foo3: String)
        (foo4: String)
        (foo5: String)
        : (
            String,
            String,
            String,
            String
        ) =
     bar
     baz
  def notAnInterestingFunction
       (foo1: String)
       (foo2: String,
        foo3: String,
        foo4: Map[String, Map[
          String,
          Map[String, String]
        ]]
       ) // this line doesn't fit
       (foo5: String)
       (using
           foo6: Int,
           foo7: Int,
           foo8: Int,
           foo9: Int,
           foo10: Int,
           foo11: Int,
           foo12: Int
       ) // this line also doesn't fit
       : (
           String,
           String,
           String,
           String
       ) = ???
}
<<< #2561 scala 3: call, no align
maxColumn = 25
align.preset = none
runner.dialect = scala3
newlines.beforeOpenParenCallSite = source
newlines.beforeOpenParenDefnSite = source
===
object a {
  // class with no body
  case class fooClass
   (foo1: String)
   (foo2: String,
    foo3: String,
    foo4: Map[
      String,
      Map[String, Map[String, String]]
    ]
   )
   (foo5: String)
  def f = fooFunc("foo1")("foo2")("foo3")("foo4")("foo5")
  def f =
    fooFunc
      ("foo1")("foo2")("foo3")("foo4")("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2", "foo3", "foo4")
      ("foo5")
      (using "foo6", "foo7", "foo8", "foo9", "foo10", "foo11", "foo12")
}
>>>
object a {
  // class with no body
  case class fooClass
    (foo1: String)
    (
        foo2: String,
        foo3: String,
        foo4: Map[
          String,
          Map[
            String,
            Map[
              String,
              String
            ]
          ]
        ]
    )
    (foo5: String)
  def f = fooFunc("foo1")
    ("foo2")("foo3")
    ("foo4")("foo5")
  def f =
    fooFunc
      ("foo1")("foo2")
      ("foo3")("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      (
        "foo2",
        "foo3",
        "foo4"
      )
      ("foo5")
      (using
        "foo6",
        "foo7",
        "foo8",
        "foo9",
        "foo10",
        "foo11",
        "foo12"
      )
}
<<< #2561 scala 3: call, align
maxColumn = 25
align.preset = none
align.openParenCallSite = true
runner.dialect = scala3
newlines.beforeOpenParenCallSite = keep
===
object a {
  def f = fooFunc("foo1")("foo2")("foo3")("foo4")("foo5")
  def f =
    fooFunc("foo1")("foo2")("foo3")("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2", "foo3", "foo4")
      ("foo5")
      (using "foo6", "foo7", "foo8", "foo9", "foo10", "foo11", "foo12")
}
>>>
object a {
  def f = fooFunc("foo1")
    ("foo2")("foo3")
    ("foo4")("foo5")
  def f =
    fooFunc("foo1")
      ("foo2")("foo3")
      ("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2",
       "foo3",
       "foo4"
      )
      ("foo5")
      (using
        "foo6",
        "foo7",
        "foo8",
        "foo9",
        "foo10",
        "foo11",
        "foo12"
      )
}
<<< #2561 enum, single arg, wide
maxColumn = 80
runner.parser = source
runner.dialect = scala3
newlines {
  beforeOpenParenDefnSite = source
  beforeOpenParenCallSite = source
}
===
package dev.muve.vdom

enum Namespace(val uri: String | Null):
   case xhtml extends Namespace("http://www.w3.org/1999/xhtml")
   case xlink extends Namespace("http://www.w3.org/1999/xlink")
   case xmlns extends Namespace("http://www.w3.org/2000/xmlns/")
   case svg extends Namespace("http://www.w3.org/2000/svg")
   case muve extends Namespace("http://dev.muve/2021/muve")

   case none extends Namespace(null)
>>>
package dev.muve.vdom

enum Namespace(val uri: String | Null):
  case xhtml extends Namespace("http://www.w3.org/1999/xhtml")
  case xlink extends Namespace("http://www.w3.org/1999/xlink")
  case xmlns extends Namespace("http://www.w3.org/2000/xmlns/")
  case svg extends Namespace("http://www.w3.org/2000/svg")
  case muve extends Namespace("http://dev.muve/2021/muve")

  case none extends Namespace(null)
<<< #2561 nested apply as parameter
maxColumn = 80
runner.dialect = scala3
newlines.beforeOpenParenCallSite = unfold
===
line
  (x1 := centre - offset * s,
   y1 := centre + offset * c,
   x2 := centre + (length - offset) * s,
   y2 := centre - (length - offset) * c,
   (SvgA.filter := "url(#handShadow)").when(hasShadow),
   strokeWidth := width,
   stroke := colour)
>>>
line
  (
    x1 := centre - offset * s,
    y1 := centre + offset * c,
    x2 := centre + (length - offset) * s,
    y2 := centre - (length - offset) * c,
    (SvgA.filter := "url(#handShadow)").when(hasShadow),
    strokeWidth := width,
    stroke := colour
  )
<<< bracketDefnSite=oneline
maxColumn = 100
binPack.bracketCallSite = oneline
binPack.bracketDefnSite = oneline
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketDefnSite=always
maxColumn = 100
binPack.bracketCallSite = always
binPack.bracketDefnSite = always
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketDefnSite=never
maxColumn = 100
binPack.bracketCallSite = never
binPack.bracketDefnSite = never
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketCallSite = Oneline in return type, !sometimesBeforeColonInMethodReturnType
maxColumn = 50
binPack.bracketCallSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(bb: BB, cc: CC,
    dd: DD = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      bb: BB,
      cc: CC,
      dd: DD = DDD.ddd
  ): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.xxxSite = Oneline, !sometimesBeforeColonInMethodReturnType
maxColumn = 50
binPack.callSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(bb: BB, cc: CC,
    dd: DD = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(bb: BB, cc: CC,
      dd: DD = DDD.ddd): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(dd: DD[AA[BB], CC] =
        DDD.ddd): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also bracketCallSite
binPack.bracketCallSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(dd: DD[AA[BB], CC] =
        DDD.ddd): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also align
align.openParenDefnSite = true
optIn.configStyleArguments = false
danglingParentheses.preset = false
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = true
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDDD.dddd) = {
      // c
      qux
    }
}
>>>
object a {
  def foo(dd: DD[AA[BB], CC] =
            DDDD.dddd) = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also bracketCallSite+align
align.openParenDefnSite = true
optIn.configStyleArguments = false
danglingParentheses.preset = false
binPack.bracketCallSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = true
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDDD.dddd) = {
      // c
      qux
    }
}
>>>
object a {
  def foo(dd: DD[AA[BB], CC] =
            DDDD.dddd) = {
    // c
    qux
  }
}
<<< bracketCallSite = Oneline, nested with one arg
maxColumn = 100
binPack.bracketCallSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe Some(Left(
    s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
  ))

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](apiAudience
      .copy(status = AudienceStatus.Pending.name))
  )
}
<<< bracketCallSite = always, nested with one arg
maxColumn = 100
binPack.bracketCallSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe Some(Left(
    s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
  ))

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](apiAudience
      .copy(status = AudienceStatus.Pending.name))
  )
}
<<< binPack.callSite = Oneline, nested with one arg
maxColumn = 100
binPack.callSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe Some(Left(
    s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
  ))

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](apiAudience
      .copy(status = AudienceStatus.Pending.name))
  )
}
<<< binPack.callSite = Oneline, nested with one arg, several options
maxColumn = 100
binPack.callSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
  PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(
    service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
<<< binPack.callSite = Oneline, nested with one arg, more options
maxColumn = 100
binPack.callSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(
    service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default)
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default)
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default).thenReturn(
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(
    service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default)
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default)
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default).thenReturn(
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))
  )

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
<<< binPack.callSite = always, nested with one arg
maxColumn = 100
binPack.callSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](apiAudience
        .copy(status = AudienceStatus.Pending.name))
  )
}
<<< binPack.callSite = always, nested with one arg, several options
maxColumn = 100
binPack.callSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
  PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default
    )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default
    )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
<<< binPack.callSite = always, nested with one arg, no breaks
maxColumn = 100
binPack.callSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default)).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default)).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
      Page(0, Page.maxPageLimit), Order.default)).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
      Page(0, Page.maxPageLimit), Order.default)).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default).thenReturn(PageResult(Seq(audience,
        audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
    PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
<<< #2821 default
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
<<< #2821 keep
newlines.beforeMultiline = keep
===
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
<<< #2821 fold
newlines.beforeMultiline = fold
===
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
<<< #2821 unfold
newlines.beforeMultiline = unfold
===
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
<<< TryWithHandler: newline after catch
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, short
maxColumn = 12
===
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, space comment
object a {
  def foo = try
    a
  catch /* c1 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch /* c1 */
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, break comment
object a {
  def foo = try
    a
  catch
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch
      /* c2 */
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch /* c1 */
      /* c2 */
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */ bar
  finally
    a
}
>>>
object a {
  def foo =
    try
      a
    catch /* c1 */ bar
    finally
      a
}
<<< #2019 infix
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  def foo =
    a +
    b
  val foo =
    a +
    b
  var foo =
    a +
    b
}
>>>
object a {
  def foo = {
    a +
      b
  }
  val foo = {
    a +
      b
  }
  var foo = {
    a +
      b
  }
}
<<< #2019 if-else !alwaysBeforeElseAfterCurlyIf
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = if (a) {
    a +
      b
  } else {
    a +
      b
  }
  val foo = if (a) {
    a +
      b
  } else if (b) {
    a +
      b
  } else if (c) {
    a +
      b
  }
  var foo = if (a) {
    a +
      b
  } else {
    a +
      b
  }
}
<<< #2019 if-else alwaysBeforeElseAfterCurlyIf
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = if (a) {
    a +
      b
  }
  else {
    a +
      b
  }
  val foo = if (a) {
    a +
      b
  }
  else if (b) {
    a +
      b
  }
  else if (c) {
    a +
      b
  }
  var foo = if (a) {
    a +
      b
  }
  else {
    a +
      b
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch
      bar
    finally
      a
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch {
      bar
    } finally {
      a
    }
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch
      bar
    finally
      a
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch {
      bar
    }
    finally {
      a
    }
  }
}
<<< #2019 function
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  foo(x =>
    a +
      b
  )
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
>>>
object a {
  foo(x => {
    a +
      b
  })
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
<<< #2019 partial function
maxColumn = 25
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
>>>
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
<<< #2019 for-yield !allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-yield allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield { // c
    a
  }
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-do !allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) a +
    b
  for {
    a <- b
  } a +
    b
}
<<< #2019 for-do allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } { // c
    a
  }
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) a +
    b
  for {
    a <- b
  } a +
    b
}
<<< comment in select chain
object a {
  foo
    // c2
    .bar(baz).foo(bar, baz)
  foo // c1
    // c2
    .bar(baz).foo(bar, baz)
  foo.bar(baz) // c1
    // c2
    .foo(bar, baz)
}
>>>
object a {
  foo
    // c2
    .bar(baz).foo(bar, baz)
  foo // c1
    // c2
    .bar(baz).foo(bar, baz)
  foo.bar(baz) // c1
    // c2
    .foo(bar, baz)
}
<<<  try with match expr
object a {
  try ta match {
    case Success(a) => bind(a); case Failure(e) => recover(e)
  } catch { case NonFatal(e) => Failure(e) }
}
>>>
object a {
  try ta match {
      case Success(a) => bind(a);
      case Failure(e) => recover(e)
    }
  catch {
    case NonFatal(e) => Failure(e)
  }
}
<<<  if with match expr
object a {
  if (checkCondition()) ta match {
    case Success(a) => bind(a); case Failure(e) => recover(e)
  } else doSomethingOtherwise()
}
>>>
object a {
  if (checkCondition()) ta match {
    case Success(a) => bind(a);
    case Failure(e) => recover(e)
  }
  else doSomethingOtherwise()
}
<<< align.beforeOpenParenDefnSite
maxColumn = 100
align.closeParenSite = true
align.beforeOpenParenDefnSite = true
newlines.beforeOpenParenDefnSite = source
===
def allMatching(versionString: String)
                 (partialFunctions: PartialFunction[options.Common, List[String]]*): List[String] = {

                 }
>>>
def allMatching(versionString: String)
               (partialFunctions: PartialFunction[options.Common, List[String]]*): List[String] = {}
<<< align.beforeOpenParenDefnSite + align.openParenDefnSite
maxColumn = 85
danglingParentheses.defnSite = false
align.closeParenSite = true
align.openParenDefnSite = true
align.beforeOpenParenDefnSite = true
newlines.beforeOpenParenDefnSite = source
===
def allMatching(versionString: String, partialFunctions: PartialFunction[options.Common, List[String]]*)
                 (partialFunctions: PartialFunction[options.Common, List[String]]*): List[String] = {

                 }
>>>
def allMatching(versionString: String,
                partialFunctions: PartialFunction[options.Common, List[String]]*)
               (partialFunctions: PartialFunction[options.Common, List[String]]*)
  : List[String] = {}
<<< #3173 beforeMultiline = keep
newlines.beforeMultiline = keep
===
class Foo {
  val foo = if (true) {
    ""
  } else {
    "a"
  }
  val foo = if (true)
    ""
  else
    "a"
  val foo = if (true) "" else "a"
  val foo = if (true) "aaaaa" else "bbbbb"
  val foo = if (true) "aaaaa"
  else "bbbbb"
}
>>>
class Foo {
  val foo = if (true) {
    ""
  } else {
    "a"
  }
  val foo = if (true)
    ""
  else
    "a"
  val foo = if (true) "" else "a"
  val foo =
    if (true) "aaaaa" else "bbbbb"
  val foo = if (true) "aaaaa"
  else "bbbbb"
}
<<< #3173 beforeMultiline = fold
newlines.beforeMultiline = fold
===
class Foo {
  val foo = if (true) {
    ""
  } else {
    "a"
  }
  val foo = if (true)
    ""
  else
    "a"
  val foo = if (true) "" else "a"
  val foo = if (true) "aaaaa" else "bbbbb"
  val foo = if (true) "aaaaa"
  else "bbbbb"
}
>>>
class Foo {
  val foo =
    if (true) {
      ""
    } else {
      "a"
    }
  val foo =
    if (true) ""
    else "a"
  val foo = if (true) "" else "a"
  val foo =
    if (true) "aaaaa" else "bbbbb"
  val foo =
    if (true) "aaaaa"
    else "bbbbb"
}
<<< #3276
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
<<< #3276 2
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
      {c; a + b}.foo
    else
      false
}
>>>
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
      { c; a + b }.foo
    else
      false
}
<<< #3276 4
class Foo() {
  def notOK: Boolean =
    try {c; a + b}.foo
    finally {c; a + b}.foo
}
>>>
class Foo() {
  def notOK: Boolean =
    try { c; a + b }.foo
    finally { c; a + b }.foo
}
<<< #3295 1
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
<<< #3327 match
indent.relativeToLhsLastLine = [match]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ match /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ match /* c2 */ {
          case Some(Row(value: Long)) =>
            value
          case _ => 0
        }
    }
}
<<< #3327 infix
indent.relativeToLhsLastLine = [infix]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) =>
            value
          case _ => 0
        }
    }
}
<<< #3327 infix 2
indent.relativeToLhsLastLine = [infix]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        } /* c3 */ infix /* c4 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) =>
            value
          case _ => 0
        } /* c3 */ infix /* c4 */ {
          case Some(Row(value: Long)) =>
            value
          case _ => 0
        }
    }
}
<<< #3369
binPack.defnSite = always
===
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[CommittableOffsetBatch],
      TestOffsetFactory) = {
    val (source, control, sink) = streamProbes(committerSettings)
    val factory = TestOffsetFactory(new TestBatchCommitter(committerSettings))
    (source, control, sink, factory)
  }
}
>>>
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[
        CommittableOffsetBatch
      ], TestOffsetFactory) = {
    val (source, control, sink) =
      streamProbes(committerSettings)
    val factory = TestOffsetFactory(
      new TestBatchCommitter(
        committerSettings
      )
    )
    (source, control, sink, factory)
  }
}
<<< SM 4.7.0: 1
object a {
  @volatile private var _foo: Bar =
    _ // This must be volatile since it isn't protected by the mailbox status
}
>>>
object a {
  @volatile private var _foo: Bar =
    _ // This must be volatile since it isn't protected by the mailbox status
}
<<< SM 4.7.0: 2
object a {
  private[this] var _mailboxDoNotCallMeDirectly
      : Bar =
    _
}
>>>
object a {
  private[this] var _mailboxDoNotCallMeDirectly
      : Bar =
    _
}
<<< SM 4.7.0: 3
object a {
  if ((a > b && c > 0)) {
    true // Allow messages larger than capacity through, it will be recorded as negative tokens
  }
}
>>>
object a {
  if ((a > b && c > 0)) {
    true // Allow messages larger than capacity through, it will be recorded as negative tokens
  }
}
<<< SM 4.7.0: 4
object a {
  (
    registry ⇒
      Props(classOf[TcpOutgoingConnection], tcp, registry, commander, c)
  )
}
>>>
object a {
  (
      registry ⇒
        Props(
          classOf[
            TcpOutgoingConnection
          ],
          tcp,
          registry,
          commander,
          c
        )
  )
}
<<< SM 4.7.0: 5
object a {
  ((
    server,
    serverSet.join(
      server.address,
      Map[String, InetSocketAddress](),
      shardId)))
}
>>>
object a {
  (
    (
      server,
      serverSet.join(
        server.address,
        Map[
          String,
          InetSocketAddress
        ](),
        shardId
      )
    )
  )
}
<<< SM 4.7.0: 6
object a {
  val expected = Map(
    "foos" -> ((
      "xyz",
      "1"
    )), // the "cas unique" values are predictable from a fresh memcached
    a -> b)
}
>>>
object a {
  val expected = Map(
    "foos" -> ((
      "xyz",
      "1"
    )), // the "cas unique" values are predictable from a fresh memcached
    a -> b
  )
}
<<< SM 4.7.0: 7
maxColumn = 100
===
object a {
  foo match {
    case f: Float if f == 42f => (<float>perfect</float>: Elem)
    case f: Float if f == 0f  => (<float>zero</float>: Node)
    case f: Float if f > 0f   => (<float>positive</float>: NodeSeq)
    case f: Float if f < 0f   => (<float>negative</float>: Seq[Node])
  }
}
>>>
object a {
  foo match {
    case f: Float if f == 42f => (<float>perfect</float>: Elem)
    case f: Float if f == 0f => (<float>zero</float>: Node)
    case f: Float if f > 0f => (<float>positive</float>: NodeSeq)
    case f: Float if f < 0f => (<float>negative</float>: Seq[Node])
  }
}
<<< SM 4.7.0: 8
maxColumn = 80
===
foo match {
      case (exp: ScReferenceExpression) childOf ((_: ScGenericCall) childOf (_: ScMethodCall)) =>
}
>>>
foo match {
  case (exp: ScReferenceExpression) childOf ((_: ScGenericCall) childOf (_: ScMethodCall)) =>
}
<<< SM 4.7.0: 9
maxColumn = 100
===
object a {
    val ui = LiftRules.jsArtifacts
    (<span>{
      rs % ("onclick" -> (ui.hide(sid).cmd &
        ui.showAndFocus(hid).cmd & JsRaw("return false;")))
    }</span>)
}
>>>
object a {
  val ui = LiftRules.jsArtifacts
  (<span>{
    rs % ("onclick" -> (ui.hide(sid).cmd &
      ui.showAndFocus(hid).cmd & JsRaw("return false;")))
  }</span>)
}
<<< SM 4.7.0: 10
object a {
  XhtmlResponse(
    (<html> <body>Exception occured while processing {r.uri}<pre>{
      showException(e)
    }</pre> </body> </html>),
    foo
  )
}
>>>
object a {
  XhtmlResponse(
    (<html> <body>Exception occured while processing {
      r.uri
    }<pre>{
      showException(e)
    }</pre> </body> </html>),
    foo
  )
}
<<< SM 4.7.0: 11
foo match {
    case ScWhileStmt(
          Some(
            ScInfixExpr(
              (ref: ScReferenceExpression) && (ResolvesTo(
                target @ Parent(Parent(entity: ScVariable))
              )),
              ElementText(operator),
              _
            )
          ),
          Some(body)
        ) =>
}
>>>
foo match {
  case ScWhileStmt(
        Some(
          ScInfixExpr(
            (ref: ScReferenceExpression) && (ResolvesTo(
              target @ Parent(Parent(
                entity: ScVariable
              ))
            )),
            ElementText(operator),
            _
          )
        ),
        Some(body)
      ) =>
}
<<< SM 4.7.0: 12
object a {
  case class MaxReusableBufferSize(maxReusableBufferSize: Int)
  implicit
  object MaxReusableBufferSize extends Stack.Param[MaxReusableBufferSize] {
  }
}
>>>
object a {
  case class MaxReusableBufferSize(
      maxReusableBufferSize: Int
  )
  implicit object MaxReusableBufferSize
      extends Stack.Param[
        MaxReusableBufferSize
      ] {}
}
<<< SM 4.7.0: 13
runner.parser = source
===
/*ref*/be()
/*
import scala.collection.immutable

immutable.HashSet
*/
>>>
/*ref*/
be()
/*
import scala.collection.immutable

immutable.HashSet
 */
<<< SM 4.7.0: 14
maxColumn = 100
===
object a {
 foldedTopics + shortStringLength(topic) + 4 + /* partition count */
   partitionFetchInfos.size *
   (4 + /* partition id */
     8 + /* offset */
     4 /* fetch size */
   )
}
>>>
object a {
  foldedTopics + shortStringLength(topic) + 4 + /* partition count */
    partitionFetchInfos.size *
    (4 + /* partition id */
      8 + /* offset */
      4 /* fetch size */
    )
}
<<< SM 4.7.0: 15
class a {
  def this(x: Int) {
    this()
    class Q
    trait R
    object S
    new T {}
    (() => () => "5")
  }
}
>>>
class a {
  def this(x: Int) {
    this()
    class Q
    trait R
    object S
    new T {}
    (() => () => "5")
  }
}
<<< SM 4.7.0: 16
maxColumn = 80
===
object a {
  jID =
    new SerializableWritable[JobID](SparkHadoopWriter.createJobID(now, jobid))
}
>>>
object a {
  jID =
    new SerializableWritable[JobID](SparkHadoopWriter.createJobID(now, jobid))
}
<<< SM 4.7.0: 17
object a {
  info(
    "ZKConsumerConnector shutdown completed in " +
     (System.nanoTime() - startTime) / 1000000 + " ms"
  )
}
>>>
object a {
  info(
    "ZKConsumerConnector shutdown completed in " +
      (System.nanoTime() - startTime) / 1000000 + " ms"
  )
}
<<< SM 4.7.0: 18
maxColumn = 80
===
object a {
  @(SourceAnnotation @getter)("http://apple.com")
  val x = 0
}
>>>
object a {
  @(SourceAnnotation @getter)("http://apple.com")
  val x = 0
}
<<< SM 4.7.0: 19
maxColumn = 80
===
object a {
  val d = foo.< ref > pal (42) ("abc")
}
>>>
object a {
  val d = foo.< ref > pal (42)("abc")
}
<<< SM 4.7.0: 20
maxColumn = 80
===
object a {
  def step: (Input[I] => IterateeT[I, F, A]) => (
    Input[O] => IterateeT[O, F, StepT[I, F, A]]
  ) = ???
}
>>>
object a {
  def step: (Input[I] => IterateeT[I, F, A]) => (
      Input[O] => IterateeT[O, F, StepT[I, F, A]]
  ) = ???
}
<<< SM 4.7.0: 21
maxColumn = 50
===
object a {
  avgMem.add(
    heapUsed.used / nrOfActors
  ) // average actor size, over nrOfRepeats
}
>>>
object a {
  avgMem.add(
    heapUsed.used / nrOfActors
  ) // average actor size, over nrOfRepeats
}
<<< SM 4.7.0: 22
maxColumn = 60
===
object CapabilityFlag {
  def on(): CapabilityFlag =
    new CapabilityFlag { override def value = true }
}
>>>
object CapabilityFlag {
  def on(): CapabilityFlag =
    new CapabilityFlag { override def value = true }
}
<<< SM 4.7.0: 23
val boss = system.actorOf(Props(new Supervisor(
  OneForOneStrategy()(List(classOf[Exception]))
)))
>>>
val boss =
  system.actorOf(Props(new Supervisor(
    OneForOneStrategy()(
      List(classOf[Exception])
    )
  )))
<<< SM 4.7.0: 24.1
maxColumn = 80
optIn.annotationNewlines = true
===
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
>>>
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
<<< SM 4.7.0: 24.2
maxColumn = 80
optIn.annotationNewlines = false
===
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
>>>
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
<<< SM 4.7.0: 25
maxColumn = 80
===
if (
  settings.fuzzingMode && !system.settings.config.hasPath(
    "akka.stream.secret-test-fuzzing-warning-disable"
  )
) {
  //
}
>>>
if (
  settings.fuzzingMode && !system.settings.config.hasPath(
    "akka.stream.secret-test-fuzzing-warning-disable"
  )
) {
  //
}
<<< SM 4.7.0: 26
maxColumn = 80
===
assert((-9223372036854775807L - 1L ==
  (bytesToInt64(ba(0), ba(1), ba(2), ba(3), ba(4), ba(5), ba(6), ba(7)))))
>>>
assert((-9223372036854775807L - 1L ==
  (bytesToInt64(ba(0), ba(1), ba(2), ba(3), ba(4), ba(5), ba(6), ba(7)))))
<<< SM 4.7.0: 27
maxColumn = 80
===
object a {
  sb.append((if (msb < 10) ('0' + msb).asInstanceOf[Char]
             else ('a' + (msb - 10)).asInstanceOf[Char]))
  sb.append((if (lsb < 10) ('0' + lsb).asInstanceOf[Char]
             else ('a' + (lsb - 10)).asInstanceOf[Char]))
}
>>>
object a {
  sb.append((if (msb < 10) ('0' + msb).asInstanceOf[Char]
             else ('a' + (msb - 10)).asInstanceOf[Char]))
  sb.append((if (lsb < 10) ('0' + lsb).asInstanceOf[Char]
             else ('a' + (lsb - 10)).asInstanceOf[Char]))
}
<<< SM 4.7.0: 28
maxColumn = 80
===
object a {
  val pebblesAndBammBammsParents = Person.findAll(("childId" ->
    ("$in" -> List(pebblesId, bammbammId))))
}
>>>
object a {
  val pebblesAndBammBammsParents = Person.findAll(("childId" ->
    ("$in" -> List(pebblesId, bammbammId))))
}
<<< SM 4.7.0: 29.1
maxColumn = 75
===
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldContent = None,
        newContent = None,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldContent = None,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    }
  ))
}
>>>
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldContent = None,
        newContent = None,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldContent = None,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    }
  ))
}
<<< SM 4.7.0: 29.2
maxColumn = 75
===
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  ))
}
>>>
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  ))
}
<<< SM 4.7.0: 29.3
maxColumn = 75
===
object a {
  buffer.append(
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  )
}
>>>
object a {
  buffer.append(
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  )
}
<<< SM 7.4.0: 30
maxColumn = 80
===
object Test { (tree: Tree) =>
  tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
}
>>>
object Test {
  (tree: Tree) =>
    tree match { case LetL(CharLit) => ??? }
  (tree: Tree) => tree match { case LetL(CharLit) => ??? }
  (tree: Tree) => tree match { case LetL(CharLit) => ??? }
  (tree: Tree) => tree match { case LetL(CharLit) => ??? }
  (tree: Tree) => tree match { case LetL(CharLit) => ??? }
  (tree: Tree) => tree match { case LetL(CharLit) => ??? }
}
<<< SM 7.4.0: 31
maxColumn = 80
===
object a {
  licenses +=
    (
      "BSD New",
      url("https://github.com/scala-js/scala-js/blob/master/LICENSE")
    )
}
>>>
object a {
  licenses +=
    (
      "BSD New",
      url("https://github.com/scala-js/scala-js/blob/master/LICENSE")
    )
}
<<< SM 7.4.0: 32
maxColumn = 80
===
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
          AnyMimeType -> (XJsonStream, XJsonStream),
          OctetStream -> (XJsonStream, OctetStream)
        )).toMap
}
>>>
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
      AnyMimeType -> (XJsonStream, XJsonStream),
      OctetStream -> (XJsonStream, OctetStream)
    )).toMap
}
<<< SM 7.4.0: 33
maxColumn = 80
===
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
          AnyMimeType -> (XJsonStream, XJsonStream),
          OctetStream -> (XJsonStream, OctetStream)
        )).toMap
}
>>>
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
      AnyMimeType -> (XJsonStream, XJsonStream),
      OctetStream -> (XJsonStream, OctetStream)
    )).toMap
}
<<< SM 7.4.0: 34.1
maxColumn = 80
===
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"), tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
>>>
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"),
      tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
<<< SM 7.4.0: 34.2
maxColumn = 60
===
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"), tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
>>>
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"),
      tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
<<< SM 7.4.0: 35
maxColumn = 76
===
object a {
  ECNotUsed(ec =>
    f.onFailure({ case _ =>
      fail("onFailure should not have been called")
    })(ec)
  )
}
>>>
object a {
  ECNotUsed(ec =>
    f.onFailure({ case _ =>
      fail("onFailure should not have been called")
    })(ec)
  )
}
<<< SM 7.4.0: 36
maxColumn = 76
===
object a {
  foo match {
    case _ => buildConditions(
        names.tail,
        ((
          node: AbstractTestProxy
        ) => node.getName == names.head && !node.isLeaf) :: acc
    )
  }
}
>>>
object a {
  foo match {
    case _ => buildConditions(
        names.tail,
        ((
          node: AbstractTestProxy
        ) => node.getName == names.head && !node.isLeaf) :: acc
      )
  }
}
<<< SM 7.4.0: 37
maxColumn = 76
===
object a {
  var sessionCheckFuncs
      : List[(Map[String, SessionInfo], SessionInfo => Unit) => Unit] =
    (
        (
            ses: Map[String, SessionInfo],
            destroyer: SessionInfo => Unit
        ) => {
          foo
        }
    ) :: Nil
}
>>>
object a {
  var sessionCheckFuncs
      : List[(Map[String, SessionInfo], SessionInfo => Unit) => Unit] =
    (
        (
            ses: Map[String, SessionInfo],
            destroyer: SessionInfo => Unit
        ) => {
          foo
        }
    ) :: Nil
}
<<< SM 7.4.0: 38
maxColumn = 76
===
object a {
  private def test_sort_on_comparables[T <: AnyRef with Comparable[
    T
  ]: ClassTag](
      factory: ListFactory,
      toElem: Int => T,
      absoluteOrder: Boolean = true
  ): Unit = {
    foo
  }
}
>>>
object a {
  private def test_sort_on_comparables[T <: AnyRef with Comparable[
    T
  ]: ClassTag](
      factory: ListFactory,
      toElem: Int => T,
      absoluteOrder: Boolean = true
  ): Unit = {
    foo
  }
}
<<< SM 7.4.0: 39
maxColumn = 76
===
object a {
  def curried: T1 => T2 => T3 => T4 => T5 => T6 => R = { (x1: T1) =>
    (
        (
            x2: T2,
            x3: T3,
            x4: T4,
            x5: T5,
            x6: T6
        ) => self.apply(x1, x2, x3, x4, x5, x6)
    ).curried
  }
}
>>>
object a {
  def curried: T1 => T2 => T3 => T4 => T5 => T6 => R = { (x1: T1) =>
    (
        (
            x2: T2,
            x3: T3,
            x4: T4,
            x5: T5,
            x6: T6
        ) => self.apply(x1, x2, x3, x4, x5, x6)
    ).curried
  }
}
<<< SM 7.4.0: 40.1
maxColumn = 76
===
object a {
  override def !(message: Any)(implicit
      sender: ActorRef = Actor.noSender
  ): Unit = ()
}
>>>
object a {
  override def !(message: Any)(implicit
      sender: ActorRef = Actor.noSender
  ): Unit = ()
}
<<< SM 7.4.0: 40.1
maxColumn = 76
===
object a {
  implicit def convertToScala[J](j: J)(implicit
      mapping: J2SMapping[J]
  ): mapping.S = mapping.toScala(j)
}
>>>
object a {
  implicit def convertToScala[J](j: J)(implicit
      mapping: J2SMapping[J]
  ): mapping.S = mapping.toScala(j)
}
<<< SM 7.4.0: 41
maxColumn = 76
===
object a {
    (
        (a: A) => {
          class N extends M[a.C] {
            def m(x: a.C) = true
          }
          new N: M[Null]
        }
    ).apply(a).m(null) // NPE, missing bridge
}
>>>
object a {
  (
      (a: A) => {
        class N extends M[a.C] {
          def m(x: a.C) = true
        }
        new N: M[Null]
      }
  ).apply(a).m(null) // NPE, missing bridge
}
<<< SM 7.4.0: 42.1
maxColumn = 76
===
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S]): Result[S]
}
>>>
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S]): Result[S]
}
<<< SM 7.4.0: 42.2
maxColumn = 76
===
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S], foo: String): Result[S]
}
>>>
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](
      f: T => Result[S],
      foo: String
  ): Result[S]
}
<<< SM 7.4.0: 42.3
maxColumn = 76
===
object a {
  def span[a, s <: Seq[
    a
  ] { type MyType /*look ma, no type parameters!*/ <: s }](xs: s): s = xs f
}
>>>
object a {
  def span[a, s <: Seq[
    a
  ] { type MyType /*look ma, no type parameters!*/ <: s }](xs: s): s = xs f
}
<<< SM 7.4.0: 43
maxColumn = 76
===
object a {
    assert(
      t21 ==
        (
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21
        )
    )
}
>>>
object a {
  assert(
    t21 ==
      (
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21
      )
  )
}
<<< SM 7.4.0: 44
maxColumn = 76
===
object a {
  private val capturedStack =
    (new Throwable().getStackTrace)
      .filter(_.getMethodName.startsWith("supports"))
      .find { el ⇒
        val clazz = Class.forName(el.getClassName)
        clazz
          .getDeclaredMethod(el.getMethodName)
          .getReturnType == classOf[CapabilityFlag]
      } map { _.getMethodName } getOrElse "[unknown]"
}
>>>
object a {
  private val capturedStack =
    (new Throwable().getStackTrace)
      .filter(_.getMethodName.startsWith("supports"))
      .find { el ⇒
        val clazz = Class.forName(el.getClassName)
        clazz
          .getDeclaredMethod(el.getMethodName)
          .getReturnType == classOf[CapabilityFlag]
      } map { _.getMethodName } getOrElse "[unknown]"
}
<<< SM 7.4.0: 45
maxColumn = 76
===
object a {
  protected override def newAppended[B >: A](
      that: GenTraversable[B]
  ): Transformed[B] = new { val rest = that } with AbstractTransformed[B]
    with Appended[B]
}
>>>
object a {
  protected override def newAppended[B >: A](
      that: GenTraversable[B]
  ): Transformed[B] = new { val rest = that }
    with AbstractTransformed[B] with Appended[B]
}
<<< SM 7.4.0: 46
maxColumn = 76
===
object a {
  slice match {
    case (xs, from, until) ⇒
      likeVector(xs)({ _.drop(from).take(until - from) })
  }
}
>>>
object a {
  slice match {
    case (xs, from, until) ⇒
      likeVector(xs)({ _.drop(from).take(until - from) })
  }
}
<<< SM 7.4.0: 47.1
maxColumn = 76
===
class a {
  def this(settings: Settings, eventStream: EventStream) = this(() ⇒
    eventStream.logLevel
  )
}
>>>
class a {
  def this(settings: Settings, eventStream: EventStream) = this(() ⇒
    eventStream.logLevel
  )
}
<<< SM 7.4.0: 47.2
maxColumn = 76
===
class a {
  def thiz(settings: Settings, eventStream: EventStream) = thiz(() ⇒
    eventStream.logLevel
  )
}
>>>
class a {
  def thiz(settings: Settings, eventStream: EventStream) = thiz(() ⇒
    eventStream.logLevel
  )
}
<<< SM 7.4.0: 48
maxColumn = 76
===
class a {
  val ipv4: immutable.Seq[Inet4Address] = addresses
    .collect({ case a: Inet4Address ⇒ a })(breakOut)
}
>>>
class a {
  val ipv4: immutable.Seq[Inet4Address] = addresses
    .collect({ case a: Inet4Address ⇒ a })(breakOut)
}
<<< SM 7.4.0: 49
maxColumn = 76
===
class a {
  def this(
    trapExit: Array[Class[_ <: Throwable]],
    maxNrOfRetries: Int,
    withinTimeRange: Int
  ) = this(
    trapExit.toList,
    if (maxNrOfRetries < 0) None else Some(maxNrOfRetries),
    if (withinTimeRange < 0) None else Some(withinTimeRange)
  )
}
>>>
class a {
  def this(
      trapExit: Array[Class[_ <: Throwable]],
      maxNrOfRetries: Int,
      withinTimeRange: Int
  ) = this(
    trapExit.toList,
    if (maxNrOfRetries < 0) None else Some(maxNrOfRetries),
    if (withinTimeRange < 0) None else Some(withinTimeRange)
  )
}
<<< SM 7.4.0: 50
maxColumn = 70
===
class a {
  def step(
      inner: Iteratee[E, A]
  )(in: Input[E]): Iteratee[E, Iteratee[E, A]] = in match {
    case Input.El(e) => Iteratee.flatten(
        Future(p(e))(pec).map(b =>
          if (b) Done(inner, in)
          else stepNoBreak(inner)(in)
        )(dec)
      )
    case _ => stepNoBreak(inner)(in)
  }
}
>>>
class a {
  def step(
      inner: Iteratee[E, A]
  )(in: Input[E]): Iteratee[E, Iteratee[E, A]] = in match {
    case Input.El(e) => Iteratee.flatten(
        Future(p(e))(pec).map(b =>
          if (b) Done(inner, in)
          else stepNoBreak(inner)(in)
        )(dec)
      )
    case _ => stepNoBreak(inner)(in)
  }
}
<<< SM 7.4.0: 51
maxColumn = 76
===
class a {
  atPos(body.pos)(casegen.one(substitution(
    body
  ))) // since SubstOnly treemakers are dropped, need to do it here
}
>>>
class a {
  atPos(body.pos)(casegen.one(substitution(
    body
  ))) // since SubstOnly treemakers are dropped, need to do it here
}
<<< SM 7.4.0: 52
maxColumn = 76
===
class a {
  val o2 =
    v1.changes
      .register(Witness({ i =>
        result = result * i * i
      })) // result = 2 * 2 * 2 = 8
}
>>>
class a {
  val o2 =
    v1.changes
      .register(Witness({ i =>
        result = result * i * i
      })) // result = 2 * 2 * 2 = 8
}
<<< SM 7.4.0: 53
maxColumn = 76
===
object a {
  def toJsCmd = """var x=document.getElementById(""" + select.encJs + """);
    if (x) {
    while (x.length > 0) {x.remove(0);}
    var y = null;
  """ + opts.map { case (value, text) =>
    "y=document.createElement('option'); " + "y.text = " + text.encJs + "; " +
      "y.value = " + value.encJs + "; " +
      (if (Full(value) == dflt) "y.selected = true; " else "") +
      " try {x.add(y, null);} catch(e) {if (typeof(e) == 'object' && typeof(e.number) == 'number' && (e.number & 0xFFFF) == 5){ x.add(y,x.options.length); } } "
  }
}
>>>
object a {
  def toJsCmd = """var x=document.getElementById(""" + select.encJs + """);
    if (x) {
    while (x.length > 0) {x.remove(0);}
    var y = null;
  """ + opts.map { case (value, text) =>
    "y=document.createElement('option'); " + "y.text = " + text.encJs + "; " +
      "y.value = " + value.encJs + "; " +
      (if (Full(value) == dflt) "y.selected = true; " else "") +
      " try {x.add(y, null);} catch(e) {if (typeof(e) == 'object' && typeof(e.number) == 'number' && (e.number & 0xFFFF) == 5){ x.add(y,x.options.length); } } "
  }
}
<<< binPack.callSite with configStyle, danglingParentheses
newlines.configStyleCallSite.prefer = true
danglingParentheses.callSite = true
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
    10000,
    10001,
    10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001,
    10002 + 0
  )
  val bar2 = foo2(
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10 + 0
  )
}
<<< binPack.defnSite with configStyle, danglingParentheses
newlines.configStyleDefnSite.prefer = true
danglingParentheses.defnSite = true
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X,
      x2: X,
      xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X,
      x2: X,
      xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*): Set[Int]
  def foo2(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
  def foo3(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
}
<<< binPack.callSite with !configStyle, danglingParentheses
newlines.configStyleCallSite.prefer = false
danglingParentheses.callSite = true
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0
  )
}
<<< binPack.defnSite with !configStyle, danglingParentheses
newlines.configStyleDefnSite.prefer = false
danglingParentheses.defnSite = true
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*): Set[Int]
  def foo2(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*
  ): Set[Int]
  def foo3(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*
  ): Set[Int]
}
<<< binPack.callSite with configStyle, !danglingParentheses
newlines.configStyleCallSite.prefer = true
danglingParentheses.callSite = false
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
    10000,
    10001,
    10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(
    10000,
    10001,
    10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10 + 0
  )
}
<<< binPack.defnSite with configStyle, !danglingParentheses
newlines.configStyleDefnSite.prefer = true
danglingParentheses.defnSite = false
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X,
      x2: X,
      xs: X*
  ): Set[Int]
  def foo1(
      x1: X,
      x2: X,
      xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*): Set[Int]
  def foo2(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
  def foo3(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
}
<<< binPack.callSite with !configStyle, !danglingParentheses
newlines.configStyleCallSite.prefer = false
danglingParentheses.callSite = false
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
<<< binPack.defnSite with !configStyle, !danglingParentheses
newlines.configStyleDefnSite.prefer = false
danglingParentheses.defnSite = false
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X,
      x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
      x2: X, xs: X*): Set[Int]
  def foo2(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*
  ): Set[Int]
  def foo3(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*): Set[Int]
}
<<< two statements separated by semicolon
foo match {
  case a =>
    bara;
    baza
  case b => barb;
    bazb
  case c => barc; bazc
}
>>>
foo match {
  case a =>
    bara;
    baza
  case b =>
    barb;
    bazb
  case c => barc; bazc
}
