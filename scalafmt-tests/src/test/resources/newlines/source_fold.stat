align.preset = none
maxColumn = 40
newlines.source = fold
newlines.afterCurlyLambda = squash
runner.optimizer.forceConfigStyleOnOffset = 50
<<< 1.1: block, if-else, line too long
if (true) {      println(aaaaaaaaaaaaaaaaaaaaaaaaaa)}
>>>
if (true) {
  println(aaaaaaaaaaaaaaaaaaaaaaaaaa)
}
<<< 1.2: block, if-else, egyptian curlies
object a {
if (a) {
println("bbb") } else c
}
>>>
object a {
  if (a) { println("bbb") }
  else c
}
<<< 1.3: block, if, non-egyptian curlies
object a {
if (a)
{
println("bbb")
}
else
{
c
}}
>>>
object a {
  if (a) { println("bbb") }
  else { c }
}
<<< 1.4: block #1043
object a {
      if ('0' <= c && c <= '9') { c - '0' }
      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }
      else if ('a' <= c && c <= 'f') { c - 'a' + 10 }
      else {
       -1  }}
>>>
object a {
  if ('0' <= c && c <= '9') { c - '0' }
  else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else { -1 }
}
<<< 1.5: block #1043 with lines joined
object a {
      if ('0' <= c && c <= '9') { c - '0' }      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }  else if ('a' <= c && c <= 'f') { c - 'a' + 10 }      else {
                                                            -1
}}
>>>
object a {
  if ('0' <= c && c <= '9') { c - '0' }
  else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else { -1 }
}
<<< 1.6: block, try-catch, line too long
object a {
try { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa } catch { case b => }
}
>>>
object a {
  try {
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  } catch { case b => }
}
<<< 1.7: block, try-catch, no breaks
object a {
try { a } catch { case b => ; case c => } finally { d }
}
>>>
object a {
  try { a }
  catch { case b => ; case c => }
  finally { d }
}
<<< 1.8: block, try-catch, with breaks
object a {
try {
 a } catch {
  case b => ; case c => } finally {
   d }
}
>>>
object a {
  try { a }
  catch { case b => ; case c => }
  finally { d }
}
<<< 1.9: block, try-catch, with breaks, top-level
try {
 a } catch {
  case b => ; case c => } finally {
   d }
>>>
try {
  a
} catch { case b => ; case c => }
finally {
  d
}
<<< 1.a: block, class
object a {
class a {
 type b = Int
}
}
>>>
object a {
  class a {
    type b = Int
  }
}
<<< 1.b: block, trait and object
object a {
trait b {
 type c = Int
}
object b {
def apply(c: Int) = { new d(c)
}
}}
>>>
object a {
  trait b {
    type c = Int
  }
  object b {
    def apply(c: Int) = { new d(c) }
  }
}
<<< 1.c: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user")
    } should have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message
    """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.d: if-else, no curlies
if (a)
println("bbb")
 else
  if (b)
   b else
 c
>>>
if (a) println("bbb")
else if (b) b
else c
<<< 2.1: def one-line body
def a = b
>>>
def a = b
<<< 2.2: def one-line block body
object a {
def a = { b; c }
}
>>>
object a {
  def a = { b; c }
}
<<< 2.3: def one-line block body with a break
object a {
def a =
 { b; c }
}
>>>
object a {
  def a = { b; c }
}
<<< 2.4: def multiline-line block body with a break
object a {
def a =
 {
  b;c }}
>>>
object a {
  def a = { b; c }
}
<<< 2.5: def multiline-line block body with a break
object a {
def a = {
  b;c }
}
>>>
object a {
  def a = { b; c }
}
<<< 2.6 #1747: one line with else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 = if (a > 10) { Some(a) } else { None }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) }
    else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
    else { None }
}
<<< 2.7 #1747: one line without else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
<<< 2.8 #1747: split on then with else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  else
    None
  val ok2 = if (a > 10) {
    Some(a)
  } else {
    None
  }
  val ok3 = if (aaaa > 10000) {
     Some(aaaa)
  }
  else {
    None
  }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) }
    else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
    else { None }
}
<<< 2.9 #1747: split on else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10) Some(a) else
    None
  val ok2 = if (a > 10) { Some(a) } else {
    None
  }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else {
    None
  }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) }
    else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
    else { None }
}
<<< 2.10 #1747: split on then without else
maxColumn = 60
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  val ok2 = if (a > 10) {
    Some(a) }
  val ok3 = if (aaaa > 10000) {
    Some(aaaa) }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
<<< 2.11 #1747: split on if
maxColumn = 60
===
object a {
  val ok1 =
    if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) } else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) }
    else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) }
    else { None }
}
<<< 2.12 #1747: split on if without else
maxColumn = 60
===
object a {
  val ok1 =
    if (a > 10) Some(a)
  val ok2 =
    if (a > 10) { Some(a) }
  val ok3 =
   if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
<<< 2.13 val with for/yield
maxColumn = 80
===
val attributes =
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
>>>
val attributes = for (_ ← 1 to count) yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
<<< 2.14 val with short for/yield
maxColumn = 80
===
val attributes =
 for (i ← 1 to count)
 yield i
>>>
val attributes = for (i ← 1 to count) yield i
<<< 2.15 val with literal apply
object a {
   val a =
    b(
      0x1F, // ID1
       0x8B, // ID2
       8, // CM = Deflate
       0, // FLG
       0, // MTIME 1
       0, // MTIME 2
       0, // MTIME 3
       0, // MTIME 4
       0, // XFL
       0 // OS
    )
 }
>>>
object a {
  val a = b(
    0x1f, // ID1
    0x8b, // ID2
    8, // CM = Deflate
    0, // FLG
    0, // MTIME 1
    0, // MTIME 2
    0, // MTIME 3
    0, // MTIME 4
    0, // XFL
    0 // OS
  )
}
<<< 2.16 val with apply and comment
danglingParentheses.preset = false
===
val a = Set(
  "b" // ...
)
>>>
val a = Set(
  "b" // ...
)
<<< 2.17 val with apply-apply-select
val aaaaa = bbbbb.asss(as).ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb.asss(as)
  .ccccc(ddddd, eeeee, fffff) // comment
<<< 2.18 val with apply-apply
val aaaaa = (getSomeLongerFunction(c))(as)
>>>
val aaaaa = (getSomeLongerFunction(c))(
  as
)
<<< 2.19 val with apply-select-select
val aaaaa = bbbbb.asss.ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb.asss
  .ccccc(ddddd, eeeee, fffff) // comment
<<< 2.20 val with apply-select-select
val nested =
  promiseIntercept(new Actor {
    def receive = {
      case _ ⇒
    }
  })(result)
>>>
val nested = promiseIntercept(
  new Actor {
    def receive = { case _ ⇒ }
  }
)(result)
<<< 2.21 val with apply type
  val deployment =
   system
    .asInstanceOf[ActorSystemImpl]
    .provider
    .deployer
    .lookup(service.split("/").drop(1))
>>>
val deployment = system
  .asInstanceOf[ActorSystemImpl]
  .provider.deployer
  .lookup(service.split("/").drop(1))
<<< 2.22
maxColumn = 80
===
val augassign: P[Ast.operator] = P(
    "+=".!.map(_ => Ast.operator.Add) |
    "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) |
    "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) |
    "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) |
    "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) |
    "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
  )
>>>
val augassign: P[Ast.operator] = P(
  "+=".!.map(_ => Ast.operator.Add) | "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) | "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) | "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) | "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) | "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
)
<<< 3.1: def non-config-style, long
def a( ccccccccccccccccc:Int,
 ddddddddddddddddd:String,
  eeeeeeeeeeeeeeeee:Long) = true
>>>
def a(
    ccccccccccccccccc: Int,
    ddddddddddddddddd: String,
    eeeeeeeeeeeeeeeee: Long
) = true
<<< 3.2: def non-config-style, short
def a( b:Int,
 c:String,
  d:Long) = true
>>>
def a(b: Int, c: String, d: Long) = true
<<< 3.3: apply non-config-style, no breaks on ( and )
val a = b(c, d,
  efgh)
>>>
val a = b(c, d, efgh)
<<< 3.4: apply non-config-style, no break on (, break on )
val a = b(c,
 d,
  efgh
)
>>>
val a = b(c, d, efgh)
<<< 3.5: apply non-config-style, break on (, no break on )
val a = b(
c,
 d,
  efgh)
>>>
val a = b(c, d, efgh)
<<< 3.6: apply config-style, break on ( and )
val a = b(
c,
 d,
  efgh
  )
>>>
val a = b(c, d, efgh)
<<< 3.7: apply non-config-style, force
val a = b( cccccccccccccc, dddddddddddddd,  eeeeeeeeeeeeee)
>>>
val a = b(
  cccccccccccccc,
  dddddddddddddd,
  eeeeeeeeeeeeee
)
<<< 3.8: apply non-config-style, too long
val a = b( ccccccccccc, ddddddddddd,  eeeeeeeeeee)
>>>
val a = b(
  ccccccccccc,
  ddddddddddd,
  eeeeeeeeeee
)
<<< 3.9: single-arg multi-line apply, possible config-style
a.b(foo {
    val bar = baz
    qux
  }
)
>>>
a.b(foo {
  val bar = baz
  qux
})
<<< 3.10 enclosed, infix on the right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  terminaters = Set() ++
    (for (i ← 1 to n) yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
<<< 3.11 enclosed, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  (for (i ← 1 to n) yield {
    val man = context.watch(context.system.actorOf(Props[Terminater]))
    man ! "run"
    man
  })
}
<<< 3.12 enclosed, followed by select
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(promiseIntercept({
        throw new IllegalStateException("Ur state be b0rked");
        new InnerActor
      })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
>>>
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(
        promiseIntercept({
          throw new IllegalStateException("Ur state be b0rked");
          new InnerActor
        })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
<<< 3.13 enclosed, followed by select and infix
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    in.readObject
  }).getMessage should ===(
    "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
      " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
>>>
object a {
  (intercept[java.lang.IllegalStateException] { in.readObject })
    .getMessage should ===(
    "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
      " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
<<< 3.14 enclosed, assignment, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] { in.readObject })
}
<<< 3.15 enclosed, assignment, infix on left
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] { in.readObject }) ++ 2
}
<<< 3.16 enclosed, assignment, infix on right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject })
}
<<< 3.17 enclosed, assignment, infix in middle
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a = 2 ++ (intercept[java.lang.IllegalStateException] { in.readObject }) ++
    3
}
<<< 3.18 enclosed, assignment, by itself, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
<<< 3.19 enclosed, assignment, infix on left, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  }) ++ 2
}
<<< 3.20 enclosed, assignment, infix on right, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = 2 ++
    (intercept[java.lang.IllegalStateException] {
      in.readObject
    })
}
<<< 3.21 enclosed, assignment, infix in middle, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a = 2 ++
    (intercept[java.lang.IllegalStateException] {
      in.readObject
    }) ++ 3
}
<<< 3.22 enclosed, assignment, by itself, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a =
    (intercept[
      java.lang.IllegalStateException] {
      in.readObject
    })
}
<<< 3.23 enclosed, assignment, infix on left, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a = (intercept[
    java.lang.IllegalStateException] {
    in.readObject
  }) ++ 2
}
<<< 3.24 enclosed, assignment, infix on right, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = 2 ++
    (intercept[
      java.lang.IllegalStateException] {
      in.readObject
    })
}
<<< 3.25 enclosed, assignment, infix in middle, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a = 2 ++
    (intercept[
      java.lang.IllegalStateException] {
      in.readObject
    }) ++ 3
}
<<< 3.26 enclosed, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    (supervisor
      .ask(AwaitActivation(endpoint))(timeout))
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(
    endpoint: ActorRef
)(implicit timeout: Timeout, executor: ExecutionContext): Future[ActorRef] =
  (supervisor.ask(AwaitActivation(endpoint))(timeout)).map[ActorRef]({
    case EndpointActivated(`endpoint`) ⇒ endpoint
    case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
  })
<<< 3.27 enclosed in block, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    {supervisor
      .ask(AwaitActivation(endpoint))(timeout)}
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(
    endpoint: ActorRef
)(implicit timeout: Timeout, executor: ExecutionContext): Future[ActorRef] = {
  supervisor.ask(AwaitActivation(endpoint))(timeout)
}.map[ActorRef]({
  case EndpointActivated(`endpoint`) ⇒ endpoint
  case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
})
<<< 3.28 apply with optimal token
maxColumn = 80
danglingParentheses.preset = false
===
case class AttributeInfo(symbol : Symbol, typeRef : Type, value : Option[Any],
  values : Seq[String ~ Any]) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
>>>
case class AttributeInfo(
    symbol: Symbol,
    typeRef: Type,
    value: Option[Any],
    values: Seq[
      String ~ Any]) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
<<< 3.29 apply with optimal token
maxColumn = 80
===
Multipart.FormData.BodyPart.Strict(
  "userfile",
  HttpEntity(`application/pdf`, ByteString("filecontent")),
  Map("filename" -> "test€.dat"),
  List(
    RawHeader("Content-Transfer-Encoding", "binary"),
    RawHeader("Content-Additional-1", "anything"),
    RawHeader("Content-Additional-2", "really-anything"))
)
>>>
Multipart.FormData.BodyPart.Strict(
  "userfile",
  HttpEntity(`application/pdf`, ByteString("filecontent")),
  Map("filename" -> "test€.dat"),
  List(
    RawHeader("Content-Transfer-Encoding", "binary"),
    RawHeader("Content-Additional-1", "anything"),
    RawHeader("Content-Additional-2", "really-anything")
  )
)
<<< 3.30: apply with single-arg assign; open nl, close nonl
object foo {
val a = b(c = d)
val a = b(c =
  d)
val a = b(
  c =  d)
val a = b(
  c =  d
  )
}
>>>
object foo {
  val a = b(c = d)
  val a = b(c = d)
  val a = b(c = d)
  val a = b(c = d)
}
<<< 3.31
object a {
  val b: Bbbbb[Seq[Ccccc]] = writable[Seq[Ccccc]]
}
>>>
object a {
  val b: Bbbbb[Seq[Ccccc]] =
    writable[Seq[Ccccc]]
}
<<< 4.1: annotation with newlines
maxColumn = 50
optIn.annotationNewlines = true
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot @deprecated
  class B(
      @annot @deprecated
      private implicit val x: Int
  ) extends A {
    @annot
    override def foo = 1

    @annot
    override def bar = { 1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/
    @annot5 @deprecated
    def foo2(
        @annot @deprecated
        x: Int
    ) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value = "foo", someInt = 5)
    @annot3 @deprecated(value = "bar")
    def bar2 = 1
  }

  @annot @annot2 @annot3 @annot4 @deprecated
  class C

  @annot @deprecated
  class D
}
<<< 4.2: annotation without newlines
maxColumn = 50
optIn.annotationNewlines = false
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot @deprecated
  class B(
      @annot @deprecated
      private implicit val x: Int
  ) extends A {
    @annot override def foo = 1

    @annot override def bar = { 1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/
    @annot5 @deprecated
    def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value = "foo", someInt = 5)
    @annot3 @deprecated(value = "bar") def bar2 =
      1
  }

  @annot @annot2 @annot3 @annot4 @deprecated
  class C

  @annot @deprecated class D
}
<<< 4.3: #938 flag false, newline no
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.4: #938 flag true, newline no
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.5: #938 flag false, newline yes
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a {
  self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.6: #938 flag true, newline yes
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a {
 self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.7: #938 flag true, newline no, line too long
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { selfaaaaaaaaaaaaaaaa =>
    blah
}
>>>
trait a {
  selfaaaaaaaaaaaaaaaa =>
  blah
}
<<< 4.8 flag true, annot in param
optIn.annotationNewlines = true
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
)
object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1
      x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 => 3
      case <A>2</A> => 2
    }
  }
}
<<< 4.9 flag false, annot in param
optIn.annotationNewlines = false
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
) object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1 x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 => 3
      case <A>2</A> => 2
    }
  }
}
<<< 4.10
maxColumn = 80
===
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]]],
     val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
     val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
     val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]])
     extends BaseEngine[EI, Q, P, A]
>>>
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]
    ]],
    val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
    val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
    val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]]
) extends BaseEngine[EI, Q, P, A]
<<< 5.1: case statements
a match {
  case b =>
    bb
  case c => cc
   ccc
  case d =>
   dd
   ddd
  case e =>
  case f => ff
}
>>>
a match {
  case b => bb
  case c =>
    cc
    ccc
  case d =>
    dd
    ddd
  case e =>
  case f => ff
}
<<< 5.2 #1518
a match {
  case b: C =>
    ddd.eee match { case fff => """ggg""" }
}
>>>
a match {
  case b: C => ddd.eee match {
      case fff => """ggg"""
    }
}
<<< 6.1: chain, no break
val a = b.c.d.e().f.g.h()
>>>
val a = b.c.d.e().f.g.h()
<<< 6.2: chain, break on =
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a = b.c.d.e(f).g.h { i => j }.k()
  .l({ m => n }, o)
<<< 6.3: chain, breaks in the middle
val a = b.c
 .d.e() .f
 .g .h()
>>>
val a = b.c.d.e().f.g.h()
<<< 6.4: chain without apply
maxColumn = 72
includeNoParensInSelectChains = true
===
object a {
created filter (ref ⇒
         !ref.isTerminated && !ref
          .asInstanceOf[ActorRefWithCell]
          .underlying.isInstanceOf[UnstartedCell]) should ===(
        Seq.empty[ActorRef])
}
>>>
object a {
  created filter
    (ref ⇒
      !ref.isTerminated &&
        !ref.asInstanceOf[ActorRefWithCell].underlying
          .isInstanceOf[UnstartedCell]
    ) should ===(Seq.empty[ActorRef])
}
<<< 6.5: chain with delayed indent after break
maxColumn = 70
===
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc
    .union(algoPredicts).groupByKey().mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount")
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
>>>
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc.union(algoPredicts)
    .groupByKey().mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount"
        )
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
<<< 7.1: enumerator and guard short, for long
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b if (b ++ b).length >= 2
    } yield a
}
<<< 7.2: enumerator shoft, guard long
maxColumn = 28
===
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(
      b: List[Int]
  ): List[Int] =
    for {
      a <- b if (b ++ b)
        .length >= 2
    } yield a
}
<<< 7.3: enumerator and guard short, for short
for (a <- b.sortBy(c)
 if a > 0) yield x
>>>
for (a <- b.sortBy(c) if a > 0) yield x
<<< 7.4: enumerator and guard long
maxColumn = 17
===
val k = for {
  _ <- aaa + bbb
    if !onlyOne
  _ <- Future(aaa)
  if !onlyOne
  _ <- Future(2)
} yield ()
>>>
val k = for {
  _ <- aaa + bbb
  if !onlyOne
  _ <- Future(
    aaa
  ) if !onlyOne
  _ <- Future(2)
} yield ()
<<< 7.5: multiple consecutive guards
maxColumn = 80
===
val allOps = (
  for {
    c ← classes
    m ← c.getMethods if !Modifier.isStatic(m.getModifiers); if !ignore(m.getName)
    if !m.getName.contains("$"); if !materializing(m)
  } yield m.getName
).toSet
>>>
val allOps = (for {
  c ← classes
  m ← c.getMethods if !Modifier.isStatic(m.getModifiers); if !ignore(m.getName)
  if !m.getName.contains("$"); if !materializing(m)
} yield m.getName).toSet
<<< 7.6: for-yield with select chain
maxColumn = 80
===
object a {
for {
       (listenAddress, listenerPromise) ← wrappedTransport.listen
       // Enforce ordering between the signalling of "listen ready" to upstream
       // and initialization happening in interceptListen
      _ ←
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
     } yield (augmentScheme(listenAddress), upstreamListenerPromise)
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
}
>>>
object a {
  for {
    (listenAddress, listenerPromise) ← wrappedTransport.listen
    // Enforce ordering between the signalling of "listen ready" to upstream
    // and initialization happening in interceptListen
    _ ← listenerPromise.tryCompleteWith(
      interceptListen(listenAddress, upstreamListenerPromise.future1)
    ).future2
  } yield (augmentScheme(listenAddress), upstreamListenerPromise)
  listenerPromise.tryCompleteWith(
    interceptListen(listenAddress, upstreamListenerPromise.future1)
  ).future2
}
<<< 7.7: for-yield enclosed in parens
maxColumn = 40
danglingParentheses.preset = true
===
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (mean
        + mean * mean * y * 0.5 / shape
        - 0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y) // c1
    )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x =
    (mean +
      mean * mean * y * 0.5 / shape -
      0.5 * mean / shape * math.sqrt(
        4 * mean * shape * y +
          mean * mean * y * y
      ) // c1
    )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x)) x
  else mean * mean / x
}
<<< #1409
class Sample {
  def mkFunc(): String => Boolean = {
    if(flag) {
      v => true
    } else {
      v => false
    }
  }
}
>>>
class Sample {
  def mkFunc(): String => Boolean = {
    if (flag) { v => true }
    else { v => false }
  }
}
<<< fold ctor body with zero args
val foo = new Bar { () =>
  f(42)
}
>>>
val foo = new Bar { () => f(42) }
<<< preserve ctor body with zero args
val foo = new Bar { () => f(42) }
>>>
val foo = new Bar { () => f(42) }
<<< fold ctor body with wildcard arg
val foo = new Bar { _ =>
  println("a")
}
>>>
val foo = new Bar { _ => println("a") }
<<< fold apply with zero args
val foo = Bar { () =>
  f(42)
}
>>>
val foo = Bar { () => f(42) }
<<< keep new class definition as is
val a = new A {
  def f = b
}
>>>
val a = new A {
  def f = b
}
<<< 8.1: infix with longer left ||
val a =
  1 + 2 * 3 && 4 ^ 5 || 6 op
    7 map {
      8 % 9
    }
>>>
val a =
  1 + 2 * 3 && 4 ^ 5 || 6 op 7 map {
    8 % 9
  }
<<< 8.2: infix with shorter left ||
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
>>>
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op
  7 map { 8 % 9 }
<<< 8.3: infix with longer left ||, narrow
maxColumn = 20
===
val a = 1 + 2 * 3 && 4 ^ 5 || 6 op 7 map { 8 % 9 }
>>>
val a =
  1 + 2 * 3 && 4 ^
    5 || 6 op
    7 map { 8 % 9 }
<<< 8.4: infix with shorter left ||, narrow
maxColumn = 17
===
{
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
val b = { 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 } || somethinglong }
}
>>>
{
  val a =
    1 + 2 * 3 ||
      4 ^
      5 && 6 op
      7 map {
        8 % 9
      }
  val b = {
    1 + 2 * 3 ||
    4 ^ 5 && 6 op
      7 map {
        8 % 9
      } ||
      somethinglong
  }
}
<<< 8.5: sequences of infix operations
maxColumn = 75
runner.optimizer.forceConfigStyleOnOffset = 1000
===
val strings = Seq(
    "MetricEvaluatorResult:",
    s"  # engine params evaluated: ${engineParamsScores.size}") ++
    Seq(
      "Optimal Engine Params:",
      s"  $bestEPStr",
      "Metrics:",
      s"  $metricHeader: ${bestScore.score}") ++
    otherMetricHeaders.zip(bestScore.otherScores).map {
      case (h, s) => s"  $h: $s"
    } ++
    outputPath.toSeq.map { p =>
      s"The best variant params can be found in $p"
    }
>>>
val strings = Seq(
  "MetricEvaluatorResult:",
  s"  # engine params evaluated: ${engineParamsScores.size}"
) ++ Seq(
  "Optimal Engine Params:",
  s"  $bestEPStr",
  "Metrics:",
  s"  $metricHeader: ${bestScore.score}"
) ++ otherMetricHeaders.zip(bestScore.otherScores).map {
  case (h, s) => s"  $h: $s"
} ++ outputPath.toSeq.map { p =>
  s"The best variant params can be found in $p"
}
<<< 8.6: assignment with short expression
object a {
  plugins(service.pluginType) += service.pluginName -> service
}
>>>
object a {
  plugins(service.pluginType) +=
    service.pluginName -> service
}
<<< 8.7
maxColumn = 80
===
val json = ("event" -> data("event")) ~ ("entityType" -> "user") ~
       ("entityId" -> data("userId")) ~ ("targetEntityType" -> "item") ~
       ("targetEntityId" -> data("itemId")) ~
       ("eventTime" -> data("timestamp")) ~ ("properties" -> (("context" ->
       (("ip" -> data("context[ip]")) ~ ("prop1" -> data("context[prop1]")
         .toDouble) ~ ("prop2" -> data("context[prop2]")))) ~
       ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
       ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))))
>>>
val json =
  ("event" -> data("event")) ~
    ("entityType" -> "user") ~
    ("entityId" -> data("userId")) ~
    ("targetEntityType" -> "item") ~
    ("targetEntityId" -> data("itemId")) ~
    ("eventTime" -> data("timestamp")) ~
    ("properties" ->
      (("context" ->
        (("ip" -> data("context[ip]")) ~
          ("prop1" -> data("context[prop1]").toDouble) ~
          ("prop2" -> data("context[prop2]")))) ~
        ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
        ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))))
<<< 8.8
maxColumn = 80
===
override def hashCode: Int = 41 + fields.hashCode
>>>
override def hashCode: Int = 41 + fields.hashCode
<<< 8.9
maxColumn = 80
===
object a {
val fields = JField("engineVariant", JString(i.engineVariant)) ::
   JField("engineFactory", JString(i.engineFactory)) ::
     JField("batch", JString(i.batch)) ::
     JField("env", Extraction.decompose(i.env)(DefaultFormats))
}
>>>
object a {
  val fields = JField("engineVariant", JString(i.engineVariant)) ::
    JField("engineFactory", JString(i.engineFactory)) ::
    JField("batch", JString(i.batch)) ::
    JField("env", Extraction.decompose(i.env)(DefaultFormats))
}
<<< 8.10
maxColumn = 80
===
object a {
  def isReservedPrefix(name: String): Boolean =
      name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
>>>
object a {
  def isReservedPrefix(name: String): Boolean =
    name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
<<< 8.11
maxColumn = 80
===
Some(
  ("ip" -> data.get("context[ip]")) ~ (
  "prop1" ->
     data.get("context[prop1]").map(_.toDouble)
))
>>>
Some(
  ("ip" -> data.get("context[ip]")) ~
    ("prop1" -> data.get("context[prop1]").map(_.toDouble))
)
<<< 8.12
maxColumn = 80
===
val json = (estype -> ("properties" -> ("status" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("startTime" ->
      ("type" -> "date")) ~ ("endTime" -> ("type" -> "date")) ~ ("engineId" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVersion" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVariant" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineFactory" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("batch" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("dataSourceParams" -> ("type" -> "string") ~ ("index" ->
        "not_analyzed")) ~ ("preparatorParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~ ("algorithmsParams" -> ("type" ->
          "string") ~ ("index" -> "not_analyzed")) ~ ("servingParams" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("status" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed"))))
>>>
val json =
  (estype ->
    ("properties" ->
      ("status" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("startTime" -> ("type" -> "date")) ~
      ("endTime" -> ("type" -> "date")) ~
      ("engineId" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineVersion" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineVariant" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineFactory" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("batch" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("dataSourceParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~
      ("preparatorParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~
      ("algorithmsParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~
      ("servingParams" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("status" -> ("type" -> "string") ~ ("index" -> "not_analyzed"))))
<<< 8.13
maxColumn = 80
===
val a = b match {
  case i: EngineInstance =>
    JObject(
      JField("id", JString(i.id)) :: JField("status", JString(i.status)) ::
        JField("startTime", JString(i.startTime.toString)) ::
        JField("endTime", JString(i.endTime.toString)) ::
        JField("engineId", JString(i.engineId)) ::
        JField("engineVersion", JString(i.engineVersion)) ::
        JField("engineVariant", JString(i.engineVariant)) ::
        JField("engineFactory", JString(i.engineFactory)) ::
        JField("batch", JString(i.batch)) ::
        JField("env", Extraction.decompose(i.env)(DefaultFormats)) :: JField(
          "sparkConf",
          Extraction.decompose(i.sparkConf)(DefaultFormats)
        ) :: JField("dataSourceParams", JString(i.dataSourceParams)) ::
        JField("preparatorParams", JString(i.preparatorParams)) ::
        JField("algorithmsParams", JString(i.algorithmsParams)) ::
        JField("servingParams", JString(i.servingParams)) ::
        Nil)
}
>>>
val a = b match {
  case i: EngineInstance =>
    JObject(
      JField("id", JString(i.id)) :: JField("status", JString(i.status)) ::
        JField("startTime", JString(i.startTime.toString)) ::
        JField("endTime", JString(i.endTime.toString)) ::
        JField("engineId", JString(i.engineId)) ::
        JField("engineVersion", JString(i.engineVersion)) ::
        JField("engineVariant", JString(i.engineVariant)) ::
        JField("engineFactory", JString(i.engineFactory)) ::
        JField("batch", JString(i.batch)) ::
        JField("env", Extraction.decompose(i.env)(DefaultFormats)) ::
        JField(
          "sparkConf",
          Extraction.decompose(i.sparkConf)(DefaultFormats)
        ) :: JField("dataSourceParams", JString(i.dataSourceParams)) ::
        JField("preparatorParams", JString(i.preparatorParams)) ::
        JField("algorithmsParams", JString(i.algorithmsParams)) ::
        JField("servingParams", JString(i.servingParams)) :: Nil
    )
}
<<< 8.14
maxColumn = 80
===
private lazy val subNode: Parser[SubNode] = rep(' ') ~>
  ((opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ {
    name => AttrAppendSubNode(name)
  }) |
  (opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ {
    name => AttrRemoveSubNode(name)
  }) |    (opt('*') ~ '[' ~> attrName <~ ']' ^^ {
     name => AttrSubNode(name)
   }) |

   ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
   ('<' ~ '*' ~ '>') ^^ (a => SurroundKids()) |
   ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
   ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
   '*' ^^ (a => KidsSubNode()) |
   '^' ~ '*' ^^ (a => SelectThisNode(true)) |
   '^' ~ '^' ^^ (a => SelectThisNode(false)))
>>>
private lazy val subNode: Parser[SubNode] = rep(' ') ~>
  ((opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ { name =>
    AttrAppendSubNode(name)
  }) |
    (opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ { name =>
      AttrRemoveSubNode(name)
    }) |
    (opt('*') ~ '[' ~> attrName <~ ']' ^^ { name => AttrSubNode(name) }) |
    ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
    ('<' ~ '*' ~ '>') ^^
    (a => SurroundKids()) |
    ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
    ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
    ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
    ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
    '*' ^^
    (a => KidsSubNode()) |
    '^' ~ '*' ^^
    (a => SelectThisNode(true)) |
    '^' ~ '^' ^^
    (a => SelectThisNode(false)))
<<< 8.15
maxColumn = 80
===
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
   import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~
        ("properties" -> (("email" -> data("data[email]")) ~
          ("email_type" -> data("data[email_type]")) ~
          ("merges" -> (("EMAIL" -> data("data[merges][EMAIL]")) ~
            ("FNAME" -> data("data[merges][FNAME]"))) ~
            ("LNAME" -> data("data[merges][LNAME]")) ~
            ("INTERESTS" -> data.get("data[merges][INTERESTS]")))) ~
          ("ip_opt" -> data("data[ip_opt]")) ~
          ("ip_signup" -> data("data[ip_signup]")))
      json
  }
}
>>>
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
    import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~
        ("properties" ->
          (("email" -> data("data[email]")) ~
            ("email_type" -> data("data[email_type]")) ~
            ("merges" ->
              (("EMAIL" -> data("data[merges][EMAIL]")) ~
                ("FNAME" -> data("data[merges][FNAME]"))) ~
              ("LNAME" -> data("data[merges][LNAME]")) ~
              ("INTERESTS" -> data.get("data[merges][INTERESTS]")))) ~
          ("ip_opt" -> data("data[ip_opt]")) ~
          ("ip_signup" -> data("data[ip_signup]")))
    json
  }
}
<<< 8.16
maxColumn = 80
===
override def preRestart(cause: Throwable, msg: Option[Any]) {
       if (master ne null) {
        master ! "failed with " + cause + " while processing " + msg
       }
       context stop self
     }
>>>
override def preRestart(cause: Throwable, msg: Option[Any]) {
  if (master ne null) {
    master ! "failed with " + cause + " while processing " + msg
  }
  context stop self
}
<<< 8.17
maxColumn = 80
===
object a {
   def `media-range-def` =
     rule {
       "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) |
        '*' ~ push("*") ~ push("*")
     }
}
>>>
object a {
  def `media-range-def` =
    rule {
      "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) | '*' ~ push("*") ~ push("*")
    }
}
<<< 8.18
maxColumn = 80
===
object a {
  (people.map(p => (p.name, p.age))
  // c1
  returning people.map(_.id)
  // c2
  into ((nameAge, id) => Person(id, nameAge._1, nameAge._2))
  )
}
>>>
object a {
  (people.map(p => (p.name, p.age))
  // c1
  returning people.map(_.id)
  // c2
  into ((nameAge, id) => Person(id, nameAge._1, nameAge._2)))
}
<<< 8.19
maxColumn = 80
===
def `day-name` =
     rule(
       "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
        "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6))
>>>
def `day-name` =
  rule(
    "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
      "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6)
  )
<<< 8.20
maxColumn = 80
===
HttpResponse(
   StatusCodes.ServiceUnavailable,
   entity = "The server was not able " +
   "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
>>>
HttpResponse(
  StatusCodes.ServiceUnavailable,
  entity = "The server was not able " +
    "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
<<< 8.21
maxColumn = 80
===
private val allParams: Map[String, String] = mandatoryParams +
    (
      "data-config" ->
        dummyOptionalConfigPath,
      "max-sales-mappers" ->
        "10",
      "overwrite" ->
        null,
      "keep" -> dummyOptionalMaxVersionCount
    )
>>>
private val allParams: Map[String, String] = mandatoryParams +
  (
    "data-config" -> dummyOptionalConfigPath,
    "max-sales-mappers" -> "10",
    "overwrite" -> null,
    "keep" -> dummyOptionalMaxVersionCount
  )
<<< 8.22
maxColumn = 40
===
"Terminating(" + reason + ")" +
                   (toDie.toSeq.sorted mkString
                     (
                      "\n" +
                        indent +
                        "   |    toDie: ", "\n" + indent + "   |           ", ""
                     ))
>>>
"Terminating(" + reason + ")" +
  (toDie.toSeq.sorted mkString
    (
      "\n" + indent + "   |    toDie: ",
      "\n" + indent + "   |           ",
      ""
    ))
<<< 8.23
maxColumn = 80
===
val ret = (if (dailyStats.isEmpty)
                   0
                 else {
                   val yestStats = dailyStats.last
                   val yestNav = yestStats.nav
                   (nav -
                     yestNav) / nav - 1
                 })
>>>
val ret =
  (if (dailyStats.isEmpty) 0
   else {
     val yestStats = dailyStats.last
     val yestNav = yestStats.nav
     (nav - yestNav) / nav - 1
   })
<<< 8.24
maxColumn = 80
===
def isErrorEnabled(logClass: Class[_], logSource: String) =
    (eventStream.logLevel >= ErrorLevel) &&
      Logger(logClass, logSource).isErrorEnabled
>>>
def isErrorEnabled(logClass: Class[_], logSource: String) =
  (eventStream.logLevel >= ErrorLevel) && Logger(logClass, logSource)
    .isErrorEnabled
<<< 8.25
maxColumn = 80
===
def getShort(implicit byteOrder: ByteOrder): Short = {
    if (byteOrder == ByteOrder.BIG_ENDIAN)
      ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
    else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
      ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
     else throw new IllegalArgumentException("Unknown byte order " + byteOrder)
   }
>>>
def getShort(implicit byteOrder: ByteOrder): Short = {
  if (byteOrder == ByteOrder.BIG_ENDIAN)
    ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
  else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
    ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
  else throw new IllegalArgumentException("Unknown byte order " + byteOrder)
}
<<< 8.26
maxColumn = 80
===
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m)) changeMembers(membersByAge - m + m) // replace
  }
>>>
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m)) changeMembers(membersByAge - m + m) // replace
  }
<<< 8.27
maxColumn = 80
===
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and
    (resultAfter must beEqualTo(None))
}
>>>
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and (resultAfter must beEqualTo(None))
}
<<< 8.28
object a {
  val b = qual1 op1 { 1 + 2 + 3 + 4 + 5 } op2
    111 * 222 * 333 * 444 * 555 op3
    { "1 / 2 / 3 / 4 / 5 / 6 / 7" }
}
>>>
object a {
  val b = qual1 op1 {
    1 + 2 + 3 + 4 + 5
  } op2
    111 * 222 * 333 * 444 * 555 op3 {
      "1 / 2 / 3 / 4 / 5 / 6 / 7"
    }
}
<<< 8.29
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
>>>
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
<<< 8.30
object a {
  json should be(
    """aaa bbb ccc ddd eee fff ggg"""
  )
}
>>>
object a {
  json should be(
    """aaa bbb ccc ddd eee fff ggg"""
  )
}
<<< 8.31 indent after comment
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
>>>
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
<<< #1334 1: continue chain indent after a comment
class Foo {
  val vv = v.aaa //
  //
.bbb
.ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
>>>
class Foo {
  val vv = v.aaa //
    //
    .bbb.ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
<<< #1334 2: continue chain indent after a comment, a bit longer
class Foo {
  val vv = v.aaa //
  .bbb //
  //
  .ccc //
  .ddd
  .eee()
}
>>>
class Foo {
  val vv = v.aaa //
    .bbb //
    //
    .ccc //
    .ddd.eee()
}
<<< #1334 3: continue chain indent after a comment with apply
class Foo {
  val vv = v.aaa //
  .bbb() //
  //
  .ccc //
  .ddd()
}
>>>
class Foo {
  val vv = v.aaa //
    .bbb() //
    //
    .ccc //
    .ddd()
}
<<< #1334 4: continue chain indent after a comment with apply, longer
class Foo {
  val vv = v.aaa //
  .bbb() //
  .ccc() //
  .ddd()
}
>>>
class Foo {
  val vv = v.aaa //
    .bbb() //
    .ccc() //
    .ddd()
}
<<< #1334 5: select and a block apply after a comment
     val a: Vector[Array[Double]] = b.c
     // similarUserFeatures may not contain the requested user
   .map { x =>
       similarUserFeatures.get(x)
     }.flatten
     // another comment
     .map { foo =>
       bar
       }
       .tail
>>>
val a: Vector[Array[Double]] = b.c
  // similarUserFeatures may not contain the requested user
  .map { x =>
    similarUserFeatures.get(x)
  }.flatten
  // another comment
  .map { foo => bar }.tail
<<< #1334 6: multiple select and a match after a comment
val a: Vector[Array[Double]] = b.c
       // Only handle first case, others will be fixed on the next pass.
  .headOption
  .a match {
 case None =>
 case _ =>
}
>>>
val a: Vector[Array[Double]] = b.c
  // Only handle first case, others will be fixed on the next pass.
  .headOption.a match {
  case None =>
  case _ =>
}
<<< #1888 check presence of comment, lack of break
maxColumn = 80
===
object a {
  def b(c: D): E = {
    val a = b.c
      .foo(_.tree.tpe =:= typeOf[D])
      .flatMap { x =>
        x.tree.children.tail.map { case E(F(g)) => g.asInstanceOf[String] }
      }
      .headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
>>>
object a {
  def b(c: D): E = {
    val a = b.c.foo(_.tree.tpe =:= typeOf[D]).flatMap { x =>
      x.tree.children.tail.map { case E(F(g)) => g.asInstanceOf[String] }
    }.headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
<<< binpack call
binPack.preset = true
optIn.configStyleArguments = false
===
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")), G(Some(Seq(h, i)), Some(Seq(j, k)), a.b, c.d, e.f.g, h.i.j)).foo
  }
}
>>>
object a {
  test("foo") {
    a.b(c, d) shouldBe E(
      Seq(F(1, "v1"), F(2, "v2")),
      G(
        Some(Seq(h, i)),
        Some(Seq(j, k)), a.b, c.d,
        e.f.g, h.i.j
      )
    ).foo
  }
}
<<< binPack indent expiresOn=Before when dangle
binPack.preset = true
optIn.configStyleArguments = false
===
object a {
   protected def foo[U](bar: String, baz: Seq[String] = Seq.empty)(
       f: HttpResponse => U
  ): U = qux
}
>>>
object a {
  protected def foo[U](
      bar: String,
      baz: Seq[String] = Seq.empty
  )(f: HttpResponse => U): U = qux
}
