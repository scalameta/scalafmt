align.preset = more
<<< => with comment
x match {
  case 1 => 2 // this is a comment
  case 11 => 22 // another one
  case 111 => 222 // third!

  case 1111 => 1111 // Please ignore me, I'm a loner
}
>>>
x match {
  case 1   => 2   // this is a comment
  case 11  => 22  // another one
  case 111 => 222 // third!

  case 1111 => 1111 // Please ignore me, I'm a loner
}
<<< val = with comment
{
  val x = 2 // x
  val xx = 22 // xx
  val xxx = 222 // xxx

  val xxxx = 2222 // loner
}
>>>
{
  val x   = 2   // x
  val xx  = 22  // xx
  val xxx = 222 // xxx

  val xxxx = 2222 // loner
}
<<< var = with comment
{
  var x = 2 // x
  var xx = 22 // xx
  var xxx = 222 // xxx

  var xxxx = 2222 // loner
}
>>>
{
  var x   = 2   // x
  var xx  = 22  // xx
  var xxx = 222 // xxx

  var xxxx = 2222 // loner
}
<<< def = with comment
{
  def x = 2 // x
  def xx = 22 // xx
  def xxx = 222 // xxx

  def xxxx = 2222 // loner
}
>>>
{
  def x   = 2   // x
  def xx  = 22  // xx
  def xxx = 222 // xxx

  def xxxx = 2222 // loner
}
<<< module id
    libraryDependencies ++= Seq(
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % "test",
      "org.scala-lang" % "scala-compiler" % scalaVersion.value % "test",
      "ch.qos.logback" % "logback-classic" % "1.1.6" % "test",
      "com.googlecode.java-diff-utils" % "diffutils" % "1.3.0" % "test",
      "com.ibm" %% "couchdb-scala" % "0.6.0" % "test",
      "com.lihaoyi" %% "scalatags" % "0.5.4" % "test",
      "org.apache.commons" % "commons-math3" % "3.6" % "test",
      "org.scalatest" %%% "scalatest" % Deps.scalatest % "test"
    )
>>>
libraryDependencies ++= Seq(
  "org.scala-lang"                 % "scala-reflect"   % scalaVersion.value % "test",
  "org.scala-lang"                 % "scala-compiler"  % scalaVersion.value % "test",
  "ch.qos.logback"                 % "logback-classic" % "1.1.6"            % "test",
  "com.googlecode.java-diff-utils" % "diffutils"       % "1.3.0"            % "test",
  "com.ibm"                       %% "couchdb-scala"   % "0.6.0"            % "test",
  "com.lihaoyi"                   %% "scalatags"       % "0.5.4"            % "test",
  "org.apache.commons"             % "commons-math3"   % "3.6"              % "test",
  "org.scalatest"                %%% "scalatest"       % Deps.scalatest     % "test"
)
<<< slick #138
{
def address = column[String]("address", O.PrimaryKey)
def name = column[String]("name")
def status = column[Int]("status")
}
>>>
{
  def address = column[String]("address", O.PrimaryKey)
  def name    = column[String]("name")
  def status  = column[Int]("status")
}
<<< colors #138
// tuples
val colors = Map (
     "white"   -> white,
     "green"   -> green,
     "yellow"  -> yellow,
     "red"     -> red,
     "blue"    -> blue,
     "cyan"    -> cyan,
     "black"   -> black,
     "magenta" -> magenta
)
>>>
// tuples
val colors = Map(
  "white"   -> white,
  "green"   -> green,
  "yellow"  -> yellow,
  "red"     -> red,
  "blue"    -> blue,
  "cyan"    -> cyan,
  "black"   -> black,
  "magenta" -> magenta
)
<<< sbt module ID #138
{
  addSbtPlugin("com.eed3si9n"   % "sbt-unidoc"            % "0.3.2")
  addSbtPlugin("com.github.gseitz"    % "sbt-release"           % "1.0.0")
  addSbtPlugin("com.jsuereth"  % "sbt-pgp"               % "1.0.0")
  addSbtPlugin("com.typesafe.sbt"     % "sbt-ghpages"           % "0.5.3")
  addSbtPlugin("com.typesafe.sbt"     % "sbt-site"              % "0.8.1")
  addSbtPlugin("org.tpolecat"  % "tut-plugin"            % "0.4.0")
  addSbtPlugin("pl.project13.scala"   % "sbt-jmh"               % "0.2.3")
  addSbtPlugin("org.scalastyle"      %% "scalastyle-sbt-plugin" % "0.8.0")
  addSbtPlugin("org.scoverage" % "sbt-scoverage"         % "1.2.0")
  addSbtPlugin("com.typesafe.sbt"     % "sbt-git"               % "0.8.4")
  addSbtPlugin("org.scala-js" % "sbt-scalajs"           % "0.6.8")
  addSbtPlugin("com.github.tkawachi"  % "sbt-doctest"           % "0.3.5")
  addSbtPlugin("org.xerial.sbt"       % "sbt-sonatype"          %  "1.1")
}
>>>
{
  addSbtPlugin("com.eed3si9n"        % "sbt-unidoc"            % "0.3.2")
  addSbtPlugin("com.github.gseitz"   % "sbt-release"           % "1.0.0")
  addSbtPlugin("com.jsuereth"        % "sbt-pgp"               % "1.0.0")
  addSbtPlugin("com.typesafe.sbt"    % "sbt-ghpages"           % "0.5.3")
  addSbtPlugin("com.typesafe.sbt"    % "sbt-site"              % "0.8.1")
  addSbtPlugin("org.tpolecat"        % "tut-plugin"            % "0.4.0")
  addSbtPlugin("pl.project13.scala"  % "sbt-jmh"               % "0.2.3")
  addSbtPlugin("org.scalastyle"     %% "scalastyle-sbt-plugin" % "0.8.0")
  addSbtPlugin("org.scoverage"       % "sbt-scoverage"         % "1.2.0")
  addSbtPlugin("com.typesafe.sbt"    % "sbt-git"               % "0.8.4")
  addSbtPlugin("org.scala-js"        % "sbt-scalajs"           % "0.6.8")
  addSbtPlugin("com.github.tkawachi" % "sbt-doctest"           % "0.3.5")
  addSbtPlugin("org.xerial.sbt"      % "sbt-sonatype"          % "1.1")
}
<<< final val #138
object a{
final val CAPTURED      = 1 << 16       // var
final val LABEL         = 1 << 17       // meth
final val INCONSTRUCTOR = 1 << 17       // class
final val SYNTHETIC     = 1 << 21       // symbol
final val STABLE        = 1 << 22       // f
final val BRIDGE        = 1 << 26       // fu
final val ACCESSOR      = 1 << 27       // a v
final val SUPERACCESSOR = 1 << 28       // a su
final val MODULEVAR     = 1 << 30       // for v
final val IS_ERROR      = 1L << 32      // symbol
final val OVERLOADED    = 1L << 33      // symbol
}
>>>
object a {
  final val CAPTURED      = 1 << 16  // var
  final val LABEL         = 1 << 17  // meth
  final val INCONSTRUCTOR = 1 << 17  // class
  final val SYNTHETIC     = 1 << 21  // symbol
  final val STABLE        = 1 << 22  // f
  final val BRIDGE        = 1 << 26  // fu
  final val ACCESSOR      = 1 << 27  // a v
  final val SUPERACCESSOR = 1 << 28  // a su
  final val MODULEVAR     = 1 << 30  // for v
  final val IS_ERROR      = 1L << 32 // symbol
  final val OVERLOADED    = 1L << 33 // symbol
}
<<< tricky regex #138
def f[A](x: A)(f: A => Int) = f(x) match {
  case 1 => true
  case 222 => false
}
>>>
def f[A](x: A)(f: A => Int) = f(x) match {
  case 1   => true
  case 222 => false
}
<<< tricky regex #138 2
def f[A](x: A)(f: A => Int) = f(x) match {
  case 1 => true
  case 222 => false
}
>>>
def f[A](x: A)(f: A => Int) = f(x) match {
  case 1   => true
  case 222 => false
}
<<< conflicting number of columns
    libraryDependencies ++= Seq(
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % "test",
      "org.scala-lang" % "scala-compiler",
      "ch.qos.logback" % "logback-classic" % "1.1.6" % "test"
     )
>>>
libraryDependencies ++= Seq(
  "org.scala-lang" % "scala-reflect"   % scalaVersion.value % "test",
  "org.scala-lang" % "scala-compiler",
  "ch.qos.logback" % "logback-classic" % "1.1.6"            % "test"
)
<<< 2x newline is respected
class A {
  override def x = 1

    override def xx = 11
}
>>>
class A {
  override def x = 1

  override def xx = 11
}
<<< align extends, #148
object A {
  trait B  extends A
  trait BB extends A

class B  extends A
class BB extends A

type C = Int
type CC = String

  trait Eq[-A]   extends Any            { def eqv(x: A, y: A): Boolean }
  trait Hash[-A] extends Any with Eq[A] { def hash(x: A): Int          }
}
>>>
object A {
  trait B  extends A
  trait BB extends A

  class B  extends A
  class BB extends A

  type C  = Int
  type CC = String

  trait Eq[-A]   extends Any            { def eqv(x: A, y: A): Boolean }
  trait Hash[-A] extends Any with Eq[A] { def hash(x: A): Int          }
}
<<< unicode => #155
1 match {
  case 1 ⇒ 1
  case 11 ⇒ 1
}
>>>
1 match {
  case 1  ⇒ 1
  case 11 ⇒ 1
}
<<< unicode -> #155
val m = Map(
    1 → 1,
  11 → 1
)
>>>
val m = Map(
  1  → 1,
  11 → 1
)
<<< align by <- #155
for {
  a <- List(1)
  aaa <- List(1)
} yield 1
>>>
for {
  a   <- List(1)
  aaa <- List(1)
} yield 1
<<< unicode <- #155
for {
  a ← List(1)
  aaa ← List(1)
} yield 1
>>>
for {
  a   ← List(1)
  aaa ← List(1)
} yield 1
<<< enumerator val = #155
for {
  a ← List(1)
  a = List(1)
  aaa = List(1)
} yield 1
>>>
for {
  a ← List(1)
  a   = List(1)
  aaa = List(1)
} yield 1
<<< don't jump scope #152
object Cleaver {
   def apply[R, A, B](): Cleaver[R, A, B] = new Cleaver[R, A, B] {
    def split(x: R): A -> B               = (l(x), r(x))
    def join(x: A -> B): R                = f(x._1, x._2)
   }
 }
>>>
object Cleaver {
  def apply[R, A, B](): Cleaver[R, A, B] = new Cleaver[R, A, B] {
    def split(x: R): A -> B = (l(x), r(x))
    def join(x: A -> B): R  = f(x._1, x._2)
  }
}
<<< don't jump scope #152 2
object Cleaver {
   def apply[R, A, B](): Cleaver[R, A, B] = new Cleaver[R, A, B] {
    def split(x: R): A -> B               = (l(x), r(x))
    def join(x: A -> B): R                = f(x._1, x._2)
   }
 }
>>>
object Cleaver {
  def apply[R, A, B](): Cleaver[R, A, B] = new Cleaver[R, A, B] {
    def split(x: R): A -> B = (l(x), r(x))
    def join(x: A -> B): R  = f(x._1, x._2)
  }
}
<<< only align single-line statements
{
val a = function(1, b)
val aaaaa = function(1, b)
val aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa = function(1, b, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
}
>>>
{
  val a     = function(1, b)
  val aaaaa = function(1, b)
  val aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =
    function(1, b, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
}
<<< infix owner
   Ok(Json.obj(
       "api" -> Json.obj(
         "current" -> api.currentVersion,
         "olds" -> api.oldVersions.map { old =>
           Json.obj(
             "version" -> old.version,
             "deprecatedAt" -> old.deprecatedAt,
             "unsupportedAt" -> old.unsupportedAt)
         })
     )) as JSON
>>>
Ok(
  Json.obj(
    "api" -> Json.obj(
      "current" -> api.currentVersion,
      "olds" -> api.oldVersions.map { old =>
        Json.obj(
          "version"       -> old.version,
          "deprecatedAt"  -> old.deprecatedAt,
          "unsupportedAt" -> old.unsupportedAt
        )
      }
    )
  )
) as JSON
<<< mixed val/var/def
{
  var x = 2 // x
  val xx = 22 // xx
  def xxx = 222 // xxx

  def xxxx = 2222 // loner
}
>>>
{
  var x   = 2   // x
  val xx  = 22  // xx
  def xxx = 222 // xxx

  def xxxx = 2222 // loner
}
<<< mixed object/class/trait
object mixed {
protected trait False extends Val
protected case object False extends Val
  protected case class Zero(zeroty: nir.Type)                     extends Val
}
>>>
object mixed {
  protected trait False                       extends Val
  protected case object False                 extends Val
  protected case class Zero(zeroty: nir.Type) extends Val
}
<<< #513
{
  if (cond) foo
  else { val chars = s.toCharArray }
  val prefix       = "sbt.paths." + projectName + "." + uncapitalize(config.name) + "."
}
>>>
{
  if (cond) foo
  else { val chars = s.toCharArray }
  val prefix =
    "sbt.paths." + projectName + "." + uncapitalize(config.name) + "."
}
<<< #521
x match {
    case (xs: Seq[_], ys: Seq[_])                               =>
      xs.length == ys.length && xs.zip(ys).forall { case (x, y) => loop(x, y) }
  }
>>>
x match {
  case (xs: Seq[_], ys: Seq[_]) =>
    xs.length == ys.length && xs.zip(ys).forall { case (x, y) => loop(x, y) }
}
<<< #505
object M {
  implicit class TimestampOps[@specialized(Int, Long) A](val i: A){}
}
>>>
object M {
  implicit class TimestampOps[@specialized(Int, Long) A](val i: A) {}
}
<<< #531
Seq(
"com.github.seratch" %% "awscala"                     % "0.5.7",
"org.scalatest"      % "scalatest_2.11"               % "3.0.0" % Test,
"org.scalamock"      %% "scalamock-scalatest-support" % "3.2.2" % Test
)
>>>
Seq(
  "com.github.seratch" %% "awscala"                     % "0.5.7",
  "org.scalatest"       % "scalatest_2.11"              % "3.0.0" % Test,
  "org.scalamock"      %% "scalamock-scalatest-support" % "3.2.2" % Test
)
<<< #531 2
Seq (
  Seq(
    Seq(a % b % c, a %% bb %%% ccc, aaa % bb % c),
    Seq(aaa % bb % c, aaa %%% bb %% c, a % bb % ccc),
    Seq(
      aaa % bb % c,
      aaaaa %%% bbbb %% ccc,
      a % bb % ccc
    ),
    a % b % c %%%% a %% bb %%% ccc %%%% aaa % bb % c
  ),
  Seq(a % b % c, a %% bb %%% ccc, aaa % bb % c)
)
>>>
Seq(
  Seq(
    Seq(a   % b  % c, a    %% bb %%% ccc, aaa % bb % c),
    Seq(aaa % bb % c, aaa %%% bb  %% c, a     % bb % ccc),
    Seq(
      aaa     % bb    % c,
      aaaaa %%% bbbb %% ccc,
      a       % bb    % ccc
    ),
    a % b % c %%%% a %% bb %%% ccc %%%% aaa % bb % c
  ),
  Seq(a % b % c, a %% bb %%% ccc, aaa % bb % c)
)
<<< align comments in method chain
foo
  .x() // comment1
  .xx() // comment2
  .xxx() // comment3
>>>
foo
  .x()   // comment1
  .xx()  // comment2
  .xxx() // comment3
<<< should align comments on separate statements
object test {
  val ys = xs
    .filter(_ > 2) // comment1
    .filter(x => x + 1) // comment2
  ys.map(y => y + 1) // comment3
}
>>>
object test {
  val ys = xs
    .filter(_ > 2)      // comment1
    .filter(x => x + 1) // comment2
  ys.map(y => y + 1)    // comment3
}
<<< align comments on type infix
foo
  .x[T]() // comment1
  .xx[T]() // comment2
>>>
foo
  .x[T]()  // comment1
  .xx[T]() // comment2
<<< align comments on params
a.b(
  1, // comment1
  123  // comment2
)
>>>
a.b(
  1,  // comment1
  123 // comment2
)
<<< should align comments on params of methods
def method(
    abc: String, // abc comment
    d: String // d comment
) = ???
>>>
def method(
    abc: String, // abc comment
    d: String    // d comment
) = ???
<<< shouldn't align comments on the line which only has a comment
object x {
  println("foo bar") // comment
  // comment
  println("foo") // comment
}
>>>
object x {
  println("foo bar") // comment
  // comment
  println("foo") // comment
}
<<< #1720 original, two SL comments
type iovec = CStruct2[Ptr[Byte], // iov_base
                        CSize] // iov_len
>>>
type iovec = CStruct2[
  Ptr[Byte], // iov_base
  CSize
] // iov_len
<<< #1720 with val
val iovec = CStruct2[Ptr[Byte], // iov_base
                        CSize](a) // iov_len
>>>
val iovec = CStruct2[
  Ptr[Byte], // iov_base
  CSize
](a) // iov_len
<<< #1720 no align
align.preset = none
===
type iovec = CStruct2[Ptr[Byte], // iov_base
                        CSize] // iov_len
>>>
type iovec = CStruct2[
  Ptr[Byte], // iov_base
  CSize
] // iov_len
<<< #1720 second SL comment
type iovec = CStruct2[Ptr[Byte],
                        CSize] // iov_len
>>>
type iovec = CStruct2[Ptr[Byte], CSize] // iov_len
<<< #1720 first SL comment
type iovec = CStruct2[Ptr[Byte], // iov_base
                        CSize]
>>>
type iovec = CStruct2[
  Ptr[Byte], // iov_base
  CSize
]
<<< #1720 nested multi-arg type with two SL comments
type iovec = CStruct2[Ptr[Byte, // iov_base
                        CSize]] // iov_len
>>>
type iovec = CStruct2[Ptr[
  Byte, // iov_base
  CSize
]] // iov_len
<<< #1720 one arg with SL comment
type iovec = CStruct2[Ptr[Byte] // iov_base
                        ]
>>>
type iovec = CStruct2[
  Ptr[Byte] // iov_base
]
<<< #1720 first inline comment
type iovec = CStruct2[Ptr[Byte], /* iov_base */
                        CSize]
>>>
type iovec = CStruct2[
  Ptr[Byte], /* iov_base */
  CSize
]
<<< #1720 first inline comment with apply
val iovec = CStruct2(Ptr(Byte), /* iov_base */
                        CSize)
>>>
val iovec = CStruct2(
  Ptr(Byte), /* iov_base */
  CSize
)
<<< pattern matching with tuples
x match {
  case 1 => a -> b
  case 42 => abc -> 3
}
>>>
x match {
  case 1  => a   -> b
  case 42 => abc -> 3
}
<<< #1896 1: long non-matching first
align.preset = most
align.tokens.add = [{code = "=", owner = "(Enumerator.Val|Defn.(Va(l|r)|Def|Type)|Term.Assign)"}]
===
object fmt {
  val header  = JwtHeader(algorithm = Some(JwtAlgorithm.HMD5))
  val claim   = JwtClaim(content = content)
  val content = payload.toString
}
>>>
object fmt {
  val header  = JwtHeader(algorithm = Some(JwtAlgorithm.HMD5))
  val claim   = JwtClaim(content = content)
  val content = payload.toString
}
<<< #1896 2: short non-matching first
align.preset = most
align.tokens.add = [{code = "=", owner = "(Enumerator.Val|Defn.(Va(l|r)|Def|Type)|Term.Assign)"}]
===
object fmt {
  val claim   = JwtClaim(content = content)
  val header  = JwtHeader(algorithm = Some(JwtAlgorithm.HMD5))
  val content = payload.toString
}
>>>
object fmt {
  val claim   = JwtClaim(content = content)
  val header  = JwtHeader(algorithm = Some(JwtAlgorithm.HMD5))
  val content = payload.toString
}
<<< #1896 3
align.preset = most
align.tokens.add = [{code = "=", owner = "(Enumerator.Val|Defn.(Va(l|r)|Def|Type)|Term.Assign)"}]
===
JwtClaim(
  abc = cba,
  content = content
)
>>>
JwtClaim(
  abc     = cba,
  content = content
)
<<< #1504
align.multiline = true
===
object a {
  val stringFoo = thing.identifier match {
    case foo : SuperFooBarIdentifier =>
     "somestring" / "other_string" / foo.identifyingid
    case tastyBar: TastyBarIdentifier =>
     "something" / "other_other" ? ("arg1" -> tastyBar.ider) & ("limit" -> 111)
    case unknown =>
     throw new IllegalArgumentException(s"Not sure at all what kinda class this is: ${unknown.getClass}")
  }
}
>>>
object a {
  val stringFoo = thing.identifier match {
    case foo: SuperFooBarIdentifier   =>
      "somestring" / "other_string" / foo.identifyingid
    case tastyBar: TastyBarIdentifier =>
      "something" / "other_other" ? ("arg1" -> tastyBar.ider) & ("limit" -> 111)
    case unknown                      =>
      throw new IllegalArgumentException(
        s"Not sure at all what kinda class this is: ${unknown.getClass}"
      )
  }
}
<<< #1811 1 no blanks
align.multiline = true
===
object a {
  for {
    a   <- Option(1)
    bbb <- Option(2)
    cccccc <- Option {
      3
    }
    dd <- Option(4)
  } yield ()
}
>>>
object a {
  for {
    a      <- Option(1)
    bbb    <- Option(2)
    cccccc <- Option {
      3
    }
    dd     <- Option(4)
  } yield ()
}
<<< #1811 1 with blanks
align.multiline = true
===
object a {
  for {
    a   <- Option(1)
    bbb <- Option(2)

    cccccc <- Option {
      3
    }

    dd <- Option(4)
  } yield ()
}
>>>
object a {
  for {
    a   <- Option(1)
    bbb <- Option(2)

    cccccc <- Option {
      3
    }

    dd <- Option(4)
  } yield ()
}
<<< #1811 2
align.multiline = true
align.arrowEnumeratorGenerator = true
===
object a {
  for {
    a   <- Option(1)
    bbb <- Option(2)
    cccccc <- Option {
      3
    }
    dd <- Option(4)
  } yield ()
}
>>>
object a {
  for {
    a      <- Option(1)
    bbb    <- Option(2)
    cccccc <- Option {
                3
              }
    dd     <- Option(4)
  } yield ()
}
<<< #1841 no blanks
align.multiline = true
===
object a {
  private[this] val pbClass       = Class.forName("java.lang.ProcessBuilder")
  private[this] val redirectClass = pbClass.getClasses find (_.getSimpleName == "Redirect")
}
>>>
object a {
  private[this] val pbClass       = Class.forName("java.lang.ProcessBuilder")
  private[this] val redirectClass =
    pbClass.getClasses find (_.getSimpleName == "Redirect")
}
<<< #1841 with blanks
align.multiline = true
===
object a {
  private[this] val pbClass       = Class.forName("java.lang.ProcessBuilder")

  private[this] val redirectClass = pbClass.getClasses find (_.getSimpleName == "Redirect")
}
>>>
object a {
  private[this] val pbClass = Class.forName("java.lang.ProcessBuilder")

  private[this] val redirectClass =
    pbClass.getClasses find (_.getSimpleName == "Redirect")
}
<<< multiline with blanks
align.preset = most
===
object a {
  def foo: Int = {
    val x = ???
    42
  }

  def bar: Int = {
    for { x <- "hey" } yield x
    42
  }

  def fooBig: Int = {
    42
  }

  def fooBigger: Int = {
    42
  }
}
>>>
object a {
  def foo: Int = {
    val x = ???
    42
  }

  def bar: Int = {
    for { x <- "hey" } yield x
    42
  }

  def fooBig: Int = {
    42
  }

  def fooBigger: Int = {
    42
  }
}
<<< multiline with blanks and comments and no blocks
align.preset = most
===
object a {
  def foo: Int =
    42
  // comment

  def fooBar: Int =
    42

  /* comment */
  def fooBarBaz: Int =
    42

  // comment
  def fooBarBazQux: Int =
    42
}
>>>
object a {
  def foo: Int =
    42
  // comment

  def fooBar: Int =
    42

  /* comment */
  def fooBarBaz: Int =
    42

  // comment
  def fooBarBazQux: Int =
    42
}
<<< multiline without blanks
align.preset = most
===
object a {
  def foo: Int = {
    val x = ???
    42
  }
  def bar: Int = {
    for { x <- "hey" } yield x
    42
  }
  def fooBig: Int = {
    42
  }
  def fooBigger: Int = {
    42
  }
}
>>>
object a {
  def foo: Int = {
    val x = ???
    42
  }
  def bar: Int = {
    for { x <- "hey" } yield x
    42
  }
  def fooBig: Int = {
    42
  }
  def fooBigger: Int = {
    42
  }
}
<<< singleline def without blanks
object a {
  def a: Int = b % c
  def aa: Int = bb % cc
  def aaa: Int = bbb % ccc
}
>>>
object a {
  def a: Int   = b   % c
  def aa: Int  = bb  % cc
  def aaa: Int = bbb % ccc
}
<<< singleline def with blocks and without blanks
object a {
  def a: Int = { b % c }
  def aa: Int = { bb % cc }
  def aaa: Int = { bbb % ccc }
}
>>>
object a {
  def a: Int = { b % c }
  def aa: Int = { bb % cc }
  def aaa: Int = { bbb % ccc }
}
<<< singleline val without blanks
object a {
  val a: Int = b % c
  val aa: Int = bb % cc
  val aaa: Int = bbb % ccc
}
>>>
object a {
  val a: Int   = b   % c
  val aa: Int  = bb  % cc
  val aaa: Int = bbb % ccc
}
<<< singleline val with blocks and without blanks
object a {
  val a: Int = { b % c }
  val aa: Int = { bb % cc }
  val aaa: Int = { bbb % ccc }
}
>>>
object a {
  val a: Int = { b % c }
  val aa: Int = { bb % cc }
  val aaa: Int = { bbb % ccc }
}
<<< #1948
align.preset = most
===
for {
  aaa <- bbb % ccc
  a <- b % c.map { x =>
    x * x
  }
} yield (a, aaa)
>>>
for {
  aaa <- bbb % ccc
  a   <- b   % c.map { x =>
           x * x
         }
} yield (a, aaa)
<<< #2151 with blank line
align.multiline = true
===
val x = blar match {
  case a  =>
    ???

  case aaaaaaaaaa => ???
}
>>>
val x = blar match {
  case a =>
    ???

  case aaaaaaaaaa => ???
}
<<< #2151 without blank line
align.multiline = true
===
val x = blar match {
  case a  =>
    ???
  case aaaaaaaaaa => ???
}
>>>
val x = blar match {
  case a          =>
    ???
  case aaaaaaaaaa => ???
}
