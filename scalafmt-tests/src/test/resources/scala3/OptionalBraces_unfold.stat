indent.significant = 3
newlines.source = unfold
<<< simple value equals
val test = // comm
    val a = ""
     a  +    ""
>>>
val test = // comm
   val a = ""
   a + ""
<<< if else with comment before colon
trait A /* comm */ :
  val cond =
   if true then
    stat1
    stat2
   else { // c1
     stat3
     stat4
     }
   end if
>>>
trait A /* comm */:
   val cond =
      if true then
         stat1
         stat2
      else { // c1
        stat3
        stat4
      }
      end if
<<< nested class with end marker
trait A /* comm */ :
  class B:
    val a = ""
  end B
>>>
trait A /* comm */:
   class B:
      val a = ""
   end B
<<< object
object Obj:
  def hello = 
      1
       2
  end hello
>>>
object Obj:
   def hello =
      1
      2
   end hello
<<< object with braces
object Obj{
  def hello = 
    1
    2
}
>>>
object Obj {
  def hello =
     1
     2
}
<<< extension method
maxColumn = 40
===
extension [A](a: Map[A, Foooooooooooooooo[B]]) 
    def add(b: A) = a + b
     def add2(b: A) = a + b
  
    def add3(b: A) = a + b
>>>
extension [A](
    a: Map[A, Foooooooooooooooo[B]]
)
   def add(b: A) = a + b
   def add2(b: A) = a + b

   def add3(b: A) = a + b
<<< extension multi
maxColumn = 40
===
extension [A](a: Map[A, Foooooooooooooooo[B]]) (using b: Map[A, Foooooooooooooooo[B]])
    def add(b: A) = a + b
     def add2(b: A) = a + b
  
    def add3(b: A) = a + b
>>>
extension [A](
    a: Map[A, Foooooooooooooooo[B]]
)(using b: Map[A, Foooooooooooooooo[B]])
   def add(b: A) = a + b
   def add2(b: A) = a + b

   def add3(b: A) = a + b
<<< if(cond) indentation 
trait A:
  val cond =
    if (true)
        stat1
         stat2
    else
       stat3
       stat4
>>>
trait A:
   val cond =
     if (true)
        stat1
        stat2
     else
        stat3
        stat4
<<< given with
given intOrd: Ord[Int] with Eq[Int] with // c1
    /* c2 */
     def compare(x: Int, y: Int) =
      if x < y then -1 else if x > y then +1 else 0
     def compare2(x: Int, y: Int) =
      if x < y then -1 else if x > y then +1 else 0
>>>
given intOrd: Ord[Int] with Eq[Int] with // c1
   /* c2 */
   def compare(x: Int, y: Int) =
     if x < y then
        -1
     else if x > y then
        +1
     else
        0
   def compare2(x: Int, y: Int) =
     if x < y then
        -1
     else if x > y then
        +1
     else
        0
<<< given with and a blank
given intOrd: Ord[Int] with Eq[Int] with

     def compare(x: Int, y: Int) =
      if x < y then -1 else if x > y then +1 else 0
>>>
given intOrd: Ord[Int] with Eq[Int] with

   def compare(x: Int, y: Int) =
     if x < y then
        -1
     else if x > y then
        +1
     else
        0
<<< derived trait, val-end, if-end
trait A extends B:
  val cond1 =
    if true then

     stat1
     stat2
    else

     stat3
     stat4
    end if
  end cond1
>>>
trait A extends B:
   val cond1 =
      if true then

         stat1
         stat2
      else

         stat3
         stat4
      end if
   end cond1
<<< derived trait, val-end, if-noend
trait A extends B:
  val cond1 =
    if true then
     stat1
     stat2
    else
     stat3
     stat4
  end cond1
>>>
trait A extends B:
   val cond1 =
     if true then
        stat1
        stat2
     else
        stat3
        stat4
   end cond1
<<< derived trait, val-noend, if-end
trait A extends B:
  val cond1 =
    if true then
     stat1
     stat2
    else
     stat3
     stat4
    end if
>>>
trait A extends B:
   val cond1 =
      if true then
         stat1
         stat2
      else
         stat3
         stat4
      end if
<<< derived trait, val-noend, if-noend
trait A extends B:
  val cond1 =
    if true then
     stat1
     stat2
    else
     stat3
     stat4
>>>
trait A extends B:
   val cond1 =
     if true then
        stat1
        stat2
     else
        stat3
        stat4
<<< derived trait with self
trait A extends B:

  self: C =>
  val cond =
   if true then
    stat1
    stat2
   else
     stat3
     stat4
   end if
>>>
trait A extends B:

   self: C =>
   val cond =
      if true then
         stat1
         stat2
      else
         stat3
         stat4
      end if
<<< lots of end markers
object a {
 trait A:
  val cond =
    if true then
      stat1
      stat2
    else
      stat3
      stat4
    end if
  end cond
  val cond =
    if true then
      stat1
      stat2
    else
      stat3
      stat4
    end if
  end cond
 end A
}
>>>
object a {
  trait A:
     val cond =
        if true then
           stat1
           stat2
        else
           stat3
           stat4
        end if
     end cond
     val cond =
        if true then
           stat1
           stat2
        else
           stat3
           stat4
        end if
     end cond
  end A
}
<<< ctor this
class a(vi: Int, vs: String):
  def this() =
    this(0, "")
    foo
  end this
  def this(vi: Int) =
    this(vi, "")
    foo
  end this
>>>
class a(vi: Int, vs: String):
   def this() =
      this(0, "")
      foo
   end this
   def this(vi: Int) =
      this(vi, "")
      foo
   end this
<<< match
object a:
  def foo =
    this match
      case A =>
         that match
            case b => bb
            case c => cc
         end match
      case B =>
         that match
            case c => cc
            case _ => dd
>>>
object a:
   def foo =
     this match
        case A =>
          that match
             case b =>
               bb
             case c =>
               cc
          end match
        case B =>
          that match
             case c =>
               cc
             case _ =>
               dd
<<< match type
object a:
  type foo[x] = x match
      case A =>
         that match
            case b => bb
            case c => cc
      case B =>
         that match
            case c => cc
            case _ => dd
>>>
object a:
   type foo[x] =
     x match
        case A =>
          that match
             case b =>
               bb
             case c =>
               cc
        case B =>
          that match
             case c =>
               cc
             case _ =>
               dd
<<< catch one
object a:
  def foo =
    try foo
    catch case A => foo
>>>
object a:
   def foo =
     try
        foo
     catch
        case A =>
          foo
<<< catch multiple
object a:
  def foo =
    try foo
    catch
      case A =>
         that match
            case b => bb
            case c => cc
         end match
      case B =>
         that match
            case c => cc
            case _ => dd
>>>
object a:
   def foo =
     try
        foo
     catch
        case A =>
          that match
             case b =>
               bb
             case c =>
               cc
          end match
        case B =>
          that match
             case c =>
               cc
             case _ =>
               dd
<<< try/finally, single
object a:
   def foo =
     try foo
     catch
       case a => baz
     finally bar
>>>
object a:
   def foo =
     try
        foo
     catch
        case a =>
          baz
     finally
        bar
<<< try/finally, multiple
object a:
   def foo =
     try
       foo
       bar
     catch
       case a => baz
     finally
       bar
       qux
>>>
object a:
   def foo =
     try
        foo
        bar
     catch
        case a =>
          baz
     finally
        bar
        qux
<<< for
object a:
  def foo =
    for
      x <- y
      x <- y
    do
      foo
      bar
  def foo =
    for
      x <- y
    do
      bar
>>>
object a:
   def foo =
     for
        x <- y
        x <- y
     do
        foo
        bar
   def foo =
     for x <- y do
        bar
<<< for-yield
object a:
  def foo =
    for
      x <- y
      x = y
      if x
    yield
      foo
      bar
  def foo =
    for
      x <- y
    yield
      foo
>>>
object a:
   def foo =
     for
        x <- y
        x = y
        if x
     yield
        foo
        bar
   def foo =
     for x <- y
     yield foo
<<< complex "block" expression
object a:
  def foo =
    if cond then
        sb.append(doc.text.substring(offset, end))
        sb.append(doc.text.substring(offset, end))
  def foo =
    if (cond) {
        sb.append(doc.text.substring(offset, end))
        sb.append(doc.text.substring(offset, end))
    }
>>>
object a:
   def foo =
     if cond then
        sb.append(doc.text.substring(offset, end))
        sb.append(doc.text.substring(offset, end))
   def foo =
     if (cond) {
       sb.append(doc.text.substring(offset, end))
       sb.append(doc.text.substring(offset, end))
     }
<<< lambda with =>
object a:
  val func: A => B = (a: A) =>
    a + a
    a * a
  func(a)
>>>
object a:
   val func: A => B =
     (a: A) =>
        a + a
        a * a
   func(a)
<<< if, with parens, without braces
object a:
  val a =
    if (a)
      if (aa)
        aaa
      // c1
    else
      b
  if (a)
    foo
  if (a)
    if (aa)
      foo
  if (a)
    if (aa)
      if (aaa) then
        foo
  if (a)
    foo
  else if (a)
    foo
    bar
  if (a)
    foo
    bar
  if (a)
    foo
    bar
    if (aa)
      foo
      bar
>>>
object a:
   val a =
     if (a)
        if (aa)
          aaa
        // c1
     else
       b
   if (a)
     foo
   if (a)
     if (aa)
       foo
   if (a)
     if (aa)
       if (aaa) then
          foo
   if (a)
      foo
   else if (a)
      foo
      bar
   if (a)
      foo
      bar
   if (a)
      foo
      bar
      if (aa)
         foo
         bar
<<< if and while, with parens
object a:
  if (a) then
    foo
  if (a) then
    if (aa) then
      foo
  if (a) then
    foo
    bar
  if (a) then
    foo
    bar
    if (aa) then
      foo
      bar
  while (foo) do
    foo
  while (foo) do
  while (foo) do
    foo
  while (foo) do
    foo
    bar
  while (foo) do
    foo
    bar
    while (foo) do
      foo
      bar
>>>
object a:
   if (a) then
      foo
   if (a) then
      if (aa) then
         foo
   if (a) then
      foo
      bar
   if (a) then
      foo
      bar
      if (aa) then
         foo
         bar
   while (foo) do
      foo
   while (foo) do
      while (foo) do
         foo
   while (foo) do
      foo
      bar
   while (foo) do
      foo
      bar
      while (foo) do
         foo
         bar
<<< nested if-else multiple
object a:
  val a =
    if a then
      if aa then
        aaa
        // c1
      if aa then
        aaa
    else
      if aa then
        aaa
        // c1
      if aa then
        aaa
>>>
object a:
   val a =
     if a then
        if aa then
           aaa
           // c1
        if aa then
           aaa
     else
        if aa then
           aaa
           // c1
        if aa then
           aaa
<<< nested if-else chained
object a:
  val a =
    if a then
      if aa then
        if bb then if cc then ccc
      else
        if bb then
          if cc then ccc
          else ddd
        else eee
    else if aa then aaa else bbb
>>>
object a:
   val a =
     if a then
        if aa then
           if bb then
              if cc then
                 ccc
        else if bb then
           if cc then
              ccc
           else
              ddd
        else
           eee
     else if aa then
        aaa
     else
        bbb
<<< nested if-else single
object a:
  val a =
    if a then
      if aa then
        aaa
        // c1
    else
      if aa then
        aaa
        // c1
>>>
object a:
   val a =
     if a then
        if aa then
           aaa
           // c1
     else if aa then
        aaa
        // c1
<<< #2448
object Foo:
  def bar = process(arg match
    case a: A if a.b =>
      None

    case a: A if a.c() =>
      None

    case a: A if a.c() =>
      None

    case a: A if a.b =>
      Some(someMethod().anotherMethod().fooBarMethod(ObjectWithLongName.method()))

    case a: A if a.c() =>
      val varName = a.method(a.someField.anotherField.method().map(ObjectWithLongName.A))
      val otherVarName = varName.method(a.someField.method(ObjectWithLongName.B))
      otherVarName

    case a: A if a.someField.otherField.function().exists(SomeObjectLongName.isTrue) =>
      None
  )
>>>
object Foo:
   def bar = process(
     arg match
        case a: A if a.b =>
          None

        case a: A if a.c() =>
          None

        case a: A if a.c() =>
          None

        case a: A if a.b =>
          Some(
            someMethod()
              .anotherMethod()
              .fooBarMethod(ObjectWithLongName.method())
          )

        case a: A if a.c() =>
          val varName = a
            .method(a.someField.anotherField.method().map(ObjectWithLongName.A))
          val otherVarName = varName
            .method(a.someField.method(ObjectWithLongName.B))
          otherVarName

        case a: A
            if a
              .someField
              .otherField
              .function()
              .exists(SomeObjectLongName.isTrue) =>
          None
   )
<<< #2425 partial function
val f: String => String =
  case "horses" => "are neat"
  case _ => "cows are sweet"
>>>
val f: String => String =
   case "horses" =>
     "are neat"
   case _ =>
     "cows are sweet"
<<< rewrite with empty blocks
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
object a {
  def a = {
  }
}
>>>
object a:
   def a = {}
<<< rewrite with nested if-else, old syntax
rewrite.scala3.removeOptionalBraces = yes
===
object a {
  val a = {
    if (a) {
      if (aa) {
        aaa
      } // c1
    } else {
      b
    }
  }
}
>>>
object a:
   val a =
     if (a) {
       if (aa) {
         aaa
       } // c1
     } else
       b
<<< rewrite with nested if-else
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
object a {
  val a = {
    if (a) {
      if (aa) {
        aaa
      } // c1
    } else {
      b
    }
  }
}
>>>
object a:
   val a =
     if (a)
        if (aa)
          aaa
        // c1
     else
       b
<<< rewrite with val and if-else
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
object a {
 trait A {
  val cond = {
    if true then {
      stat1
      stat2
    } else {
      stat3
      stat4
    }
    end if
  }
  end cond
 }
}
>>>
object a:
   trait A:
      val cond =
         if true then
            stat1
            stat2
         else
            stat3
            stat4
         end if
      end cond
<<< rewrite with given-with
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
object a {
  given intOrd: Ord[Int] with Eq[Int] with { // c1
    /* c2 */
     def compare(x: Int, y: Int) = {
      if x < y then -1 else if x > y then +1 else 0
     }
     def compare2(x: Int, y: Int) = {
      if x < y then -1 else if x > y then +1 else 0
     }
  }
}
>>>
object a:
   given intOrd: Ord[Int] with Eq[Int] with // c1
      /* c2 */
      def compare(x: Int, y: Int) =
        if x < y then
           -1
        else if x > y then
           +1
        else
           0
      def compare2(x: Int, y: Int) =
        if x < y then
           -1
        else if x > y then
           +1
        else
           0
<<< rewrite with match
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
rewrite.scala3.insertEndMarkerMinLines = 2 # will not apply, we use single-stat blocks
===
enum IndentWidth {
   def foo = { this match {
      case a =>
         that match {
            case b => bb
            case c => cc
         }
         end match
      case b =>
         that match {
            case c => cc
            case _ => dd
          }
    }
  }
   def foo = { this match {
      case a =>
         that match {
            case b => bb
            case c => cc
         }
         end match
      case b =>
         that match {
            case c => cc
            case _ => dd
          }
    }
    end match
  }
  end foo
}
>>>
enum IndentWidth:
   def foo =
     this match
        case a =>
          that match
             case b =>
               bb
             case c =>
               cc
          end match
        case b =>
          that match
             case c =>
               cc
             case _ =>
               dd
   def foo =
      this match
         case a =>
           that match
              case b =>
                bb
              case c =>
                cc
           end match
         case b =>
           that match
              case c =>
                cc
              case _ =>
                dd
      end match
   end foo
<<< rewrite with catch
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
enum IndentWidth {
   def foo = { try { foo }
         catch {
            case a =>
               that match {
                  case b => bb
                  case c => cc
               }
               end match
            case b =>
               that match {
                  case c => cc
                  case _ => dd
                }

         } finally {
           foo
           bar
         }
     }
}
>>>
enum IndentWidth:
   def foo =
     try
        foo
     catch
        case a =>
          that match
             case b =>
               bb
             case c =>
               cc
          end match
        case b =>
          that match
             case c =>
               cc
             case _ =>
               dd

     finally
        foo
        bar
<<< rewrite with catch, format-off
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
enum IndentWidth {
   def foo = { try { foo }
         catch {
            case a =>
               that match {
               // format: off
                  case b => bb
               // format: on
                  case c => cc
               }
               end match
            case b =>
               that match {
                  case c => cc
                  case _ => dd
                }

         } finally {
           foo
           bar
         }
     }
}
>>>
enum IndentWidth {
  def foo = {
    try
       foo
    catch {
      case a =>
        that match {
               // format: off
                  case b => bb
               // format: on
          case c =>
            cc
        }
        end match
      case b =>
        that match
           case c =>
             cc
           case _ =>
             dd

    } finally
       foo
       bar
  }
}
<<< rewrite with catch, config override
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
enum IndentWidth {
   def foo = { try { foo }
         catch {
            case a =>
               that match {
               // scalafmt: { indent { significant = 1 } }
                  case b => bb
                  case c => cc
               }
               end match
            case b =>
               that match {
                  case c => cc
                  case _ => dd
                }

         } finally {
           foo
           bar
         }
     }
}
>>>
enum IndentWidth:
   def foo =
     try
        foo
     catch
        case a =>
          that match
             // scalafmt: { indent { significant = 1 } }
             case b =>
               bb
             case c =>
               cc
          end match
        case b =>
          that match
           case c =>
             cc
           case _ =>
             dd

     finally
      foo
      bar
<<< rewrite with try/finally
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
object a {
  def foo = { try { foo }
    catch {
      case a => baz
    } finally {
      bar
    }
  }
}
>>>
object a:
   def foo =
     try
        foo
     catch
        case a =>
          baz
     finally
        bar
<<< rewrite with end markers: this; with equals, only init
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
class a(vi: Int, vs: String):
  def this() = {

    this(0, "")

  }
  end this
  def this(vi: Int) = {
    this(vi, "")
  }
  end this
>>>
class a(vi: Int, vs: String):
   def this() = this(0, "")

   end this
   def this(vi: Int) = this(vi, "")
   end this
<<< rewrite with end markers: this; with equals, not only init
rewrite.scala3.removeOptionalBraces = oldSyntaxToo
===
class a(vi: Int, vs: String):
  def this() = {
    this(0, "")
    foo
  }
  end this
  def this(vi: Int) = {
    this(vi, "")
    foo
  }
  end this
>>>
class a(vi: Int, vs: String):
   def this() =
      this(0, "")
      foo
   end this
   def this(vi: Int) =
      this(vi, "")
      foo
   end this
<<< rewrite to new syntax with nested if-else
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 6
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
object a {
  val a = {
    if (a) { // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
      if (aa) {  // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
        aaa
      } // c1
    } else {
      b
    }
  }
  val a = {
    if (a) { // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
      if (aa) {  // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
        aaa
      } // c1
    } else {
      b
    }
    if (a) { // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
      if (aa) {  // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
        aaa
      } // c1
    } else {
      b
    }
  }
}
>>>
object a:
   val a =
     if a then // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
        if (aa) { // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
          aaa
        } // c1
     else
        b
   val a =
      if a then // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
         if (aa) { // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
           aaa
         } // c1
      else
         b
      end if
      if a then // scalafmt: { rewrite.scala3.convertToNewSyntax = false }
         if (aa) { // scalafmt: { rewrite.scala3.convertToNewSyntax = true }
           aaa
         } // c1
      else
         b
      end if
   end a
end a
<<< rewrite to new syntax with for-do, single
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 3
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
rewrite.rules = [RedundantParens]
===
object a {
  for (a <- b) yield {
    for {a <- b} yield {
      foo
    }
  }
  while (a > 0) {
    while (a > 0) do {
      foo
    }
  }
  for (a <- b) {
    for (a <- b) do {
      foo
    }
  }
  for {a <- b} {
    for {a <- b} do {
      foo
    }
  }
}
>>>
object a:
   for (a <- b)
     yield for a <- b
     yield foo
   while a > 0 do
      while a > 0 do
         foo
   end while
   for a <- b do
      for a <- b do
         foo
   end for
   for a <- b do
      for a <- b do
         foo
   end for
end a
<<< rewrite to new syntax with for-do, multiple
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 6
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
rewrite.rules = [RedundantParens]
===
object a {
  for (a <- b; c <- d) yield {
    for {a <- b; c <- d} yield {
      foo
      bar
    }
    for {a <- b; c <- d} yield {
      foo
      bar
    }
  }
  while (a > 0) {
    while (a > 0) do {
      foo
      bar
    }
    while (a > 0) do {
      foo
      bar
    }
  }
  for (a <- b; c <- d) {
    for (a <- b; c <- d) do {
      foo
      bar
    }
    for (a <- b; c <- d) do {
      foo
      bar
    }
  }
  for {a <- b; c <- d} {
    for {a <- b; c <- d} do {
      foo
      bar
    }
    for {a <- b; c <- d} do {
      foo
      bar
    }
  }
}
>>>
object a:
   for (
     a <- b;
     c <- d
   )
     yield
        for
           a <- b;
           c <- d
        yield
           foo
           bar
        end for
        for
           a <- b;
           c <- d
        yield
           foo
           bar
        end for
   end for
   while a > 0 do
      while a > 0 do
         foo
         bar
      while a > 0 do
         foo
         bar
   end while
   for
      a <- b;
      c <- d
   do
      for
         a <- b;
         c <- d
      do
         foo
         bar
      end for
      for
         a <- b;
         c <- d
      do
         foo
         bar
      end for
   end for
   for
      a <- b;
      c <- d
   do
      for
         a <- b;
         c <- d
      do
         foo
         bar
      end for
      for
         a <- b;
         c <- d
      do
         foo
         bar
      end for
   end for
end a
<<< rewrite to new syntax, imports
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
object a:
 import A.{min => minimum, `*` => multiply}
 import Predef.{augmentString => _, _}
 import scala.{annotation => ann}
 import java as j
 import Predef.{augmentString => _}
>>>
object a:
   import A.{min as minimum, `*` as multiply}
   import Predef.{augmentString as _, *}
   import scala.{annotation as ann}
   import java as j
   import Predef.{augmentString as _}
<<< rewrite to new syntax, imports, scala2-source3
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
runner.dialect = scala213source3
===
object a {
 import A.{min => minimum, `*` => multiply}
 import Predef.{augmentString => _, _}
 import scala.{annotation => ann}
 import java as j
 import Predef.{augmentString => _}
}
>>>
object a {
  import A.{min as minimum, `*` as multiply}
  import Predef.{augmentString as _, *}
  import scala.{annotation as ann}
  import java as j
  import Predef.{augmentString as _}
}
<<< rewrite to new syntax, wildcard
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
object a:
  def foo(a: Foo[_]): Unit = ???
>>>
object a:
   def foo(a: Foo[?]): Unit = ???
<<< rewrite to new syntax, wildcard, scala2-source3
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
runner.dialect = scala213source3
===
object a {
  def foo(a: Foo[_]): Unit = ???
}
>>>
object a {
  def foo(a: Foo[?]): Unit = ???
}
<<< rewrite to new syntax, vararg splices, call
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
def foo: Unit =
  foo(a: _*)
>>>
def foo: Unit = foo(a*)
<<< rewrite to new syntax, vararg splices, call, scala2-source3
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
runner.dialect = scala213source3
===
def foo: Unit =
  foo(a: _*)
>>>
def foo: Unit = foo(a*)
<<< rewrite to new syntax, vararg splices, pat bind
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
object a:
  lst match
    case List(0, 1, xs @ _*) => foo
>>>
object a:
   lst match
      case List(0, 1, xs*) =>
        foo
<<< rewrite to new syntax, vararg splices, pat bind, scala2-source3
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
runner.dialect = scala213source3
===
object a {
  lst match {
    case List(0, 1, xs @ _*) => foo
  }
}
>>>
object a {
  lst match {
    case List(0, 1, xs*) =>
      foo
  }
}
<<< if break before then if multiline cond
maxColumn = 12
===
object a:
  if a &&
     b &&
     c then
      foo
>>>
object a:
   if a &&
      b && c
   then
      foo
<<< while break before do if multiline cond
maxColumn = 12
===
object a:
  while a &&
     b &&
     c do
      foo
>>>
object a:
   while a &&
      b && c
   do
      foo
<<< if break before then if multiline cond, !dangle
maxColumn = 15
indent.callSite = 4
indent.ctrlSite = 6
danglingParentheses.ctrlSite = false
===
object a:
  if a &&
     bb &&
     c then
      foo
>>>
object a:
   if a &&
         bb &&
         c then
      foo
<<< while break before do if multiline cond, !dangle
maxColumn = 13
indent.callSite = 4
indent.ctrlSite = 6
danglingParentheses.ctrlSite = false
===
object a:
  while a &&
     b &&
     c do
      foo
>>>
object a:
   while a &&
         b &&
         c do
      foo
<<< #2495 1
rewrite.scala3.removeOptionalBraces = yes
===
val a = List(Some(1), None, Some(3), Some(4)).map({
  case Some(x) => x match {
    case 1 => "one"
    case _ => "more than one"
  }
  case _ => "none"
})
>>>
val a = List(Some(1), None, Some(3), Some(4)).map({
  case Some(x) =>
    x match
       case 1 =>
         "one"
       case _ =>
         "more than one"
  case _ =>
    "none"
})
<<< #2495 2
rewrite.scala3.removeOptionalBraces = yes
===
val bar =
  foo({
    val arr = new Array[String](10)
    var x = 0
    while x < 10 do {
      arr(x) = "x"
      x += 1
    }
    arr
  })
>>>
val bar = foo({
  val arr = new Array[String](10)
  var x = 0
  while x < 10 do
     arr(x) = "x"
     x += 1
  arr
})
<<< new optional braces
rewrite.scala3.removeOptionalBraces = yes
===
val request: Request = Request(
  "./api/notes",
  new {
    method = HttpMethod.POST
  }
)
>>>
val request: Request = Request(
  "./api/notes",
  new:
     method = HttpMethod.POST
)
<<< lambda
rewrite.scala3.removeOptionalBraces = yes
===
val f: Int => Int = (x: Int) => {
  x * x
}
>>>
val f: Int => Int = (x: Int) => x * x
<<< lambda multiple statements
rewrite.scala3.removeOptionalBraces = yes
===
val f: Int => Int = (x: Int) => {
  val y = x * x
  y
}
>>>
val f: Int => Int =
  (x: Int) =>
     val y = x * x
     y
<<< 2 end markers at end of file
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 2
===
object a:
  class a:
    val a =
      a
>>>
object a:
   class a:
      val a = a
   end a
end a
<<< 2 end markers at end of file, comment
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 2
===
object a:
  class b:
    val c =
      d
  // c
end a
>>>
object a:
   class b:
      val c = d
   end b
   // c
end a
<<< 1 end marker at end of file
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 3
===
object a:
  class b:
    val c =
      d
>>>
object a:
   class b:
      val c = d
end a
<<< 1 end marker at end of file, comment
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 3
===
object a:
  class b:
    val c =
      d
  // c
end a
>>>
object a:
   class b:
      val c = d
   // c
end a
<<< no end markers at end of file
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 4
===
object a:
  class a:
    val a =
      a
>>>
object a:
   class a:
      val a = a
<<< ml=2 remove 0 end markers
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 2
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a
>>>
object a:
   class b:
      val c = d
      end c
   end b
end a
<<< ml=3 remove 1 end marker
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 3
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a
>>>
object a:
   class b:
      val c = d
      end c
end a
<<< ml=4 remove 2 end markers
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 4
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a
>>>
object a:
   class b:
      val c = d
      end c
<<< ml=4 remove 0 end markers, comment 1
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 4
===
object a:
  class b:
    val c =
      d
    end c
  end b // comment
end a
>>>
object a:
   class b:
      val c = d
      end c
   end b // comment
end a
<<< ml=5 remove 1 end marker, comment 1
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 5
===
object a:
  class b:
    val c =
      d
    end c
  end b // comment
end a
>>>
object a:
   class b:
      val c = d
      end c
   end b // comment
<<< ml=10 remove 1 end marker, comment 1
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 10
===
object a:
  class b:
    val c =
      d
    end c
  end b // comment
end a
>>>
object a:
   class b:
      val c = d
      end c
   end b // comment
<<< ml=2 remove 0 end markers, comment 2
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 2
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a // comment
>>>
object a:
   class b:
      val c = d
      end c
   end b
end a // comment
<<< ml=3 remove 1 end marker, comment 2
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 3
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a // comment
>>>
object a:
   class b:
      val c = d
      end c
end a // comment
<<< ml=10 remove 1 end marker, comment 2
runner.parser = source
rewrite.scala3.removeEndMarkerMaxLines = 10
===
object a:
  class b:
    val c =
      d
    end c
  end b
end a // comment
>>>
object a:
   class b:
      val c = d
      end c
end a // comment
<<< package colonEol
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 4
===
package a.b.c:
  object a:
    println("ah")
    println("ha")
>>>
package a.b.c:
   object a:
      println("ah")
      println("ha")
end c
<<< two consecutive defs #2559
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 2
===
def f(s: String) =
  val t = "Bar"
  val u = "Baz"
  s"$t $u $s"

/** Some doc comment */
def g = f("Foo")
>>>
def f(s: String) =
   val t = "Bar"
   val u = "Baz"
   s"$t $u $s"
end f

/** Some doc comment */
def g = f("Foo")
<<< two consecutive defs #2559, trailing comment in block
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 2
===
def f(s: String) =
  val t = "Bar"
  val u = "Baz"
  s"$t $u $s"
  // final comment

/** Some doc comment */
def g = f("Foo")
>>>
def f(s: String) =
   val t = "Bar"
   val u = "Baz"
   s"$t $u $s"
   // final comment
end f

/** Some doc comment */
def g = f("Foo")
<<< #2561 no forced dangle in tuples
newlines {
  beforeOpenParenDefnSite = source
  beforeOpenParenCallSite = source
}
===
val (length, width) =
   if s % 5 == 0 then
      (hourMarkLength, hourMarkWidth)
   else
      (secondMarkLength, secondMarkWidth)
>>>
val (length, width) =
  if s % 5 == 0 then
     (hourMarkLength, hourMarkWidth)
  else
     (secondMarkLength, secondMarkWidth)
<<< if indentation
if // comm
    val cond1 = true
    (a1 && a2) == cond1
  then
    val exitCode = 1
    exitCode
    
>>>
if // comm
   val cond1 = true
   (a1 && a2) == cond1
then
   val exitCode = 1
   exitCode
<<< if indentation long
runner.parser = source
maxColumn = 35
rewrite.scala3.insertEndMarkerMinLines = 1
rewrite.scala3.convertToNewSyntax = true
rewrite.scala3.removeOptionalBraces = yes
===
object O {
  if {// comm
    def bye = "bye"
    def hello = { val greet = "This is a long string hello!  "; greet }
    (hello + bye).length > 10
  } then
    val greet = "Too many words!"
    println(greet)
}
>>>
object O:
   if // comm
      def bye = "bye"
      def hello =
         val greet =
           "This is a long string hello!  ";
         greet
      end hello
      (hello + bye).length > 10
   then
      val greet = "Too many words!"
      println(greet)
   end if
end O
<<< if indentation danglingParentheses false
danglingParentheses.ctrlSite = false
===
if // comm
    val cond1 = true
    (a1 && a2) == cond1
  then
    val exitCode = 1
    exitCode
    
>>>
if // comm
   val cond1 = true
   (a1 && a2) == cond1 then
   val exitCode = 1
   exitCode
<<< if indentation danglingParentheses false oneline
danglingParentheses.ctrlSite = false
===
if
    (a1 && a2) == cond1
  then
    val exitCode = 1
    exitCode
    
>>>
if (a1 && a2) == cond1 then
   val exitCode = 1
   exitCode
<<< while indentation danglingParentheses false
danglingParentheses.ctrlSite = false
===
while // comm
    val cond1 = true
    (a1 && a2) == cond1
  do
    val exitCode = 1
    exitCode
    
>>>
while // comm
   val cond1 = true
   (a1 && a2) == cond1 do
   val exitCode = 1
   exitCode
<<< if indentation danglingParentheses false oneline
danglingParentheses.ctrlSite = false
===
while
    (a1 && a2) == cond1
  do
    val exitCode = 1
    exitCode
    
>>>
while (a1 && a2) == cond1 do
   val exitCode = 1
   exitCode
<<< if redundant parens
rewrite.rules = [RedundantParens]
===
if (a > 1) then
  println("Hello!")
>>>
if a > 1 then
   println("Hello!")
<<< #2634
rewrite.scala3.insertEndMarkerMinLines = 2
===
object a:
  given Foo[String] with
    def foo(s: String) =
      true
>>>
object a:
   given Foo[String] with
      def foo(s: String) = true
   end given
<<< #2687 preserve break for partial function
maxColumn = 100
===
given liftPropertyAlias: NiceLiftable[PropertyAlias] with {
  def lift =
    case PropertyAlias(a, b) => '{ PropertyAlias(${ a.expr }, ${ b.expr }) }
}
>>>
given liftPropertyAlias: NiceLiftable[PropertyAlias] with {
  def lift =
     case PropertyAlias(a, b) =>
       '{
         PropertyAlias(
           ${
             a.expr
           },
           ${
             b.expr
           }
         )
       }
}
<<< #2725 newline after extension parameter
extension (a: All) 
  def getAll: Boolean = a
>>>
extension (a: All)
  def getAll: Boolean = a
<<< #2725 newline after extension parameter short
extension (a: All) def getAll: Boolean = a
>>>
extension (a: All)
  def getAll: Boolean = a
<<< #2725 newline after extension parameter long
maxColumn = 40
===
extension (a: All) def getAll: Boolean = a
>>>
extension (a: All)
  def getAll: Boolean = a
<<< #2740
runner.parser = source
rewrite.scala3.insertEndMarkerMinLines = 1
===
object `Accept-Ranges`:
  val r = ""
>>>
object `Accept-Ranges`:
   val r = ""
end `Accept-Ranges`
<<< #2781
rewrite.scala3.removeOptionalBraces = yes
===
object x:
  val y = List(1).map(v => {
    println(v)
    v + 1
  })
>>>
object x:
   val y = List(1).map(v =>
      println(v)
      v + 1
   )
<<< 2786 insert def
runner.parser = source
rewrite.scala3.countEndMarkerLines = lastBlockOnly
rewrite.scala3.insertEndMarkerMinLines = 3
===
def foo(
    a1: Int,
    a2: Int
): Int =
  println()
  42

def foo(
    a1: Int,
    a2: Int
): Int =
  println()
  42
  43
>>>
def foo(a1: Int, a2: Int): Int =
   println()
   42

def foo(a1: Int, a2: Int): Int =
   println()
   42
   43
end foo
<<< 2786 insert else
runner.parser = source
rewrite.scala3.countEndMarkerLines = lastBlockOnly
rewrite.scala3.insertEndMarkerMinLines = 3
===
def foo2: Int =
  fx()
  if true then
    println()
    println()
    println()
    println()
    println()
    println()
    println()
    32
  else // c
    42
    43
end foo2

def foo2: Int =
  fx()
  if true then
    println()
    println()
    println()
    println()
    println()
    println()
    println()
    32
  else
    42
    43
    44
end foo2
>>>
def foo2: Int =
   fx()
   if true then
      println()
      println()
      println()
      println()
      println()
      println()
      println()
      32
   else // c
      42
      43
end foo2

def foo2: Int =
   fx()
   if true then
      println()
      println()
      println()
      println()
      println()
      println()
      println()
      32
   else
      42
      43
      44
   end if
end foo2
<<< 2786 remove def
runner.parser = source
rewrite.scala3.countEndMarkerLines = lastBlockOnly
rewrite.scala3.removeEndMarkerMaxLines = 2
===
def foo(
    a1: Int,
    a2: Int
): Int =
  println()
  42
end foo

def foo(
    a1: Int,
    a2: Int
): Int =
  println()
  42
  43
end foo
>>>
def foo(a1: Int, a2: Int): Int =
   println()
   42

def foo(a1: Int, a2: Int): Int =
   println()
   42
   43
end foo
<<< 2786 remove else
runner.parser = source
rewrite.scala3.countEndMarkerLines = lastBlockOnly
rewrite.scala3.removeEndMarkerMaxLines = 2
===
def foo2: Int =
  fx()
  if true then
    println()
    println()
    println()
    println()
    println()
    println()
    println()
    32
  else // c
    42
    43
  end if
end foo2

def foo2: Int =
  fx()
  if true then
    println()
    println()
    println()
    println()
    println()
    println()
    println()
    32
  else
    42
    43
    44
  end if
end foo2
>>>
def foo2: Int =
   fx()
   if true then
      println()
      println()
      println()
      println()
      println()
      println()
      println()
      32
   else // c
      42
      43
end foo2

def foo2: Int =
   fx()
   if true then
      println()
      println()
      println()
      println()
      println()
      println()
      println()
      32
   else
      42
      43
      44
   end if
end foo2
<<< 2790 for loops indentation
def update(tpf: Float): Unit =
  for (scene <- scenes.all) 
    scene.updateLogicalState(tpf)
    scene.updateGeometricState()
  for (scene <- scenes.all) 
    scene.updateLogicalState(tpf)
>>>
def update(tpf: Float): Unit =
   for (scene <- scenes.all)
      scene.updateLogicalState(tpf)
      scene.updateGeometricState()
   for (scene <- scenes.all)
     scene.updateLogicalState(tpf)
<<< 2790 while loops indentation
def update(tpf: Float): Unit =
  while (true) 
    scene.updateLogicalState(tpf)
    scene.updateGeometricState()
  while (true) 
    scene.updateLogicalState(tpf)
>>>
def update(tpf: Float): Unit =
   while (true)
      scene.updateLogicalState(tpf)
      scene.updateGeometricState()
   while (true)
     scene.updateLogicalState(tpf)
<<< 2790 for loops indentation end marker
maxColumn = 60
rewrite.scala3.insertEndMarkerMinLines = 1
===
def update(tpf: Float): Unit =
  for (scene <- scenes.all) 
    scene.updateLogicalState(tpf)
    scene.updateGeometricState()
  for (scene <- scenes.all) 
    scene.updateLogicalState(tpf)
  for (scene <- scenes.all)
    for (scene <- scenes.all)
      scene.updateLogicalState(tpf)
  for (scene <- scenes.all) scene.updateLogicalState(
    tpf,
    scene.updateLogicalState(tpf)
  )
>>>
def update(tpf: Float): Unit =
   for (scene <- scenes.all)
      scene.updateLogicalState(tpf)
      scene.updateGeometricState()
   end for
   for (scene <- scenes.all)
     scene.updateLogicalState(tpf)
   end for
   for (scene <- scenes.all)
     for (scene <- scenes.all)
       scene.updateLogicalState(tpf)
   end for
   for (scene <- scenes.all)
     scene.updateLogicalState(
       tpf,
       scene.updateLogicalState(tpf)
     )
   end for
<<< 2790 while loops indentation end marker
rewrite.scala3.insertEndMarkerMinLines = 1
===
def update(tpf: Float): Unit =
  while (true) 
    scene.updateLogicalState(tpf)
    scene.updateGeometricState()
  while (true)
    scene.updateLogicalState(tpf)
  while (true)
    while (true)
      scene.updateLogicalState(tpf)
  while (true) scene.updateLogicalState(
    tpf,
    scene.updateLogicalState(tpf)
  )
>>>
def update(tpf: Float): Unit =
   while (true)
      scene.updateLogicalState(tpf)
      scene.updateGeometricState()
   end while
   while (true)
     scene.updateLogicalState(tpf)
   end while
   while (true)
     while (true)
       scene.updateLogicalState(tpf)
   end while
   while (true)
     scene.updateLogicalState(tpf, scene.updateLogicalState(tpf))
   end while
<<< TryWithHandler: newline after catch
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch bar
    finally a
}
<<< TryWithHandler: newline after catch, short
maxColumn = 12
===
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, space comment
object a {
  def foo = try
    a
  catch /* c1 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, break comment
object a {
  def foo = try
    a
  catch
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch
      /* c2 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */
      /* c2 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */ bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */ bar
    finally a
}
<<< #2019 infix
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  def foo =
    a +
    b
  val foo =
    a +
    b
  var foo =
    a +
    b
}
>>>
object a {
  def foo = {
    a +
      b
  }
  val foo = {
    a +
      b
  }
  var foo = {
    a +
      b
  }
}
<<< #2019 if-else !alwaysBeforeElseAfterCurlyIf
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = {
    if (a) {
      a +
        b
    } else {
      a +
        b
    }
  }
  val foo = {
    if (a) {
      a +
        b
    } else if (b) {
      a +
        b
    } else if (c) {
      a +
        b
    }
  }
  var foo = {
    if (a) {
      a +
        b
    } else {
      a +
        b
    }
  }
}
<<< #2019 if-else alwaysBeforeElseAfterCurlyIf
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = {
    if (a) {
      a +
        b
    }
    else {
      a +
        b
    }
  }
  val foo = {
    if (a) {
      a +
        b
    }
    else if (b) {
      a +
        b
    }
    else if (c) {
      a +
        b
    }
  }
  var foo = {
    if (a) {
      a +
        b
    }
    else {
      a +
        b
    }
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch
      bar
    finally
      a
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch {
      bar
    } finally {
      a
    }
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch
      bar
    finally
      a
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.afterInfix = keep
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch {
      bar
    }
    finally {
      a
    }
  }
}
<<< #2019 function
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  foo(x =>
    a +
      b
  )
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
>>>
object a {
  foo(x => {
    a +
      b
  })
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
<<< #2019 partial function
maxColumn = 25
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
>>>
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
<<< #2019 for-yield !allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-yield allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield { // c
    a
  }
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-do !allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
}
<<< #2019 for-do allBlocks
maxColumn = 12
newlines.afterInfix = keep
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } { // c
    a
  }
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
}
<<< #3005 if
object a {
  if ({ !Yield(2); false }) {
    !Yield(3)
  } else {
    !Yield(4)
  }
}
>>>
object a {
  if ({
    !Yield(2);
    false
  }) {
    !Yield(3)
  } else {
    !Yield(4)
  }
}
<<< #3005 if-then
object a {
  if
    ({ !Yield(2); false }) then {
    !Yield(3)
  } else {
    !Yield(4)
  }
}
>>>
object a {
  if ({
    !Yield(2);
    false
  }) then {
    !Yield(3)
  } else {
    !Yield(4)
  }
}
<<< #3005 while
object a {
  while ({ !Yield(2); false }) {
    !Yield(3)
  }
}
>>>
object a {
  while ({
    !Yield(2);
    false
  }) {
    !Yield(3)
  }
}
<<< #3005 while-do
object a {
  while
    ({ !Yield(2); false }) do {
    !Yield(3)
  }
}
>>>
object a {
  while ({
    !Yield(2);
    false
  }) do {
    !Yield(3)
  }
}
<<< #3033 if-then danglingParentheses
danglingParentheses.ctrlSite = true
===
class C:
  if true
  then 3
  else 4
  if true
  then
    3
  else 4
  if
    true
  then
    3
  else 4
>>>
class C:
   if true then
      3
   else
      4
   if true then
      3
   else
      4
   if true then
      3
   else
      4
<<< #3033 if-then !danglingParentheses
danglingParentheses.ctrlSite = false
===
class C:
  if true
  then 3
  else 4
  if true
  then
    3
  else 4
  if
    true
  then
    3
  else 4
>>>
class C:
   if true then
      3
   else
      4
   if true then
      3
   else
      4
   if true then
      3
   else
      4
<<< #3034 for-yield danglingParentheses
danglingParentheses.ctrlSite = true
===
object a:
  for x <- range
  yield matrix(x)(0) += matrix(x - 1)(0)
  for x <- range
  yield
    matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   for x <- range
   yield matrix(x)(0) += matrix(x - 1)(0)
   for x <- range
   yield matrix(x)(0) += matrix(x - 1)(0)
<<< #3034 for-yield !danglingParentheses
danglingParentheses.ctrlSite = false
===
object a:
  for x <- range
  yield matrix(x)(0) += matrix(x - 1)(0)
  for x <- range
  yield
    matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   for x <- range
   yield matrix(x)(0) += matrix(x - 1)(0)
   for x <- range
   yield matrix(x)(0) += matrix(x - 1)(0)
<<< #3034 for-do danglingParentheses
danglingParentheses.ctrlSite = true
===
object a:
  for x <- range
  do matrix(x)(0) += matrix(x - 1)(0)
  for x <- range do
    matrix(x)(0) += matrix(x - 1)(0)
  for x <- range
  do
   matrix(x)(0) += matrix(x - 1)(0)
  for
   x <- range
  do
   matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
<<< #3034 for-do !danglingParentheses
danglingParentheses.ctrlSite = false
===
object a:
  for x <- range
  do matrix(x)(0) += matrix(x - 1)(0)
  for x <- range do
    matrix(x)(0) += matrix(x - 1)(0)
  for x <- range
  do
   matrix(x)(0) += matrix(x - 1)(0)
  for
   x <- range
  do
   matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
   for x <- range do
      matrix(x)(0) += matrix(x - 1)(0)
<<< #3034 while-do danglingParentheses
danglingParentheses.ctrlSite = true
===
object a:
  while x < range
  do matrix(x)(0) += matrix(x - 1)(0)
  while x < range do
    matrix(x)(0) += matrix(x - 1)(0)
  while
    x < range
  do matrix(x)(0) += matrix(x - 1)(0)
  while x < range
  do
    matrix(x)(0) += matrix(x - 1)(0)
  while
    x < range
  do
    matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
<<< #3034 while-do !danglingParentheses
danglingParentheses.ctrlSite = false
===
object a:
  while x < range
  do matrix(x)(0) += matrix(x - 1)(0)
  while x < range do
    matrix(x)(0) += matrix(x - 1)(0)
  while
    x < range
  do matrix(x)(0) += matrix(x - 1)(0)
  while x < range
  do
    matrix(x)(0) += matrix(x - 1)(0)
  while
    x < range
  do
    matrix(x)(0) += matrix(x - 1)(0)
>>>
object a:
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
   while x < range do
      matrix(x)(0) += matrix(x - 1)(0)
<<< align.beforeOpenParenCallSite
maxColumn = 30
align.closeParenSite = true
align.beforeOpenParenCallSite = true
newlines.beforeOpenParenCallSite = source
===
allMatching(versionString)
                 (partialFunctions)
>>>
allMatching
   (versionString)
   (partialFunctions)
<<< align.beforeOpenParenCallSite + align.openParenCallSite
maxColumn = 30
align.closeParenSite = true
align.openParenCallSite = true
align.beforeOpenParenCallSite = true
newlines.beforeOpenParenCallSite = source
===
allMatching(versionString, partialFunctions)
                 (partialFunctions)
>>>
allMatching
   (versionString,
    partialFunctions
   )
   (partialFunctions)
<<< #3056
enum SerializedField extends jl.Enum[SerializedField] {
  case UNKNOWN,         // represents a field code we didn't recognize
    END_MARKER,         // end of a list of fields
    ROOT_VALUE,         // Fields at the root
    ROOT_WAS_CONFIG,
    VALUE_DATA,         // Fields that make up a value
    VALUE_ORIGIN,
    ORIGIN_DESCRIPTION, // Fields that make up an origin
    ORIGIN_LINE_NUMBER,
    ORIGIN_END_LINE_NUMBER, ORIGIN_TYPE, ORIGIN_URL,
    ORIGIN_COMMENTS, ORIGIN_NULL_URL, ORIGIN_NULL_COMMENTS, ORIGIN_RESOURCE, ORIGIN_NULL_RESOURCE
}
>>>
enum SerializedField extends jl.Enum[SerializedField] {
  case UNKNOWN, // represents a field code we didn't recognize
    END_MARKER, // end of a list of fields
    ROOT_VALUE, // Fields at the root
    ROOT_WAS_CONFIG,
    VALUE_DATA, // Fields that make up a value
    VALUE_ORIGIN,
    ORIGIN_DESCRIPTION, // Fields that make up an origin
    ORIGIN_LINE_NUMBER,
    ORIGIN_END_LINE_NUMBER,
    ORIGIN_TYPE,
    ORIGIN_URL,
    ORIGIN_COMMENTS,
    ORIGIN_NULL_URL,
    ORIGIN_NULL_COMMENTS,
    ORIGIN_RESOURCE,
    ORIGIN_NULL_RESOURCE
}
<<< #3158
for { foobar <- LongClassName(database).longMethodName() } yield doSomething(foobar)
>>>
for {
  foobar <- LongClassName(database).longMethodName()
} yield doSomething(foobar)
<<< #3153
maxColumn = 14
indentOperator.excludeRegex = "^(&|\\||&&|\\|\\|)$"
indentOperator.exemptScope = aloneArgOrBody
===
type T =
  Byte |
  Short |
  Int |
  Long |
  Double
>>>
type T =
  Byte |
  Short |
  Int | Long |
  Double
<<< #3188
maxColumn = 60
===
object a {
  implicit def generate[T](value: T): Clue[T] =
    macro MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
  implicit def generate[T](
    value: T
  ): Clue[T] = macro MacroCompatScala2.clueImpl
  implicit def generate[T](value: T)
    : Clue[T] = macro MacroCompatScala2.clueImpl
}
>>>
object a {
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
  implicit def generate[T](value: T): Clue[T] = macro
    MacroCompatScala2.clueImpl
}
<<< #3204 if
object a:
  if
    val x = 4
    4 == 3
  then 5
  else 4
>>>
object a:
   if
      val x = 4
      4 == 3
   then
      5
   else
      4
<<< #3204 while
object a:
  while
    val x = 4
    4 == 3
  do 5
>>>
object a:
   while
      val x = 4
      4 == 3
   do
      5
<<< #3276
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
<<< #3276 2
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
      {c; a + b}.foo
    else
      false
}
>>>
class Foo() {
  def notOK: Boolean =
    if (1 == 1) {
      c;
      a + b
    }.foo
    else
      false
}
<<< #3276 3
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
      {a + b}.foo
      c
    else
      false
}
>>>
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
       {
         a + b
       }.foo
       c
    else
       false
}
<<< #3276 4
class Foo() {
  def notOK: Boolean =
    try {c; a + b}.foo
    finally {c; a + b}.foo
}
>>>
class Foo() {
  def notOK: Boolean =
    try
      {
        c;
        a + b
      }.foo
    finally
      {
        c;
        a + b
      }.foo
}
<<< #3295 1
maxColumn = 40
===
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
<<< #3302
rewrite.scala3.convertToNewSyntax = yes
===
type Inner[A] = A match
  case Seq[x] => x
  case _ => A
>>>
type Inner[A] =
  A match
     case Seq[x] =>
       x
     case _ =>
       A
<<< #3327 match
indent.relativeToLhsLastLine = [match]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption match
          case Some(Row(value: Long)) => value
          case _                      => 0
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] = IO.delay {
    ds // c1
      .headOption match
         case Some(Row(value: Long)) =>
           value
         case _ =>
           0
  }
}
<<< #3337
rewrite.scala3.convertToNewSyntax = yes
===
object a {
  val a = test("" +: Seq("").map{_ + ""}: _*)
  val a = test(("" +: Seq("").map{_ + ""}): _*)
}
>>>
object a {
  val a = test(
    "" +:
      Seq("").map {
        _ + ""
      }: _*
  )
  val a = test(
    (
      "" +:
        Seq("").map {
          _ + ""
        }
    )*
  )
}
<<< coloneol in fewer braces 1
maxColumn = 80
===
object a:
  def f(): Unit =
    List(1, 2, 3).foldLeft(1):
      case (a, b) => a + b
>>>
object a:
   def f(): Unit =
     List(1, 2, 3).foldLeft(1):
        case (a, b) =>
          a + b
<<< coloneol in fewer braces 1, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  def f(): Unit =
    List(1, 2, 3).foldLeft(1):
          case (a, b) => a + b
>>>
object a:
   def f(): Unit =
       List(1, 2, 3).foldLeft(1):
          case (a, b) =>
              a + b
<<< coloneol in fewer braces 2
maxColumn = 80
===
object a:
  def f(): Unit =
    List(1, 2, 3).foo: a =>
      a + 2
    .foo: a =>
      2 + a
    .apply:
      12 + 3
>>>
object a:
   def f(): Unit = List(1, 2, 3)
     .foo: a =>
        a + 2
     .foo: a =>
        2 + a
     .apply:
        12 + 3
<<< coloneol in fewer braces 2, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  def f(): Unit =
    List(1, 2, 3).foo: a =>
      a + 2
    .foo: a =>
      2 + a
    .apply:
      12 + 3
>>>
object a:
   def f(): Unit = List(1, 2, 3)
       .foo: a =>
          a + 2
       .foo: a =>
          2 + a
       .apply:
          12 + 3
<<< coloneol in fewer braces 3
maxColumn = 80
===
object a:
  def f(): Unit =
    List(1, 2, 3).foo:
       case a : Int =>
       case _ =>
    otherTerm()
>>>
object a:
   def f(): Unit =
      List(1, 2, 3).foo:
         case a: Int =>
         case _      =>
      otherTerm()
<<< coloneol in fewer braces 3, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  def f(): Unit =
    List(1, 2, 3).foo:
       case a : Int =>
       case _ =>
    otherTerm()
>>>
object a:
   def f(): Unit =
      List(1, 2, 3).foo:
         case a: Int =>
         case _      =>
      otherTerm()
<<< match with eol
maxColumn = 80
===
object a:
  def f(): Unit =
    List(1, 2, 3).match
      case _ => a + 2
    .foo: a =>
      2 + a
    .apply:
      12 + 3
>>>
object a:
   def f(): Unit =
     List(1, 2, 3)
       .match
          case _ =>
            a + 2
       .foo: a =>
          2 + a
       .apply:
          12 + 3
<<< match with eol, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  def f(): Unit =
    List(1, 2, 3).match
      case _ => a + 2
    .foo: a =>
      2 + a
    .apply:
      12 + 3
>>>
object a:
   def f(): Unit =
       List(1, 2, 3)
           .match
              case _ =>
                  a + 2
           .foo: a =>
              2 + a
           .apply:
              12 + 3
<<< coloneol in refined types
maxColumn = 80
===
object a:
  type T = String:
    type U = Int
>>>
object a:
   type T =
     String:
        type U = Int
<<< coloneol in refined types, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  type T = String:
    type U = Int
>>>
object a:
   type T =
       String:
          type U = Int
<<< with in refined types
maxColumn = 80
===
object a:
  type T = String with
    type U = Int
>>>
object a:
   type T =
     String with
        type U = Int
<<< with in refined types, main > sig
maxColumn = 80
indent.main = 4
===
object a:
  type T = String with
    type U = Int
>>>
object a:
   type T =
       String with
          type U = Int
<<< #3448 1
def test(): String =
  Block:
    2 + 2
  .toString
>>>
def test(): String =
  Block:
     2 + 2
  .toString
<<< #3448 2
indent.significant = 1
===
def test(): String =
  Block:
    2 + 2
  .toString
>>>
def test(): String =
  Block:
   2 + 2
  .toString
<<< #3448 3
indent.significant = 1
===
def test(): String =
  foo.bar:
   2 + 2
  .baz.qux:
   3 + 3
>>>
def test(): String = foo
  .bar:
   2 + 2
  .baz
  .qux:
   3 + 3
<<< #3448 4
indent.significant = 1
===
def test(): String =
  bar:
    2 + 2
  .baz.qux:
    3 + 3
>>>
def test(): String = bar:
 2 + 2
.baz
  .qux:
   3 + 3
<<< #3448 5
indent.significant = 1
===
class test:
  bar:
    2 + 2
  .baz.qux:
    3 + 3
>>>
class test:
 bar:
  2 + 2
 .baz
   .qux:
    3 + 3
<<< #3489 1
class test:
  bar:
    2 + 2
>>>
class test:
   bar:
      2 + 2
<<< #3489 2
class test:
  baz.qux:
    2 + 2
>>>
class test:
   baz.qux:
      2 + 2
<<< #3489 3
class test:
  foo.bar:
    2 + 2
  .baz
  .qux
>>>
class test:
   foo
     .bar:
        2 + 2
     .baz
     .qux
<<< #3489 4
class test:
  bar:
     2 + 2
    .baz
  .qux
>>>
class test:
   bar:
      2 + 2
   .baz
     .qux
<<< #3489 5
class test:
  bar:
     2 + 2
    .baz:
       3 + 3
>>>
class test:
   bar:
      2 + 2
   .baz:
      3 + 3
<<< #3489 6
class test:
  bar:
     2 + 2
    .baz
    .qux:
       3 + 3
>>>
class test:
   bar:
      2 + 2
   .baz
     .qux:
        3 + 3
<<< #3489 7
class test:
  bar (
     2 + 2
     )
    .baz.qux:
       3 + 3
>>>
class test:
   bar(2 + 2)
     .baz
     .qux:
        3 + 3
<<< #3489 8
class test:
  bar.baz:
     2 + 2
    .qux:
       3 + 3
>>>
class test:
   bar
     .baz:
        2 + 2
     .qux:
        3 + 3
<<< #3489 9
class test:
  foo.match
     case bar => ""
     case baz => ""
>>>
class test:
   foo.match
      case bar =>
        ""
      case baz =>
        ""
<<< #3489 10
class test:
  foo.match
     case bar => ""
     case baz => ""
  .qux
>>>
class test:
   foo
     .match
        case bar =>
          ""
        case baz =>
          ""
     .qux
<<< #3489 11
class test:
  foo.match
     case bar => ""
     case baz => ""
  .qux:
       3 + 3
>>>
class test:
   foo
     .match
        case bar =>
          ""
        case baz =>
          ""
     .qux:
        3 + 3
<<< overflowing type
object types:
  type GOutputStreamClass = CStruct21[GObjectClass, CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], gsize, Ptr[GCancellable], Ptr[Ptr[GError]], gssize], CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[GError]], gssize], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[GError]], gboolean], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[GError]], gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gssize], CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gssize], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gboolean], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gboolean], CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], gsize, Ptr[gsize], Ptr[GCancellable], Ptr[Ptr[GError]], gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, gpointer, Unit], CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[gsize], Ptr[Ptr[GError]], gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
>>>
object types:
   type GOutputStreamClass = CStruct21[
     GObjectClass,
     CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], gsize, Ptr[GCancellable], Ptr[
       Ptr[GError]
     ], gssize],
     CFuncPtr5[Ptr[GOutputStream], Ptr[
       GInputStream
     ], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[GError]], gssize],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[
       Ptr[GError]
     ], gboolean],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[
       Ptr[GError]
     ], gboolean],
     CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], gsize, CInt, Ptr[
       GCancellable
     ], GAsyncReadyCallback, gpointer, Unit],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gssize],
     CFuncPtr7[Ptr[GOutputStream], Ptr[
       GInputStream
     ], GOutputStreamSpliceFlags, CInt, Ptr[
       GCancellable
     ], GAsyncReadyCallback, gpointer, Unit],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[GError]], gssize],
     CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[
       GCancellable
     ], GAsyncReadyCallback, gpointer, Unit],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[
       Ptr[GError]
     ], gboolean],
     CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[
       GCancellable
     ], GAsyncReadyCallback, gpointer, Unit],
     CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[
       Ptr[GError]
     ], gboolean],
     CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], gsize, Ptr[gsize], Ptr[
       GCancellable
     ], Ptr[Ptr[GError]], gboolean],
     CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], gsize, CInt, Ptr[
       GCancellable
     ], GAsyncReadyCallback, gpointer, Unit],
     CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[gsize], Ptr[
       Ptr[GError]
     ], gboolean],
     CFuncPtr0[Unit],
     CFuncPtr0[Unit],
     CFuncPtr0[Unit],
     CFuncPtr0[Unit],
     CFuncPtr0[Unit]
   ]
<<< interleaved
maxColumn = 40
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )(implicit c: C): B = ???
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )[C](implicit c: C): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit
       c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, implicitParamListModifierPrefer = before
maxColumn = 40
newlines.implicitParamListModifierPrefer = before
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )(implicit c: C): B = ???
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )[C](implicit c: C): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, implicitParamListModifierPrefer = after
maxColumn = 40
newlines.implicitParamListModifierPrefer = after
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )(implicit c: C): B = ???
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )[C](implicit c: C): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit
       c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, implicitParamListModifierForce = [after]
maxColumn = 40
newlines.implicitParamListModifierForce = [after]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )(implicit
       c: C
   ): B = ???
   def f[A](a: A, as: A*)[B](
       b: B,
       bs: B*
   )[C](implicit
       c: C
   ): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit
       c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, implicitParamListModifierForce = [before]
maxColumn = 40
newlines.implicitParamListModifierForce = [before]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
   )[B](b: B, bs: B*)(
       implicit c: C
   ): B = ???
   def f[A](
       a: A,
       as: A*
   )[B](b: B, bs: B*)[C](
       implicit c: C
   ): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, implicitParamListModifierForce = [before,after]
maxColumn = 40
newlines.implicitParamListModifierForce = [before,after]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
   )[B](b: B, bs: B*)(
       implicit
       c: C
   ): B = ???
   def f[A](
       a: A,
       as: A*
   )[B](b: B, bs: B*)[C](
       implicit
       c: C
   ): B = ???
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(a: A, as: A*)(b: B, bs: B*)(
       implicit
       c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, vertical multiline
maxColumn = 40
verticalMultiline.atDefnSite = true
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(implicit c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit
       c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, vertical multiline, implicitParamListModifierPrefer = before
maxColumn = 40
verticalMultiline.atDefnSite = true
newlines.implicitParamListModifierPrefer = before
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(implicit c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, vertical multiline, implicitParamListModifierPrefer = after
maxColumn = 40
verticalMultiline.atDefnSite = true
newlines.implicitParamListModifierPrefer = after
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(implicit c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit
       c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, vertical multiline, implicitParamListModifierForce = [after]
maxColumn = 40
verticalMultiline.atDefnSite = true
newlines.implicitParamListModifierForce = [after]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(implicit
       c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit
       c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit
       c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, vertical multiline, implicitParamListModifierForce = [before]
maxColumn = 40
verticalMultiline.atDefnSite = true
newlines.implicitParamListModifierForce = [before]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(
       implicit c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(
       implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(
       implicit c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, vertical multiline, implicitParamListModifierForce = [before,after]
maxColumn = 40
verticalMultiline.atDefnSite = true
newlines.implicitParamListModifierForce = [before,after]
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(
       implicit
       c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit
       c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(
       implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(
       implicit
       c: C,
       d: D,
       implicit val e: E) {}
<<< interleaved, short
maxColumn = 23
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
   )[B](b: B, bs: B*)(
       implicit c: C
   ): B = ???
   def f[A](
       a: A,
       as: A*
   )[B](
       b: B,
       bs: B*
   )[C](implicit
       c: C
   ): B = ???
   class F(
       a: A,
       as: A*
   )(b: B, bs: B*)(
       implicit c: C,
       implicit val d: D
   ) {}
   class F(
       a: A,
       as: A*
   )(b: B, bs: B*)(
       implicit
       c: C,
       d: D,
       implicit val e: E
   ) {}
<<< interleaved, short, vertical multiline
maxColumn = 23
verticalMultiline.atDefnSite = true
===
object a:
  def f[A](a: A, as: A*)[B](b: B, bs: B*)(implicit c: C): B = ???
  def f[A](a: A, as: A*)[B](b: B, bs: B*)[C](implicit c: C): B = ???
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, implicit val d: D) {}
  class F(a: A, as: A*)(b: B, bs: B*)(implicit c: C, d: D, implicit val e: E) {}
>>>
object a:
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )(implicit c: C
     ): B = ???
   def f[A](
       a: A,
       as: A*
     )[B](
       b: B,
       bs: B*
     )[C](
       implicit c: C
     ): B = ???
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit c: C,
       implicit val d: D) {}
   class F(
       a: A,
       as: A*
     )(b: B,
       bs: B*
     )(implicit
       c: C,
       d: D,
       implicit val e: E) {}
<<< #3492
object Test:
  def test =
    try
      1; 2
    catch
      case _: RuntimeException => 2
      case _: Exception        => 3
>>>
object Test:
   def test =
     try
        1;
        2
     catch
        case _: RuntimeException =>
          2
        case _: Exception =>
          3
<<< #3497
newlines.beforeOpenParenDefnSite = unfold
===
extension (s: String)
  /** ... */
  def foo(): Unit = ???
  def bar(): Unit = ???
>>>
extension (s: String)
   /** ... */
   def foo(): Unit = ???
   def bar(): Unit = ???
<<< #3527
def foo(xs: List[Int]) =
  xs.map: x =>
    x + 1
  .toSet
  .filter: x =>
    x > 0
  .toList
>>>
def foo(xs: List[Int]) =
  xs.map: x =>
       x + 1
    .toSet
    .filter: x =>
       x > 0
    .toList
<<< #3537 1
rewrite.scala3.convertToNewSyntax = yes
rewrite.scala3.removeOptionalBraces = yes
===
object A:
  new Foo("xyz") {
    print("msg")
  }.bar()
>>>
object A:
   new Foo("xyz"):
      print("msg")
   .bar()
<<< #3537 2
object A:
  new Foo("xyz"):
    print("msg")
  .bar()
>>>
object A:
   new Foo("xyz"):
      print("msg")
   .bar()
