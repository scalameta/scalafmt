align.preset = none
maxColumn = 40
newlines.source = unfold
runner.optimizer.forceConfigStyleMinSpan = 50
binPack.parentConstructors = OnelineIfPrimaryOneline
<<< 1.1: block, if-else, line too long
if (true) {      println(aaaaaaaaaaaaaaaaaaaaaaaaaa)}
>>>
if (true) {
  println(aaaaaaaaaaaaaaaaaaaaaaaaaa)
}
<<< 1.2: block, if-else, egyptian curlies
object a {
if (a) {
println("bbb") } else c
}
>>>
object a {
  if (a) {
    println("bbb")
  } else
    c
}
<<< 1.3: block, if, non-egyptian curlies
object a {
if (a)
{
println("bbb")
}
else
{
c
}}
>>>
object a {
  if (a) {
    println("bbb")
  } else {
    c
  }
}
<<< 1.4: block #1043
object a {
      if ('0' <= c && c <= '9') { c - '0' }
      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }
      else if ('a' <= c && c <= 'f') { c - 'a' + 10 }
      else {
       -1  }}
>>>
object a {
  if ('0' <= c && c <= '9') {
    c - '0'
  } else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else {
    -1
  }
}
<<< 1.5: block #1043 with lines joined
object a {
      if ('0' <= c && c <= '9') { c - '0' }      else if ('A' <= c && c <= 'F') {
       c - 'A' + 10 }  else if ('a' <= c && c <= 'f') { c - 'a' + 10 }      else {
                                                            -1
}}
>>>
object a {
  if ('0' <= c && c <= '9') {
    c - '0'
  } else if ('A' <= c && c <= 'F') {
    c - 'A' + 10
  } else if ('a' <= c && c <= 'f') {
    c - 'a' + 10
  } else {
    -1
  }
}
<<< 1.6: block, try-catch, line too long
object a {
try { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa } catch { case b => }
}
>>>
object a {
  try {
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  } catch {
    case b =>
  }
}
<<< 1.7: block, try-catch, no breaks
object a {
try { a } catch { case b => ; case c => } finally { d }
}
>>>
object a {
  try {
    a
  } catch {
    case b => ;
    case c =>
  } finally {
    d
  }
}
<<< 1.8: block, try-catch, with breaks
object a {
try {
 a } catch {
  case b => ; case c => } finally {
   d }
}
>>>
object a {
  try {
    a
  } catch {
    case b => ;
    case c =>
  } finally {
    d
  }
}
<<< 1.9: block, try-catch, with breaks, top-level
try {
 a } catch {
  case b => ; case c => } finally {
   d }
>>>
try {
  a
} catch {
  case b => ;
  case c =>
} finally {
  d
}
<<< 1.a: block, class
object a {
class a {
 type b = Int
}
}
>>>
object a {
  class a {
    type b = Int
  }
}
<<< 1.b: block, trait and object
object a {
trait b {
 type c = Int
}
object b {
def apply(c: Int) = { new d(c)
}
}}
>>>
object a {
  trait b {
    type c = Int
  }
  object b {
    def apply(c: Int) = {
      new d(c)
    }
  }
}
<<< 1.c: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user")
    } should have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message
    """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.1: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message
    """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.2: block followed by an infix, overflowing if no break
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should
       have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should have message
    """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.3: block followed by an infix, break before, overflowing if no break
newlines.infix.termSite.maxCountPerFile = 0
maxColumn = 80
===
object a {
    the[Exception] thrownBy
       { SizeUtils.calculate(segments, "user") } should
       have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy
    {
      SizeUtils.calculate(segments, "user")
    } should
    have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.c.4: block followed by an infix, no break before, overflowing if no break
newlines.infix.termSite.maxCountPerFile = 0
maxColumn = 80
===
object a {
    the[Exception] thrownBy { SizeUtils.calculate(segments, "user") } should
       have message """Cannot resolve column name "user" among (segment_id);"""
}
>>>
object a {
  the[Exception] thrownBy {
    SizeUtils.calculate(segments, "user")
  } should
    have message """Cannot resolve column name "user" among (segment_id);"""
}
<<< 1.d: if-else, no curlies
if (a)
println("bbb") else if (b) b else c
>>>
if (a)
  println("bbb")
else if (b)
  b
else
  c
<<< 2.1: def one-line body
def a = b
>>>
def a = b
<<< 2.2: def one-line block body
object a {
def a = { b; c }
}
>>>
object a {
  def a = {
    b;
    c
  }
}
<<< 2.3: def one-line block body with a break
object a {
def a =
 { b; c }
}
>>>
object a {
  def a = {
    b;
    c
  }
}
<<< 2.4: def multiline-line block body with a break
object a {
def a =
 {
  b;c }}
>>>
object a {
  def a = {
    b;
    c
  }
}
<<< 2.5: def multiline-line block body with a break
object a {
def a = {
  b;c }
}
>>>
object a {
  def a = {
    b;
    c
  }
}
<<< 2.6 #1747: one line with else
maxColumn = 55
===
object a {
  val ok1 = if (a > 10) Some(a) else None
  val ok2 = if (a > 10) { Some(a) } else { None }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
    else
      None
  val ok2 =
    if (a > 10) {
      Some(a)
    } else {
      None
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    } else {
      None
    }
}
<<< 2.7 #1747: one line without else
maxColumn = 40
===
object a {
  val ok1 = if (a > 10) Some(a)
  val ok2 = if (a > 10) { Some(a) }
  val ok3 = if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
  val ok2 =
    if (a > 10) {
      Some(a)
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    }
}
<<< 2.8 #1747: split on then with else
maxColumn = 55
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  else
    None
  val ok2 = if (a > 10) {
    Some(a)
  } else {
    None
  }
  val ok3 = if (aaaa > 10000) {
     Some(aaaa)
  }
  else {
    None
  }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
    else
      None
  val ok2 =
    if (a > 10) {
      Some(a)
    } else {
      None
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    } else {
      None
    }
}
<<< 2.9 #1747: split on else
maxColumn = 55
===
object a {
  val ok1 = if (a > 10) Some(a) else
    None
  val ok2 = if (a > 10) { Some(a) } else {
    None
  }
  val ok3 = if (aaaa > 10000) { Some(aaaa) } else {
    None
  }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
    else
      None
  val ok2 =
    if (a > 10) {
      Some(a)
    } else {
      None
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    } else {
      None
    }
}
<<< 2.10 #1747: split on then without else
maxColumn = 40
===
object a {
  val ok1 = if (a > 10)
    Some(a)
  val ok2 = if (a > 10) {
    Some(a) }
  val ok3 = if (aaaa > 10000) {
    Some(aaaa) }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
  val ok2 =
    if (a > 10) {
      Some(a)
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    }
}
<<< 2.11 #1747: split on if
maxColumn = 55
===
object a {
  val ok1 =
    if (a > 10) Some(a) else None
  val ok2 =
    if (a > 10) { Some(a) } else { None }
  val ok3 =
    if (aaaa > 10000) { Some(aaaa) } else { None }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
    else
      None
  val ok2 =
    if (a > 10) {
      Some(a)
    } else {
      None
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    } else {
      None
    }
}
<<< 2.12 #1747: split on if without else
maxColumn = 40
===
object a {
  val ok1 =
    if (a > 10) Some(a)
  val ok2 =
    if (a > 10) { Some(a) }
  val ok3 =
   if (aaaa > 10000) { Some(aaaa) }
}
>>>
object a {
  val ok1 =
    if (a > 10)
      Some(a)
  val ok2 =
    if (a > 10) {
      Some(a)
    }
  val ok3 =
    if (aaaa > 10000) {
      Some(aaaa)
    }
}
<<< 2.13 val with for/yield
maxColumn = 80
===
val attributes = for (_ ← 1 to count) yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.2 val with for/yield, redundant braces
maxColumn = 80
rewrite.rules = [RedundantBraces]
===
val attributes = {
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
}
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.3 val with for/yield, redundant parens
maxColumn = 80
rewrite.rules = [RedundantParens]
===
val attributes = (
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
)
>>>
val attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.4 def with for/yield
maxColumn = 80
===
def attributes =
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
}
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.5 def with for/yield, redundant braces
maxColumn = 80
rewrite.rules = [RedundantBraces]
===
def attributes = {
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
}
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.13.6 def with for/yield, redundant parens
maxColumn = 80
rewrite.rules = [RedundantParens]
===
def attributes = (
 for (_ ← 1 to count)
 yield {
  val tag = d.readUnsignedShort()
  val length = d.readInt()
  if (debug) println(s"LNB:   tag ${c(tag)} ($length bytes)")
  if (tag != s) {
    skip(d, length)
    None
  } else {
    val name = d.readUnsignedShort()
    Some(c(name))
  }
 }
)
>>>
def attributes =
  for (_ ← 1 to count)
    yield {
      val tag = d.readUnsignedShort()
      val length = d.readInt()
      if (debug)
        println(s"LNB:   tag ${c(tag)} ($length bytes)")
      if (tag != s) {
        skip(d, length)
        None
      } else {
        val name = d.readUnsignedShort()
        Some(c(name))
      }
    }
<<< 2.14 val with short for/yield
maxColumn = 80
===
val attributes =
  for (i ← 1 to count) yield i
>>>
val attributes =
  for (i ← 1 to count)
    yield i
<<< 2.14 val with short for/do
maxColumn = 80
===
val attributes =
  for (i ← 1 to count) i * i
>>>
val attributes =
  for (i ← 1 to count)
    i * i
<<< 2.15 val with literal apply
object a {
   val a = b(0x1F, // ID1
       0x8B, // ID2
       8, // CM = Deflate
       0, // FLG
       0, // MTIME 1
       0, // MTIME 2
       0, // MTIME 3
       0, // MTIME 4
       0, // XFL
       0 // OS
    )
 }
>>>
object a {
  val a = b(
    0x1f, // ID1
    0x8b, // ID2
    8, // CM = Deflate
    0, // FLG
    0, // MTIME 1
    0, // MTIME 2
    0, // MTIME 3
    0, // MTIME 4
    0, // XFL
    0 // OS
  )
}
<<< 2.16 val with apply and comment
danglingParentheses.preset = false
===
val a = Set("b" // ...
)
>>>
val a = Set(
  "b" // ...
)
<<< 2.17 val with apply-apply-select
val aaaaa = bbbbb.asss(as).ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb
  .asss(as)
  .ccccc(ddddd, eeeee, fffff) // comment
<<< 2.18 val with apply-apply
val aaaaa = (getSomeLongerFunction(c))(as)
>>>
val aaaaa =
  (getSomeLongerFunction(c))(as)
<<< 2.19 val with apply-select-select
val aaaaa = bbbbb.asss.ccccc(
    ddddd,
    eeeee,
    fffff
  ) // comment
>>>
val aaaaa = bbbbb
  .asss
  .ccccc(ddddd, eeeee, fffff) // comment
<<< 2.20 val with apply-select-select
val nested =
  promiseIntercept(new Actor {
    def receive = {
      case _ ⇒
    }
  })(result)
>>>
val nested =
  promiseIntercept(
    new Actor {
      def receive = { case _ ⇒
      }
    }
  )(result)
<<< 2.21 val with apply type
val deployment = system
  .asInstanceOf[ActorSystemImpl]
  .provider
  .deployer
  .lookup(service.split("/").drop(1))
>>>
val deployment = system
  .asInstanceOf[ActorSystemImpl]
  .provider
  .deployer
  .lookup(service.split("/").drop(1))
<<< 2.22
maxColumn = 80
===
val augassign: P[Ast.operator] = P(
    "+=".!.map(_ => Ast.operator.Add) |
    "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) |
    "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) |
    "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) |
    "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) |
    "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
  )
>>>
val augassign: P[Ast.operator] = P(
  "+=".!.map(_ => Ast.operator.Add) | "-=".!.map(_ => Ast.operator.Sub) |
    "*=".!.map(_ => Ast.operator.Mult) | "/=".!.map(_ => Ast.operator.Div) |
    "%=".!.map(_ => Ast.operator.Mod) | "&=".!.map(_ => Ast.operator.BitAnd) |
    "|=".!.map(_ => Ast.operator.BitOr) | "^=".!.map(_ => Ast.operator.BitXor) |
    "<<=".!.map(_ => Ast.operator.LShift) |
    ">>=".!.map(_ => Ast.operator.RShift) | "**=".!.map(_ => Ast.operator.Pow) |
    "//=".!.map(_ => Ast.operator.FloorDiv)
)
<<< 3.1: def non-config-style, long
def a( ccccccccccccccccc:Int,
 ddddddddddddddddd:String,
  eeeeeeeeeeeeeeeee:Long) = true
>>>
def a(
    ccccccccccccccccc: Int,
    ddddddddddddddddd: String,
    eeeeeeeeeeeeeeeee: Long
) = true
<<< 3.2: def non-config-style, short
def a( b:Int,
 c:String,
  d:Long) = true
>>>
def a(b: Int, c: String, d: Long) = true
<<< 3.3: apply non-config-style, no breaks on ( and )
val a = b(c, d,
  efgh)
>>>
val a = b(c, d, efgh)
<<< 3.4: apply non-config-style, no break on (, break on )
val a = b(c,
 d,
  efgh
)
>>>
val a = b(c, d, efgh)
<<< 3.5: apply non-config-style, break on (, no break on )
val a = b(
c,
 d,
  efgh)
>>>
val a = b(c, d, efgh)
<<< 3.6: apply config-style, break on ( and )
val a = b(
c,
 d,
  efgh
  )
>>>
val a = b(c, d, efgh)
<<< 3.7: apply non-config-style, force
val a = b( cccccccccccccc, dddddddddddddd,  eeeeeeeeeeeeee)
>>>
val a = b(
  cccccccccccccc,
  dddddddddddddd,
  eeeeeeeeeeeeee
)
<<< 3.8: apply non-config-style, too long
val a = b( ccccccccccc, ddddddddddd,  eeeeeeeeeee)
>>>
val a = b(
  ccccccccccc,
  ddddddddddd,
  eeeeeeeeeee
)
<<< 3.9: single-arg multi-line apply, possible config-style
a.b(foo {
    val bar = baz
    qux
  }
)
>>>
a.b(
  foo {
    val bar = baz
    qux
  }
)
<<< 3.10 enclosed, infix on the right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
  terminaters = Set() ++ (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  val terminaters =
    Set() ++ (
      for (i ← 1 to n)
        yield {
          val man = context.watch(context.system.actorOf(Props[Terminater]))
          man ! "run"
          man
        }
    )
  terminaters =
    Set() ++ (
      for (i ← 1 to n)
        yield {
          val man = context.watch(context.system.actorOf(Props[Terminater]))
          man ! "run"
          man
        }
    )
}
<<< 3.11 enclosed, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (for (i ← 1 to n)
    yield {
      val man = context.watch(context.system.actorOf(Props[Terminater]))
      man ! "run"
      man
    })
}
>>>
object a {
  (
    for (i ← 1 to n)
      yield {
        val man = context.watch(context.system.actorOf(Props[Terminater]))
        man ! "run"
        man
      }
  )
}
<<< 3.12 enclosed, followed by select
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    wrap(result ⇒
      actorOf(Props(new OuterActor(actorOf(Props(promiseIntercept({
        throw new IllegalStateException("Ur state be b0rked");
        new InnerActor
      })(result)))))))
  }).getMessage should ===("Ur state be b0rked")
}
>>>
object a {
  (
    intercept[java.lang.IllegalStateException] {
      wrap(result ⇒
        actorOf(
          Props(
            new OuterActor(
              actorOf(
                Props(
                  promiseIntercept({
                    throw new IllegalStateException("Ur state be b0rked");
                    new InnerActor
                  })(result)))))))
    }
  ).getMessage should ===("Ur state be b0rked")
}
<<< 3.13 enclosed, followed by select and infix
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  (intercept[java.lang.IllegalStateException] {
    in.readObject
  }).getMessage should ===(
    "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
      " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
>>>
object a {
  (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ).getMessage should
    ===(
      "Trying to deserialize a serialized ActorRef without an ActorSystem in scope." +
        " Use 'akka.serialization.Serialization.currentSystem.withValue(system) { ... }'")
}
<<< 3.14 enclosed, assignment, by itself
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
<<< 3.15 enclosed, assignment, infix on left
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a =
    (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 2
}
<<< 3.16 enclosed, assignment, infix on right
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a =
    2 ++ (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    )
}
<<< 3.17 enclosed, assignment, infix in middle
maxColumn = 80
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a =
    2 ++ (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 3
}
<<< 3.18 enclosed, assignment, by itself, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (intercept[java.lang.IllegalStateException] {
    in.readObject
  })
}
>>>
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
<<< 3.19 enclosed, assignment, infix on left, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a =
    (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 2
}
<<< 3.20 enclosed, assignment, infix on right, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a =
    2 ++ (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    )
}
<<< 3.21 enclosed, assignment, infix in middle, narrower
maxColumn = 60
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a =
    2 ++ (
      intercept[java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 3
}
<<< 3.22 enclosed, assignment, by itself, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a = (
    intercept[
      java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
<<< 3.23 enclosed, assignment, infix on left, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 2
}
>>>
object a {
  val a =
    (
      intercept[
        java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 2
}
<<< 3.24 enclosed, assignment, infix on right, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  )
}
>>>
object a {
  val a =
    2 ++ (
      intercept[
        java.lang.IllegalStateException] {
        in.readObject
      }
    )
}
<<< 3.25 enclosed, assignment, infix in middle, narrow
maxColumn = 40
danglingParentheses.preset = false
===
object a {
  val a = 2 ++ (
    intercept[java.lang.IllegalStateException] {
      in.readObject
    }
  ) ++ 3
}
>>>
object a {
  val a =
    2 ++ (
      intercept[
        java.lang.IllegalStateException] {
        in.readObject
      }
    ) ++ 3
}
<<< 3.26 enclosed, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    (supervisor
      .ask(AwaitActivation(endpoint))(timeout))
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(
    endpoint: ActorRef
)(implicit timeout: Timeout, executor: ExecutionContext): Future[ActorRef] =
  (supervisor.ask(AwaitActivation(endpoint))(timeout)).map[ActorRef]({
    case EndpointActivated(`endpoint`) ⇒
      endpoint
    case EndpointFailedToActivate(`endpoint`, cause) ⇒
      throw cause
  })
<<< 3.27 enclosed in block, def, chain follows
maxColumn = 80
===
  def activationFutureFor(endpoint: ActorRef)(implicit
      timeout: Timeout,
      executor: ExecutionContext): Future[ActorRef] =
    {supervisor
      .ask(AwaitActivation(endpoint))(timeout)}
      .map[ActorRef]({
        case EndpointActivated(`endpoint`) ⇒ endpoint
        case EndpointFailedToActivate(`endpoint`, cause) ⇒ throw cause
      })
>>>
def activationFutureFor(
    endpoint: ActorRef
)(implicit timeout: Timeout, executor: ExecutionContext): Future[ActorRef] = {
  supervisor.ask(AwaitActivation(endpoint))(timeout)
}.map[ActorRef]({
  case EndpointActivated(`endpoint`) ⇒
    endpoint
  case EndpointFailedToActivate(`endpoint`, cause) ⇒
    throw cause
})
<<< 3.28 apply with optimal token
maxColumn = 80
danglingParentheses.preset = false
===
case class AttributeInfo(symbol : Symbol, typeRef : Type, value : Option[Any],
  values : Seq[String ~ Any]) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
>>>
case class AttributeInfo(
    symbol: Symbol,
    typeRef: Type,
    value: Option[Any],
    values: Seq[String ~ Any]
) // sym_Ref info_Ref {constant_Ref} {nameRef constantRef}
<<< 3.29 apply with optimal token
maxColumn = 80
===
object a {
Multipart.FormData.BodyPart.Strict(
  "userfile",
  HttpEntity(`application/pdf`, ByteString("filecontent")),
  Map("filename" -> "test€.dat"),
  List(
    RawHeader("Content-Transfer-Encoding", "binary"),
    RawHeader("Content-Additional-1", "anything"),
    RawHeader("Content-Additional-2", "really-anything"))
)
}
>>>
object a {
  Multipart
    .FormData
    .BodyPart
    .Strict(
      "userfile",
      HttpEntity(`application/pdf`, ByteString("filecontent")),
      Map("filename" -> "test€.dat"),
      List(
        RawHeader("Content-Transfer-Encoding", "binary"),
        RawHeader("Content-Additional-1", "anything"),
        RawHeader("Content-Additional-2", "really-anything")
      )
    )
}
<<< 3.30: apply with single-arg assign; open nl, close nonl
object foo {
val a = b(c = d)
val a = b(c =
  d)
val a = b(
  c =  d)
val a = b(
  c =  d
  )
}
>>>
object foo {
  val a = b(c = d)
  val a = b(c = d)
  val a = b(c = d)
  val a = b(c = d)
}
<<< 3.31
object a {
  val b: Bbbbb[Seq[Ccccc]] = writable[Seq[Ccccc]]
}
>>>
object a {
  val b: Bbbbb[Seq[Ccccc]] =
    writable[Seq[Ccccc]]
}
<<< 4.1: annotation with newlines
maxColumn = 50
optIn.annotationNewlines = true
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot
  @deprecated
  class B(
      @annot
      @deprecated
      private implicit val x: Int
  ) extends A {
    @annot
    override def foo = 1

    @annot
    override def bar = {
      1
    }

    @annot
    @annot2
    @annot3
    @annot4 /*comment4*/
    @annot5
    @deprecated
    def foo2(
        @annot
        @deprecated
        x: Int
    ) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot
    @annot2(value = "foo", someInt = 5)
    @annot3
    @deprecated(value = "bar")
    def bar2 = 1
  }

  @annot
  @annot2
  @annot3
  @annot4
  @deprecated
  class C

  @annot
  @deprecated
  class D
}
<<< 4.2: annotation without newlines
maxColumn = 50
optIn.annotationNewlines = false
===
object WrapperToHaveStatTestCaseParserWorking {
  @annot   @deprecated   class B(@annot @deprecated private implicit val x: Int) extends A {
    @annot override def foo = 1

    @annot
    override def bar = {   1 }

    @annot @annot2 @annot3 @annot4 /*comment4*/ @annot5 @deprecated def foo2(@annot @deprecated x: Int) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value =
    "foo", someInt = 5) @annot3
    @deprecated(value =
    "bar") def bar2  =  1
  }

  @annot @annot2
  @annot3
  @annot4 @deprecated class C

  @annot
  @deprecated
  class D
}
>>>
object WrapperToHaveStatTestCaseParserWorking {
  @annot @deprecated
  class B(
      @annot @deprecated
      private implicit val x: Int
  ) extends A {
    @annot
    override def foo = 1

    @annot
    override def bar = {
      1
    }

    @annot @annot2 @annot3 @annot4 /*comment4*/
    @annot5 @deprecated
    def foo2(
        @annot @deprecated
        x: Int
    ) = 1

    // in case of annotations with params located in many lines
    // let's live with changed lines of params
    @annot @annot2(value = "foo", someInt = 5)
    @annot3 @deprecated(value = "bar")
    def bar2 = 1
  }

  @annot @annot2 @annot3 @annot4 @deprecated
  class C

  @annot @deprecated
  class D
}
<<< 4.2.1 annotation !annotationNewlines
align.preset = none
optIn.annotationNewlines = false
===
object a {
  @Ignore @Test def foo(): Unit = {
     val bar = baz
  }
  @Ignore @Test def fooFooFoo(): Unit = {
     val bar = baz
  }
}
>>>
object a {
  @Ignore @Test
  def foo(): Unit = {
    val bar = baz
  }
  @Ignore @Test
  def fooFooFoo(): Unit = {
    val bar = baz
  }
}
<<< 4.3: #938 flag false, newline no
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.4: #938 flag true, newline no
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.5: #938 flag false, newline yes
optIn.selfAnnotationNewline = false
maxColumn = 20
===
trait a {
  self =>
    blah
}
>>>
trait a { self =>
  blah
}
<<< 4.6: #938 flag true, newline yes
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a {
 self =>
    blah
}
>>>
trait a {
  self =>
  blah
}
<<< 4.7: #938 flag true, newline no, line too long
optIn.selfAnnotationNewline = true
maxColumn = 20
===
trait a { selfaaaaaaaaaaaaaaaa =>
    blah
}
>>>
trait a {
  selfaaaaaaaaaaaaaaaa =>
  blah
}
<<< 4.8 flag true, annot in param
optIn.annotationNewlines = true
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
)
object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1
      x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 =>
        3
      case <A>2</A> =>
        2
    }
  }
}
<<< 4.9 flag false, annot in param
optIn.annotationNewlines = false
===
@ foobar("annot", {
  val x = 2
  val y = 2 // y=2
  x + y
})
 object
  a  extends b with c {

   def
   foo[T: Int#Double#Triple,
       R <% String](
    @annot1
    x
    : Int @annot2 = 2
    , y: Int = 3): Int = {
    "match" match {
      case 1 | 2 =>   3
      case <A>2</A> => 2
    }
   }
}
>>>
@foobar(
  "annot", {
    val x = 2
    val y = 2 // y=2
    x + y
  }
)
object a extends b with c {

  def foo[
      T: Int#Double#Triple,
      R <% String
  ](
      @annot1
      x: Int @annot2 = 2,
      y: Int = 3
  ): Int = {
    "match" match {
      case 1 | 2 =>
        3
      case <A>2</A> =>
        2
    }
  }
}
<<< 4.10
maxColumn = 80
===
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]]],
     val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
     val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
     val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]])
     extends BaseEngine[EI, Q, P, A]
>>>
class Engine[TD, EI, PD, Q, P, A](
    val dataSourceClassMap: Map[String, Class[
      _ <: BaseDataSource[TD, EI, Q, A]
    ]],
    val preparatorClassMap: Map[String, Class[_ <: BasePreparator[TD, PD]]],
    val algorithmClassMap: Map[String, Class[_ <: BaseAlgorithm[PD, _, Q, P]]],
    val servingClassMap: Map[String, Class[_ <: BaseServing[Q, P]]]
) extends BaseEngine[EI, Q, P, A]
<<< 5.1: case statements
a match {
  case b =>
    bb
  case c => cc
   ccc
  case d =>
   dd
   ddd
  case e =>
  case f => ff
}
>>>
a match {
  case b =>
    bb
  case c =>
    cc
    ccc
  case d =>
    dd
    ddd
  case e =>
  case f =>
    ff
}
<<< 5.2 #1518
a match {
  case b: C => d.e match {
    case f => "g"
  }
}
>>>
a match {
  case b: C =>
    d.e match {
      case f =>
        "g"
    }
}
<<< 6.1: chain, no break
val a = b.c.d.e().f.g.h()
>>>
val a = b.c.d.e().f.g.h()
<<< 6.2: chain, break on =
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a = b
  .c
  .d
  .e(f)
  .g
  .h { i =>
    j
  }
  .k()
  .l(
    { m =>
      n
    },
    o
  )
<<< 6.2.1: chain, break on =, fold
newlines.selectChains = fold
===
val a =
 b.c
 .d.e(f)
 .g.h { i => j }
 .k().l({ m => n}, o)
>>>
val a = b.c.d.e(f).g.h { i =>
  j
}.k().l(
  { m =>
    n
  },
  o
)
<<< 6.3: chain, breaks in the middle
val a = b.c
 .d.e() .f
 .g .h()
>>>
val a = b.c.d.e().f.g.h()
<<< 6.4: chain without apply
maxColumn = 72
includeNoParensInSelectChains = true
===
object a {
created filter (ref ⇒
         !ref.isTerminated && !ref
          .asInstanceOf[ActorRefWithCell]
          .underlying.isInstanceOf[UnstartedCell]) should ===(
        Seq.empty[ActorRef])
}
>>>
object a {
  created filter (
    ref ⇒
      !ref.isTerminated &&
        !ref
          .asInstanceOf[ActorRefWithCell]
          .underlying
          .isInstanceOf[UnstartedCell]
  ) should ===(Seq.empty[ActorRef])
}
<<< 6.5: chain with delayed indent after break
maxColumn = 70
===
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc
    .union(algoPredicts).groupByKey().mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount")
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
>>>
object a {
  val unionAlgoPredicts: RDD[(QX, Seq[P])] = sc
    .union(algoPredicts)
    .groupByKey()
    .mapValues { ps =>
      {
        assert(
          ps.size == algoCount,
          "Must have same length as algoCount"
        )
        // TODO. Check size == algoCount
        ps.toSeq.sortBy(_._1).map(_._2)
      }
    }
}
<<< 7.1.1: enumerator and guard short, for long
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b
      if (b ++ b).length >= 2
    } yield a
}
<<< 7.1.2: enumerators and guard short, for long, parens
object a {
  for (i <- 0 until n;
        j <- 0 until n if i + j == v)
   yield (i, j)
}
>>>
object a {
  for (
    i <- 0 until n;
    j <- 0 until n
    if i + j == v
  )
    yield (i, j)
}
<<< 7.1.2: enumerator and guard short, for long, parens
object a {
  def a = for (a <- b; if cc < dd) yield a
}
>>>
object a {
  def a =
    for (
      a <- b;
      if cc < dd
    )
      yield a
}
<<< 7.2: enumerator short, guard long
maxColumn = 28
===
object a {
  def c(b: List[Int]): List[Int] =
    for {
      a <- b if (b ++ b).length >= 2
    } yield a
}
>>>
object a {
  def c(
      b: List[Int]
  ): List[Int] =
    for {
      a <- b
      if (b ++ b).length >=
        2
    } yield a
}
<<< 7.3: enumerator and guard short, for short
for (a <- b.sortBy(c)
 if a > 0) yield x
>>>
for (
  a <- b.sortBy(c)
  if a > 0
)
  yield x
<<< 7.4: enumerator and guard long
maxColumn = 17
===
val k = for {
  _ <- aa + bb
    if !onlyOne
  _ <- Future(aaa)
    if !onlyOne
  _ <- Future(2)
} yield ()
>>>
val k =
  for {
    _ <- aa + bb
    if !onlyOne
    _ <- Future(
      aaa
    )
    if !onlyOne
    _ <- Future(
      2
    )
  } yield ()
<<< 7.5: multiple consecutive guards
maxColumn = 80
===
val allOps = (
  for {
    c ← classes
    m ← c.getMethods if !Modifier.isStatic(m.getModifiers); if !ignore(m.getName)
    if !m.getName.contains("$"); if !materializing(m)
  } yield m.getName
).toSet
>>>
val allOps =
  (
    for {
      c ← classes
      m ← c.getMethods
      if !Modifier.isStatic(m.getModifiers);
      if !ignore(m.getName)
      if !m.getName.contains("$");
      if !materializing(m)
    } yield m.getName
  ).toSet
<<< 7.6: for-yield with select chain
maxColumn = 80
===
object a {
for {
       (listenAddress, listenerPromise) ← wrappedTransport.listen
       // Enforce ordering between the signalling of "listen ready" to upstream
       // and initialization happening in interceptListen
      _ ←
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
     } yield (augmentScheme(listenAddress), upstreamListenerPromise)
        listenerPromise
          .tryCompleteWith(
            interceptListen(listenAddress, upstreamListenerPromise.future1))
          .future2
}
>>>
object a {
  for {
    (listenAddress, listenerPromise) ← wrappedTransport.listen
    // Enforce ordering between the signalling of "listen ready" to upstream
    // and initialization happening in interceptListen
    _ ←
      listenerPromise
        .tryCompleteWith(
          interceptListen(listenAddress, upstreamListenerPromise.future1)
        )
        .future2
  } yield (augmentScheme(listenAddress), upstreamListenerPromise)
  listenerPromise
    .tryCompleteWith(
      interceptListen(listenAddress, upstreamListenerPromise.future1)
    )
    .future2
}
<<< 7.7: for-yield enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x =
    (mean
        + mean * mean * y * 0.5 / shape
        - 0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y)
    )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (
    mean +
      mean * mean * y * 0.5 / shape -
      0.5 * mean / shape *
      math.sqrt(
        4 * mean * shape * y +
          mean * mean * y * y
      )
  )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< 7.8: for-yield partially enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (mean
        + mean * mean * y * 0.5 / shape) -
        0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y)
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (
    mean + mean * mean * y * 0.5 / shape
  ) -
    0.5 * mean / shape *
    math.sqrt(
      4 * mean * shape * y +
        mean * mean * y * y
    )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< 7.9: for-yield fully and partially enclosed in parens
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = ((mean
        + mean * mean * y * 0.5 / shape) -
        0.5 * mean / shape * math
          .sqrt(4 * mean * shape * y + mean * mean * y * y))
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
>>>
for {
  nu <- rand.gaussian(0, 1)
  y = nu * nu
  x = (
    (
      mean +
        mean * mean * y * 0.5 / shape
    ) -
      0.5 * mean / shape *
      math.sqrt(
        4 * mean * shape * y +
          mean * mean * y * y
      )
  )
  z <- rand.uniform
} yield {
  if (z <= mean / (mean + x))
    x
  else
    mean * mean / x
}
<<< unfold ctor body with zero args
val foo = new Bar { () =>
  f(42)
}
>>>
val foo =
  new Bar { () =>
    f(42)
  }
<<< unfold ctor body with zero args
val foo = new Bar { () => f(42) }
>>>
val foo =
  new Bar { () =>
    f(42)
  }
<<< unfold ctor body with wildcard arg
val foo = Bar { _ =>
  println("a")
}
>>>
val foo = Bar { _ =>
  println("a")
}
<<< unfold apply with zero args
val foo = Bar { () =>
  f(42)
}
>>>
val foo = Bar { () =>
  f(42)
}
<<< 8.1: infix with longer left ||
indent.main = 4
===
val a =
  1 + 2 * 3 && 4 ^ 5 || 6 op
    7 map {
      8 % 9
    }
>>>
val a =
    1 + 2 * 3 && 4 ^ 5 || 6 op 7 map {
        8 % 9
    }
<<< 8.2: infix with shorter left ||
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
>>>
val a =
  1 + 2 * 3 || 4 ^ 5 && 6 op 7 map {
    8 % 9
  }
<<< 8.3: infix with longer left ||, narrow
maxColumn = 20
indent.main = 3
===
val a = 1 + 2 * 3 && 4 ^ 5 || 6 op 7 map { 8 % 9 }
>>>
val a =
   1 + 2 * 3 && 4 ^
      5 || 6 op
      7 map {
         8 % 9
      }
<<< 8.4: infix with shorter left ||, narrow
maxColumn = 17
indentOperator.topLevelOnly = false
===
{
val a = 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 }
val b = { 1 + 2 * 3 || 4 ^ 5 && 6 op 7 map { 8 % 9 } || somethinglong }
}
>>>
{
  val a =
    1 + 2 * 3 ||
    4 ^ 5 && 6 op
      7 map {
        8 % 9
      }
  val b = {
    1 + 2 * 3 ||
    4 ^ 5 && 6 op
      7 map {
        8 % 9
      } ||
      somethinglong
  }
}
<<< 8.5: sequences of infix operations
maxColumn = 75
runner.optimizer.forceConfigStyleOnOffset = 1000
===
val strings = Seq(
    "MetricEvaluatorResult:",
    s"  # engine params evaluated: ${engineParamsScores.size}") ++
    Seq(
      "Optimal Engine Params:",
      s"  $bestEPStr",
      "Metrics:",
      s"  $metricHeader: ${bestScore.score}") ++
    otherMetricHeaders.zip(bestScore.otherScores).map {
      case (h, s) => s"  $h: $s"
    } ++
    outputPath.toSeq.map { p =>
      s"The best variant params can be found in $p"
    }
>>>
val strings =
  Seq(
    "MetricEvaluatorResult:",
    s"  # engine params evaluated: ${engineParamsScores.size}"
  ) ++
    Seq(
      "Optimal Engine Params:",
      s"  $bestEPStr",
      "Metrics:",
      s"  $metricHeader: ${bestScore.score}"
    ) ++
    otherMetricHeaders
      .zip(bestScore.otherScores)
      .map { case (h, s) =>
        s"  $h: $s"
      } ++
    outputPath
      .toSeq
      .map { p =>
        s"The best variant params can be found in $p"
      }
<<< 8.6: assignment with short expression
object a {
  plugins(service.pluginType) += service.pluginName -> service
}
>>>
object a {
  plugins(service.pluginType) +=
    service.pluginName -> service
}
<<< 8.7
maxColumn = 80
===
val json = ("event" -> data("event")) ~ ("entityType" -> "user") ~
       ("entityId" -> data("userId")) ~ ("targetEntityType" -> "item") ~
       ("targetEntityId" -> data("itemId")) ~
       ("eventTime" -> data("timestamp")) ~ ("properties" -> (("context" ->
       (("ip" -> data("context[ip]")) ~ ("prop1" -> data("context[prop1]")
         .toDouble) ~ ("prop2" -> data("context[prop2]")))) ~
       ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
       ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))))
>>>
val json =
  ("event" -> data("event")) ~
    ("entityType" -> "user") ~
    ("entityId" -> data("userId")) ~
    ("targetEntityType" -> "item") ~
    ("targetEntityId" -> data("itemId")) ~
    ("eventTime" -> data("timestamp")) ~ (
      "properties" -> (
        (
          "context" -> (
            ("ip" -> data("context[ip]")) ~
              ("prop1" -> data("context[prop1]").toDouble) ~
              ("prop2" -> data("context[prop2]"))
          )
        ) ~
          ("anotherPropertyA" -> data.get("anotherPropertyA").map(_.toDouble)) ~
          ("anotherPropertyB" -> data.get("anotherPropertyB").map(_.toBoolean))
      )
    )
<<< 8.8
maxColumn = 80
===
override def hashCode: Int = 41 + fields.hashCode
>>>
override def hashCode: Int = 41 + fields.hashCode
<<< 8.9
maxColumn = 80
===
object a {
val fields = JField("engineVariant", JString(i.engineVariant)) ::
   JField("engineFactory", JString(i.engineFactory)) ::
     JField("batch", JString(i.batch)) ::
     JField("env", Extraction.decompose(i.env)(DefaultFormats))
}
>>>
object a {
  val fields =
    JField("engineVariant", JString(i.engineVariant)) ::
      JField("engineFactory", JString(i.engineFactory)) ::
      JField("batch", JString(i.batch)) ::
      JField(
        "env",
        Extraction.decompose(i.env)(DefaultFormats)
      )
}
<<< 8.10
maxColumn = 80
===
object a {
  def isReservedPrefix(name: String): Boolean =
      name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
>>>
object a {
  def isReservedPrefix(name: String): Boolean =
    name.startsWith("$") || name.startsWith("pio_")
  def idWithAppid(appid: Int, id: String): String = appid + "_" + id
}
<<< 8.11
maxColumn = 80
===
Some(
  ("ip" -> data.get("context[ip]")) ~ (
  "prop1" ->
     data.get("context[prop1]").map(_.toDouble)
))
>>>
Some(
  ("ip" -> data.get("context[ip]")) ~
    ("prop1" -> data.get("context[prop1]").map(_.toDouble))
)
<<< 8.12
maxColumn = 80
===
val json = (estype -> ("properties" -> ("status" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("startTime" ->
      ("type" -> "date")) ~ ("endTime" -> ("type" -> "date")) ~ ("engineId" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVersion" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineVariant" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("engineFactory" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("batch" ->
      ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("dataSourceParams" -> ("type" -> "string") ~ ("index" ->
        "not_analyzed")) ~ ("preparatorParams" -> ("type" -> "string") ~
        ("index" -> "not_analyzed")) ~ ("algorithmsParams" -> ("type" ->
          "string") ~ ("index" -> "not_analyzed")) ~ ("servingParams" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ ("status" ->
          ("type" -> "string") ~ ("index" -> "not_analyzed"))))
>>>
val json = (
  estype -> (
    "properties" ->
      ("status" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("startTime" -> ("type" -> "date")) ~
      ("endTime" -> ("type" -> "date")) ~
      ("engineId" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineVersion" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineVariant" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("engineFactory" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("batch" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~ (
        "dataSourceParams" -> ("type" -> "string") ~ ("index" -> "not_analyzed")
      ) ~ (
        "preparatorParams" -> ("type" -> "string") ~ ("index" -> "not_analyzed")
      ) ~ (
        "algorithmsParams" -> ("type" -> "string") ~ ("index" -> "not_analyzed")
      ) ~
      ("servingParams" -> ("type" -> "string") ~ ("index" -> "not_analyzed")) ~
      ("status" -> ("type" -> "string") ~ ("index" -> "not_analyzed"))
  )
)
<<< 8.13
maxColumn = 80
===
val a = b match {
  case i: EngineInstance =>
    JObject(
      JField("id", JString(i.id)) ::
        JField("status", JString(i.status)) ::
        JField("startTime", JString(i.startTime.toString)) ::
        JField("endTime", JString(i.endTime.toString)) ::
        JField("engineId", JString(i.engineId)) ::
        JField("engineVersion", JString(i.engineVersion)) ::
        JField("engineVariant", JString(i.engineVariant)) ::
        JField("engineFactory", JString(i.engineFactory)) ::
        JField("batch", JString(i.batch1)) ::
        JField("env", Extraction.decompose(i.env)(DefaultFormats)) ::
        JField(
          "sparkConf",
          Extraction.decompose(i.sparkConf)(DefaultFormats)) ::
        JField("dataSourceParams", JString(i.dataSourceParams)) ::
        JField("preparatorParams", JString(i.preparatorParams)) ::
        JField("algorithmsParams", JString(i.algorithmsParams)) ::
        JField("servingParams", JString(i.servingParams)) ::
        Nil)
}
>>>
val a =
  b match {
    case i: EngineInstance =>
      JObject(
        JField("id", JString(i.id)) :: JField("status", JString(i.status)) ::
          JField("startTime", JString(i.startTime.toString)) ::
          JField("endTime", JString(i.endTime.toString)) ::
          JField("engineId", JString(i.engineId)) ::
          JField("engineVersion", JString(i.engineVersion)) ::
          JField("engineVariant", JString(i.engineVariant)) ::
          JField("engineFactory", JString(i.engineFactory)) ::
          JField("batch", JString(i.batch1)) ::
          JField(
            "env",
            Extraction.decompose(i.env)(DefaultFormats)
          ) ::
          JField(
            "sparkConf",
            Extraction.decompose(i.sparkConf)(DefaultFormats)
          ) :: JField("dataSourceParams", JString(i.dataSourceParams)) ::
          JField("preparatorParams", JString(i.preparatorParams)) ::
          JField("algorithmsParams", JString(i.algorithmsParams)) ::
          JField("servingParams", JString(i.servingParams)) :: Nil
      )
  }
<<< 8.14
maxColumn = 80
===
private lazy val subNode: Parser[SubNode] = rep(' ') ~>
  ((opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ {
    name => AttrAppendSubNode(name)
  }) |
  (opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ {
    name => AttrRemoveSubNode(name)
  }) |    (opt('*') ~ '[' ~> attrName <~ ']' ^^ {
     name => AttrSubNode(name)
   }) |

   ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
   ('<' ~ '*' ~ '>') ^^ (a => SurroundKids()) |
   ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
   ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
   ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
   '*' ^^ (a => KidsSubNode()) |
   '^' ~ '*' ^^ (a => SelectThisNode(true)) |
   '^' ~ '^' ^^ (a => SelectThisNode(false)))
>>>
private lazy val subNode: Parser[SubNode] =
  rep(' ') ~> (
    (
      opt('*') ~ '[' ~> attrName <~ '+' ~ ']' ^^ { name =>
        AttrAppendSubNode(name)
      }
    ) | (
      opt('*') ~ '[' ~> attrName <~ '!' ~ ']' ^^ { name =>
        AttrRemoveSubNode(name)
      }
    ) | (
      opt('*') ~ '[' ~> attrName <~ ']' ^^ { name =>
        AttrSubNode(name)
      }
    ) |
      ('!' ~ '!' ^^ (a => DontMergeAttributes)) |
      ('<' ~ '*' ~ '>') ^^
      (a => SurroundKids()) |
      ('-' ~ '*' ^^ (a => PrependKidsSubNode())) |
      ('>' ~ '*' ^^ (a => PrependKidsSubNode())) |
      ('*' ~ '+' ^^ (a => AppendKidsSubNode())) |
      ('*' ~ '<' ^^ (a => AppendKidsSubNode())) |
      '*' ^^
      (a => KidsSubNode()) |
      '^' ~ '*' ^^
      (a => SelectThisNode(true)) |
      '^' ~ '^' ^^
      (a => SelectThisNode(false))
  )
<<< 8.15
maxColumn = 80
===
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
   import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~
        ("properties" -> (("email" -> data("data[email]")) ~
          ("email_type" -> data("data[email_type]")) ~
          ("merges" -> (("EMAIL" -> data("data[merges][EMAIL]")) ~
            ("FNAME" -> data("data[merges][FNAME]"))) ~
            ("LNAME" -> data("data[merges][LNAME]")) ~
            ("INTERESTS" -> data.get("data[merges][INTERESTS]")))) ~
          ("ip_opt" -> data("data[ip_opt]")) ~
          ("ip_signup" -> data("data[ip_signup]")))
      json
  }
}
>>>
object a {
  def toEventJson(common: Common, userAction: UserAction): JObject = {
    import org.json4s.JsonDSL._
    val json =
      ("event" -> "subscribe") ~
        ("entityType" -> "user") ~
        ("entityId" -> data("data[id]")) ~
        ("targetEntityType" -> "list") ~
        ("targetEntityId" -> data("data[list_id]")) ~
        ("eventTime" -> eventTime) ~ (
          "properties" -> (
            ("email" -> data("data[email]")) ~
              ("email_type" -> data("data[email_type]")) ~ (
                "merges" -> (
                  ("EMAIL" -> data("data[merges][EMAIL]")) ~
                    ("FNAME" -> data("data[merges][FNAME]"))
                ) ~
                  ("LNAME" -> data("data[merges][LNAME]")) ~
                  ("INTERESTS" -> data.get("data[merges][INTERESTS]"))
              )
          ) ~
            ("ip_opt" -> data("data[ip_opt]")) ~
            ("ip_signup" -> data("data[ip_signup]"))
        )
    json
  }
}
<<< 8.16
maxColumn = 80
===
override def preRestart(cause: Throwable, msg: Option[Any]) {
       if (master ne null) {
        master ! "failed with " + cause + " while processing " + msg
       }
       context stop self
     }
>>>
override def preRestart(cause: Throwable, msg: Option[Any]) {
  if (master ne null) {
    master ! "failed with " + cause + " while processing " + msg
  }
  context stop self
}
<<< 8.17
maxColumn = 80
===
object a {
   def `media-range-def` =
     rule {
       "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) |
        '*' ~ push("*") ~ push("*")
     }
}
>>>
object a {
  def `media-range-def` = rule {
    "*/*" ~ push("*") ~ push("*") |
      `type` ~ '/' ~
      ('*' ~ !tchar ~ push("*") | subtype) | '*' ~ push("*") ~ push("*")
  }
}
<<< 8.17 with explicit beforeMultilineDef
maxColumn = 80
newlines.beforeMultilineDef = unfold
===
object a {
   def `media-range-def` =
     rule {
       "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) |
        '*' ~ push("*") ~ push("*")
     }
}
>>>
object a {
  def `media-range-def` =
    rule {
      "*/*" ~ push("*") ~ push("*") |
        `type` ~ '/' ~
        ('*' ~ !tchar ~ push("*") | subtype) | '*' ~ push("*") ~ push("*")
    }
}
<<< 8.18
maxColumn = 80
===
object a {
  (people.map(p => (p.name, p.age))
  // c1
  returning people.map(_.id)
  // c2
  into ((nameAge, id) => Person(id, nameAge._1, nameAge._2))
  )
}
>>>
object a {
  (
    people.map(p => (p.name, p.age))
    // c1
    returning people.map(_.id)
    // c2
    into
      ((nameAge, id) => Person(id, nameAge._1, nameAge._2))
  )
}
<<< 8.19
maxColumn = 80
===
def `day-name` =
     rule(
       "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
        "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6))
>>>
def `day-name` = rule(
  "Sun" ~ push(0) | "Mon" ~ push(1) | "Tue" ~ push(2) | "Wed" ~ push(3) |
    "Thu" ~ push(4) | "Fri" ~ push(5) | "Sat" ~ push(6)
)
<<< 8.20
maxColumn = 80
===
HttpResponse(
   StatusCodes.ServiceUnavailable,
   entity = "The server was not able " +
   "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
>>>
HttpResponse(
  StatusCodes.ServiceUnavailable,
  entity =
    "The server was not able " +
      "to produce a timely response to your request.\r\nPlease try again in a short while!"
)
<<< 8.21
maxColumn = 80
===
private val allParams: Map[String, String] = mandatoryParams +
    (
      "data-config" ->
        dummyOptionalConfigPath,
      "max-sales-mappers" ->
        "10",
      "overwrite" ->
        null,
      "keep" -> dummyOptionalMaxVersionCount
    )
>>>
private val allParams: Map[String, String] =
  mandatoryParams + (
    "data-config" -> dummyOptionalConfigPath,
    "max-sales-mappers" -> "10",
    "overwrite" -> null,
    "keep" -> dummyOptionalMaxVersionCount
  )
<<< 8.22
maxColumn = 40
===
"Terminating(" + reason + ")" +
                   (toDie.toSeq.sorted mkString
                     (
                      "\n" +
                        indent +
                        "   |    toDie: ", "\n" + indent + "   |           ", ""
                     ))
>>>
"Terminating(" + reason + ")" + (
  toDie.toSeq.sorted mkString (
    "\n" + indent + "   |    toDie: ",
    "\n" + indent + "   |           ",
    ""
  )
)
<<< 8.23
maxColumn = 80
===
val ret = (if (dailyStats.isEmpty)
                   0
                 else {
                   val yestStats = dailyStats.last
                   val yestNav = yestStats.nav
                   (nav -
                     yestNav) / nav - 1
                 })
>>>
val ret = (
  if (dailyStats.isEmpty)
    0
  else {
    val yestStats = dailyStats.last
    val yestNav = yestStats.nav
    (nav - yestNav) / nav - 1
  }
)
<<< 8.24
maxColumn = 80
===
def isErrorEnabled(logClass: Class[_], logSource: String) =
    (eventStream.logLevel >= ErrorLevel) &&
      Logger(logClass, logSource).isErrorEnabled
>>>
def isErrorEnabled(logClass: Class[_], logSource: String) =
  (eventStream.logLevel >= ErrorLevel) &&
    Logger(logClass, logSource).isErrorEnabled
<<< 8.25
maxColumn = 80
===
def getShort(implicit byteOrder: ByteOrder): Short = {
    if (byteOrder == ByteOrder.BIG_ENDIAN)
      ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
    else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
      ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
     else throw new IllegalArgumentException("Unknown byte order " + byteOrder)
   }
>>>
def getShort(implicit byteOrder: ByteOrder): Short = {
  if (byteOrder == ByteOrder.BIG_ENDIAN)
    ((next() & 0xff) << 8 | (next() & 0xff) << 0).toShort
  else if (byteOrder == ByteOrder.LITTLE_ENDIAN)
    ((next() & 0xff) << 0 | (next() & 0xff) << 8).toShort
  else
    throw new IllegalArgumentException("Unknown byte order " + byteOrder)
}
<<< 8.26
maxColumn = 80
===
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m)) changeMembers(membersByAge - m + m) // replace
  }
>>>
def receiveClusterEvent(evt: ClusterDomainEvent): Unit =
  evt match {
    case MemberUp(m) =>
      if (matchingRole(m))
        changeMembers(membersByAge - m + m) // replace
  }
<<< 8.27
maxColumn = 80
===
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and
    (resultAfter must beEqualTo(None))
}
>>>
def insertAndDelete(eventClient: LEvents) = {
  val resultAfter = eventClient.get(eventId, appId)

  (resultBefore must beEqualTo(Some(expectedBefore))) and
    (deleteStatus must beEqualTo(true)) and
    (resultAfter must beEqualTo(None))
}
<<< 8.28 break before block
object a {
  val b = qual1 op1 { 1 + 2 + 3 + 4 + 5 } op2
    111 * 222 * 333 * 444 * 555 op3
    { "1 / 2 / 3 / 4 / 5 / 6 / 7" }
}
>>>
object a {
  val b =
    qual1 op1 {
      1 + 2 + 3 + 4 + 5
    } op2
      111 * 222 * 333 * 444 * 555 op3 {
        "1 / 2 / 3 / 4 / 5 / 6 / 7"
      }
}
<<< 8.28 no break before block
object a {
  val b = qual1 op1 { 1 + 2 + 3 + 4 + 5 } op2
    111 * 222 * 333 * 444 * 555 op3 {
      "1 / 2 / 3 / 4 / 5 / 6 / 7" }
}
>>>
object a {
  val b =
    qual1 op1 {
      1 + 2 + 3 + 4 + 5
    } op2
      111 * 222 * 333 * 444 * 555 op3 {
        "1 / 2 / 3 / 4 / 5 / 6 / 7"
      }
}
<<< 8.29
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
>>>
object a {
  val a: Seq[(C, D, E[_, _, _, _], F)] =
    (0 until c).map { x =>
      // c1
      x
    }
}
<<< 8.30
object a {
  json should be(
    """aaa bbb ccc ddd eee fff ggg"""
  )
}
>>>
object a {
  json should
    be(
      """aaa bbb ccc ddd eee fff ggg"""
    )
}
<<< 8.31 indent after comment
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
>>>
object a {
  val a = Seq(
    "c1" + // c1
      "c2" + // c2
      "c3" + // c3
      "c4" + // c4
      "c5" + // c5
      "c6" + // c6
      "c7" + // c7
      "c8" // c8
  )
}
<<< #1334 1: continue chain indent after a comment
class Foo {
  val vv = v.aaa //
  //
.bbb
.ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
>>>
class Foo {
  val vv = v
    .aaa //
    //
    .bbb
    .ccc()
  val vv = v.aaa //
  val vv = v.aaa
}
<<< #1334 2: continue chain indent after a comment, a bit longer
class Foo {
  val vv = v.aaa //
  .bbb //
  //
  .ccc //
  .ddd
  .eee()
}
>>>
class Foo {
  val vv = v
    .aaa //
    .bbb //
    //
    .ccc //
    .ddd
    .eee()
}
<<< #1334 3: continue chain indent after a comment with apply
class Foo {
  val vv = v.aaa //
  .bbb() //
  //
  .ccc //
  .ddd()
}
>>>
class Foo {
  val vv = v
    .aaa //
    .bbb() //
    //
    .ccc //
    .ddd()
}
<<< #1334 4: continue chain indent after a comment with apply, longer
indent.main = 4
===
class Foo {
  val vv = v.aaa //
  .bbb() //
  .ccc() //
  .ddd()
}
>>>
class Foo {
    val vv = v
        .aaa //
        .bbb() //
        .ccc() //
        .ddd()
}
<<< #1334 5: select and a block apply after a comment
     val a: Vector[Array[Double]] = b.c
     // similarUserFeatures may not contain the requested user
   .map { x =>
       similarUserFeatures.get(x)
     }.flatten
     // another comment
     .map { foo =>
       bar
       }
       .tail
>>>
val a: Vector[Array[Double]] =
  b.c
    // similarUserFeatures may not contain the requested user
    .map { x =>
      similarUserFeatures.get(x)
    }
    .flatten
    // another comment
    .map { foo =>
      bar
    }
    .tail
<<< #1334 6: multiple select and a match after a comment
val a: Vector[Array[Double]] = b.c
       // Only handle first case, others will be fixed on the next pass.
  .headOption
  .a match {
 case None =>
 case _ =>
}
>>>
val a: Vector[Array[Double]] =
  b.c
    // Only handle first case, others will be fixed on the next pass.
    .headOption
    .a match {
    case None =>
    case _ =>
  }
<<< #1888 check presence of comment, lack of break
maxColumn = 80
===
object a {
  def b(c: D): E = {
    val a = b.c
      .foo(_.tree.tpe =:= typeOf[D])
      .flatMap { x =>
        x.tree.children.tail.map { case E(F(g)) => g.asInstanceOf[String] }
      }
      .headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
>>>
object a {
  def b(c: D): E = {
    val a =
      b.c
        .foo(_.tree.tpe =:= typeOf[D])
        .flatMap { x =>
          x.tree
            .children
            .tail
            .map { case E(F(g)) =>
              g.asInstanceOf[String]
            }
        }
        .headOption
    F(c.name.toString.trim, alias, sym.typeSignature)
  }
}
<<< binpack call, always
binPack.callSite = always
optIn.configStyleArguments = false
===
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")), G(Some(Seq(h, i)), Some(Seq(j, k)), a.b, c.d, e.f.g, h.i.j)).foo
  }
}
>>>
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(
        Seq(F(1, "v1"), F(2, "v2")),
        G(
          Some(Seq(h, i)),
          Some(Seq(j, k)), a.b, c.d,
          e.f.g, h.i.j
        )
      ).foo
  }
}
<<< binpack call, oneline
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(Seq(F(1, "v1"), F(2, "v2")), G(Some(Seq(h, i)), Some(Seq(j, k)), a.b, c.d, e.f.g, h.i.j)).foo
  }
}
>>>
object a {
  test("foo") {
    a.b(c, d) shouldBe
      E(
        Seq(F(1, "v1"), F(2, "v2")),
        G(
          Some(Seq(h, i)),
          Some(Seq(j, k)), a.b, c.d,
          e.f.g, h.i.j
        )
      ).foo
  }
}
<<< binpack call, oneline, with syntaxNL, single arg
maxColumn = 60
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  val readOut = new ReadOnlyOutputDirectory("main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin)
}
>>>
object a {
  val readOut =
    new ReadOnlyOutputDirectory(
      "main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin
    )
}
<<< binpack call, oneline, with syntaxNL, multiple args
maxColumn = 60
binPack.callSite = oneline
optIn.configStyleArguments = false
===
object a {
  val readOut = new ReadOnlyOutputDirectory("main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin, "main.js.map" -> raw"""{
          |  "file": "main.js",
          |  "other key": 1
          |}""".stripMargin)
}
>>>
object a {
  val readOut =
    new ReadOnlyOutputDirectory(
      "main.js" -> raw"""
          |console.log("hello");
          |//# sourceMappingURL=main.js.map
          |// some other comment
          |""".stripMargin,
      "main.js.map" -> raw"""{
          |  "file": "main.js",
          |  "other key": 1
          |}""".stripMargin
    )
}
<<< binpack oneline, first arg with block
maxColumn = 80
binPack.preset = oneline
danglingParentheses.preset = false
newlines.configStyleCallSite.prefer = false
===
object a {
  assert(fastOptFile.get(scalaJSSourceMap).exists {
      _.getPath == fastOptFile.data.getPath + ".map"
    }, "fastOptJS does not have the correct scalaJSSourceMap attribute").foo
}
>>>
object a {
  assert(
    fastOptFile
      .get(scalaJSSourceMap)
      .exists {
        _.getPath == fastOptFile.data.getPath + ".map"
      },
    "fastOptJS does not have the correct scalaJSSourceMap attribute").foo
}
<<< binpack onelineSjs, first arg with block
maxColumn = 80
binPack.preset = oneline
binPack.callSite = onelinesjs
danglingParentheses.preset = false
newlines.configStyleCallSite.prefer = false
===
object a {
  assert(fastOptFile.get(scalaJSSourceMap).exists {
      _.getPath == fastOptFile.data.getPath + ".map"
    }, "fastOptJS does not have the correct scalaJSSourceMap attribute").foo
}
>>>
object a {
  assert(
    fastOptFile
      .get(scalaJSSourceMap)
      .exists {
        _.getPath == fastOptFile.data.getPath + ".map"
      },
    "fastOptJS does not have the correct scalaJSSourceMap attribute").foo
}
<<< binPack with named parameter values, danglingParentheses
binPack.preset = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(
      baz = Option.when(false)(x.qux)
    )
  )
}
<<< binPack with named parameter values, !danglingParentheses
binPack.preset = true
optIn.configStyleArguments = false
danglingParentheses.callSite = false
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(
      baz = Option.when(false)(x.qux)))
}
<<< literalsIncludeSimpleExpr with named parameter values, danglingParentheses
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
<<< literalsIncludeSimpleExpr with named parameter values, !danglingParentheses
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = false
===
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)
    )
  )
}
>>>
object a {
  val foo = bar.map(x =>
    x.copy(baz =
      Option.when(false)(x.qux)))
}
<<< binPack.literals, danglingParentheses
maxColumn = 100
binPack.literalArgumentLists = true
binPack.literalsExclude = []
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
===
object a {
  foo(
    bar.baz(Seq(
      Qux(
        "", 1, "par1", "2018-01-01", "2018-12-31", "2018-01-01", "2018-02-01", None, None, 1000,
        Some(0), Some(1), foo = Some("bar")
      )
    ))
  )
}
>>>
object a {
  foo(
    bar.baz(
      Seq(
        Qux(
          "", 1, "par1", "2018-01-01", "2018-12-31", "2018-01-01", "2018-02-01", None, None, 1000,
          Some(0), Some(1), foo = Some("bar")
        )
      )
    )
  )
}
<<< binPack.literals, danglingParentheses, avoid fold
maxColumn = 100
binPack.literalArgumentLists = true
binPack.literalsExclude = []
binPack.literalsIncludeSimpleExpr = true
optIn.configStyleArguments = false
danglingParentheses.callSite = true
runner.optimizer.forceConfigStyleOnOffset = 150
===
object a {
  private val audience3 = apiAudience(
    3, "b_name", Sams, Inid, "2", "created-by-user2", "updated-by-user2"
  ).copy(
    updatedAt = nowDate.minusDays(15),
    audienceSizeOnsite = Some(3333),
    audienceSizeOffsite = Some(1)
  )
}
>>>
object a {
  private val audience3 = apiAudience(
    3, "b_name", Sams, Inid, "2", "created-by-user2", "updated-by-user2"
  ).copy(
    updatedAt = nowDate.minusDays(15),
    audienceSizeOnsite = Some(3333),
    audienceSizeOffsite = Some(1)
  )
}
<<< binPack indent expiresOn=Before when dangle
binPack.preset = true
optIn.configStyleArguments = false
===
object a {
   protected def foo[U](bar: String, baz: Seq[String] = Seq.empty)(
       f: HttpResponse => U
  ): U = qux
}
>>>
object a {
  protected def foo[U](
      bar: String,
      baz: Seq[String] = Seq.empty
  )(f: HttpResponse => U): U = qux
}
<<< #1973 1
maxColumn = 25
indent.extendSite = 2
===
object a {
  object Foo
  extends Bar
  with Baz
}
>>>
object a {
  object Foo
    extends Bar with Baz
}
<<< #1973 2
maxColumn = 25
indent.extendSite = 2
===
object a {
  case class Foo(
    a: Boolean,
    b: String,
    c: String,
  )
  extends Bar
  with Baz
}
>>>
object a {
  case class Foo(
      a: Boolean,
      b: String,
      c: String
  ) extends Bar
    with Baz
}
<<< #1973 3
maxColumn = 25
indent.extendSite = 2
===
object a {
  trait Foo
  extends Bar
  with Baz
}
>>>
object a {
  trait Foo
    extends Bar with Baz
}
<<< #1989
maxColumn = 80
===
object a {
  val schema = StructType(Seq(
    StructField("fieldA", DataTypes.StringType),
    StructField("fieldB", DataTypes.StringType)
  ))
}
>>>
object a {
  val schema = StructType(
    Seq(
      StructField("fieldA", DataTypes.StringType),
      StructField("fieldB", DataTypes.StringType)
    )
  )
}
<<< def followed by comment, break, wrap
maxColumn = 100
comments.wrap = trailing
===
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  def foo(bar: Int): Int =
    /* comment line 1 comment line 2 */
    baz
}
<<< def followed by comment, break, no wrap
maxColumn = 100
comments.wrap = no
===
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  def foo(bar: Int): Int =
    /* comment line 1
     * comment line 2 */
    baz
}
<<< def followed by comment, no break
maxColumn = 100
comments.wrap = trailing
===
object a {
  def foo(bar: Int): Int = /* comment */
    baz
}
>>>
object a {
  def foo(bar: Int): Int = /* comment */
    baz
}
<<< val followed by comment, break, wrap
maxColumn = 100
comments.wrap = trailing
===
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  val foo: Int =
    /* comment line 1 comment line 2 */
    baz
}
<<< val followed by comment, break, no wrap
maxColumn = 100
comments.wrap = no
===
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
>>>
object a {
  val foo: Int =
    /* comment line 1
     * comment line 2 */
    baz
}
<<< val followed by comment, no break
maxColumn = 100
comments.wrap = trailing
===
object a {
  val foo: Int = /* comment */
    baz
}
>>>
object a {
  val foo: Int = /* comment */
    baz
}
<<< #2113 if-apply 1
object a {
  if (a)
    Seq(
      a,
      b
    )
  else
    Seq(
      a,
      b
    )
}
>>>
object a {
  if (a)
    Seq(a, b)
  else
    Seq(a, b)
}
<<< #2113 if-apply 2
maxColumn = 30
===
object a {
  if (a)
    Seq(aaaaaaaaaa, bbbbbbbbbb)
  else
    Seq(aaaaaaaaaa, bbbbbbbbbb)
}
>>>
object a {
  if (a)
    Seq(
      aaaaaaaaaa,
      bbbbbbbbbb
    )
  else
    Seq(
      aaaaaaaaaa,
      bbbbbbbbbb
    )
}
<<< #2113 def 1
maxColumn = 72
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) { // c1
      d.name should be("dir" + step)
      validate(d.parent, step - 1)
    }
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) { // c1
      d.name should be("dir" + step)
      validate(d.parent, step - 1)
    }
}
<<< #2113 def 2
maxColumn = 100
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) // c1
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) // c1
      d.name should be("dir" + step)
}
<<< #2113 def 3
maxColumn = 70
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) /* c1 */
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) /* c1 */
      d.name should be("dir" + step)
}
<<< #2113 def 4
object a {
  def validate(d: Directory): Unit = if (step != 0)
    d.name should be("dir" + step)
}
>>>
object a {
  def validate(d: Directory): Unit =
    if (step != 0)
      d.name should be("dir" + step)
}
<<< #2113 def 5
maxColumn = 80
===
object a {
  def validate(d: DirectoryProxy, step: Int): Unit = if (step != 0) /* c1 */ { /* c2 */
    d.name should be("dir" + step)
  }
}
>>>
object a {
  def validate(d: DirectoryProxy, step: Int): Unit =
    if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
}
<<< #2113 case 1
object a {
  a match {
    case a => d.name.should.be_dir("step1", "step2")
  }
}
>>>
object a {
  a match {
    case a =>
      d.name
        .should
        .be_dir("step1", "step2")
  }
}
<<< #2113 case 2
object a {
  a match {
    case a => d.name.should.be_dir("step1", "plus", "step2")
  }
}
>>>
object a {
  a match {
    case a =>
      d.name
        .should
        .be_dir(
          "step1",
          "plus",
          "step2"
        )
  }
}
<<< #2113 case 3
object a {
  a match {
    case a => d.name.should.be("dir").plus("step1", "step2")
  }
}
>>>
object a {
  a match {
    case a =>
      d.name
        .should
        .be("dir")
        .plus("step1", "step2")
  }
}
<<< #2113 case 4
object a {
  a match {
    case a => d.name should be("dir")
  }
}
>>>
object a {
  a match {
    case a =>
      d.name should be("dir")
  }
}
<<< #2113 case 5
object a {
  a match {
    case a => d.name should be("dir" + step)
  }
}
>>>
object a {
  a match {
    case a =>
      d.name should be("dir" + step)
  }
}
<<< #2113 case 6
object a {
  a match {
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 case 7
object a {
  a match {
    case a => if (step != 0) /* c1 */
      d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */)
      d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ {
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a =>
      if (step != 0) /* c1 */
        d.name should be("dir" + step)
    case a =>
      if (step != 0 /* c1 */ )
        d.name should be("dir" + step)
    case a =>
      if (step != 0) { /* c1 */
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ {
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 case 7, beforeMultiline = fold
newlines.beforeMultiline = fold
===
object a {
  a match {
    case a => if (step != 0) /* c1 */
      d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */)
      d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ {
      d.name should be("dir" + step)
    }
    case a => if (step != 0) /* c1 */ { /* c2 */
      d.name should be("dir" + step)
    }
  }
}
>>>
object a {
  a match {
    case a => if (step != 0) /* c1 */
        d.name should be("dir" + step)
    case a => if (step != 0 /* c1 */ )
        d.name should be("dir" + step)
    case a => if (step != 0) { /* c1 */
        d.name should be("dir" + step)
      }
    case a => if (step != 0) /* c1 */ {
        d.name should be("dir" + step)
      }
    case a =>
      if (step != 0) /* c1 */ { /* c2 */
        d.name should be("dir" + step)
      }
  }
}
<<< #2113 original
maxColumn = 80
===
object a {
  if (!someBooleanValue) Command.invalid
  else if (someIntValue != 1) Command.invalid
  else someCollection.get(args.head) match {
      case it @ Some(_) =>
        someService.setSomeValue(it)
        Command.success
      case None => Command.invalid
    }
}
>>>
object a {
  if (!someBooleanValue)
    Command.invalid
  else if (someIntValue != 1)
    Command.invalid
  else
    someCollection.get(args.head) match {
      case it @ Some(_) =>
        someService.setSomeValue(it)
        Command.success
      case None =>
        Command.invalid
    }
}
<<< complex match case triggering SLB precedence rule
object a {
  val breakpoints = (breaks.map {
      case Break(point) =>
          s"""|send "stop at $MainObject$$:$point\\r"
              |sleep $CommandWait
              |expect "breakpoint $MainObject$$:$point"
              |expect -re $$
              """.stripMargin
    }).mkString("\n\n")
}
>>>
object a {
  val breakpoints =
    (
      breaks.map { case Break(point) =>
        s"""|send "stop at $MainObject$$:$point\\r"
              |sleep $CommandWait
              |expect "breakpoint $MainObject$$:$point"
              |expect -re $$
              """.stripMargin
      }
    ).mkString("\n\n")
}
<<< #2137
pubSubMessage match {
  case message: IngestionMessage => (
    foo.bar.baz
  ) /* very long winded comment */
  case message: IngestionMessage =>
    (foo) /* comment */
  case message: IngestionMessage => (foo.bar.baz)
  case message: UploadMessage => {
    val services = makeUploadServices()

    UploadSubscriber(services).processEff(message)
  }
  case message: IngestionMessage => (
      IngestionSubscriber.defaultService
    ).processEff.message()
  case message: IngestionMessage => (
      IngestionSubscriber.defaultServices
    ).processEff.message()
}
>>>
pubSubMessage match {
  case message: IngestionMessage => (
    foo.bar.baz
  ) /* very long winded comment */
  case message: IngestionMessage => (
    foo
  ) /* comment */
  case message: IngestionMessage => (
    foo.bar.baz
  )
  case message: UploadMessage => {
    val services = makeUploadServices()

    UploadSubscriber(services)
      .processEff(message)
  }
  case message: IngestionMessage =>
    (IngestionSubscriber.defaultService)
      .processEff
      .message()
  case message: IngestionMessage =>
    (
      IngestionSubscriber
        .defaultServices
    ).processEff.message()
}
<<< #2137 tuple with ->, match
maxColumn = 20
===
a match {
  case (k, v) => (k -> v)
}
>>>
a match {
  case (k, v) =>
    (k -> v)
}
<<< #2137 tuple with ->, partial func
maxColumn = 20
===
a {
  case (k, v) => (k -> v)
}
>>>
a { case (k, v) =>
  (k -> v)
}
<<< #2137 non-matching parens, top-level
a match {
  case (k, v) => () => k(v)
}
>>>
a match {
  case (k, v) =>
    () => k(v)
}
<<< #2137 non-matching parens, inside object
object foo {
  a match {
    case (k, v) => () => k(v)
  }
}
>>>
object foo {
  a match {
    case (k, v) =>
      () => k(v)
  }
}
<<< #2137 non-matching parens, at source level
runner.parser = source
===
a match {
  case (k, v) => () => k(v)
}
>>>
a match {
  case (k, v) =>
    () => k(v)
}
<<< #2137 non-matching parens, at source level, inside top-level package
runner.parser = source
===
package foo
a match {
  case (k, v) => () => k(v)
}
>>>
package foo
a match {
  case (k, v) =>
    () => k(v)
}
<<< #2137 non-matching parens, inside indented package
package foo {
  a match {
    case (k, v) => () => k(v)
  }
}
>>>
package foo {
  a match {
    case (k, v) =>
      () => k(v)
  }
}
<<< #2137 empty parens
maxColumn = 17
===
a match {
  case (k, v) => ()
}
>>>
a match {
  case (k, v) =>
    ()
}
<<< #2158 for with guard
maxColumn = 70
danglingParentheses.preset = false
===
object a {
  for (method <- e.getMethods if break && method.hasModifierProperty("static")) {
    // noop
  }
}
>>>
object a {
  for (method <- e.getMethods
    if break && method.hasModifierProperty("static")) {
    // noop
  }
}
<<< #2158 val and no val
object a {
  val bbb = c match {
    case _ =>
  }
  bbb = c match {
    case _ =>
  }
}
>>>
object a {
  val bbb =
    c match {
      case _ =>
    }
  bbb =
    c match {
      case _ =>
    }
}
<<< #2219
a match {
  case ( Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux"
       ) =>
    (if (foo) (foo) + bar
    else foo + (bar)) + (baz)
  case ( Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux" ) => (foo)
}
>>>
a match {
  case (
        Root / "foo" | Root / "bar" |
        Root / "baz" / _ / "qux"
      ) =>
    (
      if (foo)
        (foo) + bar
      else
        foo + (bar)
    ) + (baz)
  case (
        Root / "foo" | Root / "bar" |
        Root / "baz" / _ / "qux"
      ) => (
    foo
  )
}
<<< #2219 with spaces, match
spaces.inParentheses = true
===
a match {
  case (Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux"
       ) =>
    (if (foo) (foo) + bar
    else foo + (bar)) + (baz)
  case (Root / "foo"
       | Root / "bar"
       | Root / "baz" / _ / "qux") => (foo)
}
>>>
a match {
  case (
        Root / "foo" | Root / "bar" |
        Root / "baz" / _ / "qux"
      ) =>
    (
      if ( foo )
        ( foo ) + bar
      else
        foo + ( bar )
    ) + ( baz )
  case (
        Root / "foo" | Root / "bar" |
        Root / "baz" / _ / "qux"
      ) => (
    foo
  )
}
<<< #2219 with spaces, apply
maxColumn = 80
spaces.inParentheses = true
===
foo ((((a, b) + c))) (((a, b)))
>>>
foo( (( ( a, b ) + c )) )( (( a, b )) )
<<< #2219 with spaces, for-do
spaces.inParentheses = true
===
for ((a, b) <- c.d) (((a, b)))
>>>
for ( ( a, b ) <- c.d )
  ((( a, b )))
<<< #2219 with spaces, for-do with braces
spaces.inParentheses = true
===
for ((a, b) <- c.d) {{ (((a, b))) }}
>>>
for ( ( a, b ) <- c.d ) {
  {
    ((( a, b )))
  }
}
<<< #2219 with spaces, for-yield
spaces.inParentheses = true
===
for ((a, b) <- c.d) yield (((a, b)))
>>>
for ( ( a, b ) <- c.d )
  yield ((( a, b )))
<<< #2219 with spaces, while
spaces.inParentheses = true
===
while ((((a,b) < (1,1)))) (((a, b)))
>>>
while ( (( ( a, b ) < ( 1, 1 ) )) )
  ((( a, b )))
<<< #2219 with spaces, if
spaces.inParentheses = true
===
if ((((a,b) < (1,1)))) (((a, b)))
>>>
if ( (( ( a, b ) < ( 1, 1 ) )) )
  ((( a, b )))
<<< #2250
danglingParentheses.callSite = true
===
object a {
  val a = foo(
     bar = baz =>
       qux(b =
         c
      )
   )
}
>>>
object a {
  val a = foo(bar = baz => qux(b = c))
}
<<< #2400 forceBeforeMultilineAssign = never
newlines.forceBeforeMultilineAssign = never
maxColumn = 25
===
class Test {
  val a = foo(
    1,
    2
  )
  val a = functionCall(
    111,
    222
  )
  val a = /* c */ functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
>>>
class Test {
  val a = foo(1, 2)
  val a = functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
<<< #2400 forceBeforeMultilineAssign = any
newlines.forceBeforeMultilineAssign = any
maxColumn = 25
===
class Test {
  val a = foo(
    1,
    2
  )
  val a = functionCall(
    111,
    222
  )
  val a = /* c */ functionCall(
    111,
    222
  )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
>>>
class Test {
  val a = foo(1, 2)
  val a =
    functionCall(
      111,
      222
    )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = /* c */
    functionCall(
      111,
      222
    )
  val a = // c
    functionCall(
      111,
      222
    )
}
<<< #2400 infix forceBeforeMultilineAssign = never
newlines.forceBeforeMultilineAssign = never
maxColumn = 25
===
class Test {
  val foo = bar +
    baz * qux + 1 + 2
}
>>>
class Test {
  val foo =
    bar + baz * qux + 1 +
      2
}
<<< #2400 infix forceBeforeMultilineAssign = any
newlines.forceBeforeMultilineAssign = any
maxColumn = 25
===
class Test {
  val foo = bar +
    baz * qux + 1 + 2
}
>>>
class Test {
  val foo =
    bar + baz * qux + 1 +
      2
}
<<< #2400 nesting forceBeforeMultilineAssign = topMember
maxColumn = 27
newlines.forceBeforeMultilineAssign = topMember
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() = barBar(
          bazBaz,
          quxQux
        )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = anyMember
maxColumn = 27
newlines.forceBeforeMultilineAssign = anyMember
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo =
          barBar(
            bazBaz,
            quxQux
          )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = any
maxColumn = 27
newlines.forceBeforeMultilineAssign = any
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
      for {
        foo <- barBar(bazBaz, quxQux)
        foo = barBar(bazBaz, quxQux)
      } yield foo
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo =
        barBar(
          bazBaz,
          quxQux
        )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo =
          barBar(
            bazBaz,
            quxQux
          )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
      for {
        foo <-
          barBar(
            bazBaz,
            quxQux
          )
        foo =
          barBar(
            bazBaz,
            quxQux
          )
      } yield foo
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = def
maxColumn = 27
newlines.forceBeforeMultilineAssign = def
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() =
        barBar(
          bazBaz,
          quxQux
        )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() =
          barBar(
            bazBaz,
            quxQux
          )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
    }
  }
}
<<< #2400 nesting forceBeforeMultilineAssign = never
maxColumn = 27
newlines.forceBeforeMultilineAssign = never
===
package a {
  class b {
    class c {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
    }
    def d = {
      val foo = barBar(bazBaz, quxQux)
      def foo() = barBar(bazBaz, quxQux)
      def foo(q: Int) = barBar(bazBaz, quxQux)
      new a with b {
        val foo = barBar(bazBaz, quxQux)
        def foo() = barBar(bazBaz, quxQux)
        def foo(q: Int) = barBar(bazBaz, quxQux)
      }
      for {
        foo <- barBar(bazBaz, quxQux)
        foo = barBar(bazBaz, quxQux)
      } yield foo
    }
  }
}
>>>
package a {
  class b {
    class c {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
    }
    def d = {
      val foo = barBar(
        bazBaz,
        quxQux
      )
      def foo() = barBar(
        bazBaz,
        quxQux
      )
      def foo(q: Int) =
        barBar(
          bazBaz,
          quxQux
        )
      new a with b {
        val foo = barBar(
          bazBaz,
          quxQux
        )
        def foo() = barBar(
          bazBaz,
          quxQux
        )
        def foo(q: Int) =
          barBar(
            bazBaz,
            quxQux
          )
      }
      for {
        foo <- barBar(
          bazBaz,
          quxQux
        )
        foo = barBar(
          bazBaz,
          quxQux
        )
      } yield foo
    }
  }
}
<<< #2422
runner.dialect = scala3
===
type T = A1 & A2 | A3 & A4 | A5 & A6 | A7 & A8 | A9 & A10[T10] |
  A11 & A12 | A13 & A14 | A15 & A16 | A17 & A18 | A19 & A20[T20] |
  A21 & A22 | A23 & A24 | A25 & A26 | A27 & A28 | A29 & A30[T30] |
  A31 & A32 | A33 & A34 | A35 & A36 | A37 & A38 | A39 & A40[T40] |
  A41 & A42 | A43 & A44 | A45 & A46 | A47 & A48 | A49 & A50[T50] |
  A51 & A52 | A53 & A54 | A55 & A56 | A57 & A58 | A59 & A60[T60] |
  A61 & A62 | A63 & A64 | A65 & A66 | A67 & A68 | A69 & A70[T70]
>>>
type T =
  A1 & A2 | A3 & A4 | A5 & A6 |
    A7 & A8 | A9 & A10[T10] |
    A11 & A12 | A13 & A14 | A15 & A16 |
    A17 & A18 | A19 & A20[T20] |
    A21 & A22 | A23 & A24 | A25 & A26 |
    A27 & A28 | A29 & A30[T30] |
    A31 & A32 | A33 & A34 | A35 & A36 |
    A37 & A38 | A39 & A40[T40] |
    A41 & A42 | A43 & A44 | A45 & A46 |
    A47 & A48 | A49 & A50[T50] |
    A51 & A52 | A53 & A54 | A55 & A56 |
    A57 & A58 | A59 & A60[T60] |
    A61 & A62 | A63 & A64 | A65 & A66 |
    A67 & A68 | A69 & A70[T70]
<<< #2422 with comments
runner.dialect = scala3
===
type T = A1 & A2 | A3 & A4 | A5 & A6 /* c1 */ | /* c2 */ A7 & A8 | A9 & A10[T10] |
  A11 & A12 | A13 & A14 | A15 & A16 /* c1 */ | /* c2 */ A17 & A18 | A19 & A20[T20] |
  A21 & A22 | A23 & A24 | A25 & A26 /* c1 */ | /* c2 */ A27 & A28 | A29 & A30[T30] |
  A31 & A32 | A33 & A34 | A35 & A36 /* c1 */ | /* c2 */ A37 & A38 | A39 & A40[T40] |
  A41 & A42 | A43 & A44 | A45 & A46 /* c1 */ | /* c2 */ A47 & A48 | A49 & A50[T50] |
  A51 & A52 | A53 & A54 | A55 & A56 /* c1 */ | /* c2 */ A57 & A58 | A59 & A60[T60] |
  A61 & A62 | A63 & A64 | A65 & A66 /* c1 */ | /* c2 */ A67 & A68 | A69 & A70[T70]
>>>
type T =
  A1 & A2 | A3 & A4 |
    A5 & A6 /* c1 */ | /* c2 */
    A7 & A8 | A9 & A10[T10] |
    A11 & A12 | A13 & A14 |
    A15 & A16 /* c1 */ | /* c2 */
    A17 & A18 | A19 & A20[T20] |
    A21 & A22 | A23 & A24 |
    A25 & A26 /* c1 */ | /* c2 */
    A27 & A28 | A29 & A30[T30] |
    A31 & A32 | A33 & A34 |
    A35 & A36 /* c1 */ | /* c2 */
    A37 & A38 | A39 & A40[T40] |
    A41 & A42 | A43 & A44 |
    A45 & A46 /* c1 */ | /* c2 */
    A47 & A48 | A49 & A50[T50] |
    A51 & A52 | A53 & A54 |
    A55 & A56 /* c1 */ | /* c2 */
    A57 & A58 | A59 & A60[T60] |
    A61 & A62 | A63 & A64 |
    A65 & A66 /* c1 */ | /* c2 */
    A67 & A68 | A69 & A70[T70]
<<< #2561 scala 2: defn, no align
align.preset = none
newlines.beforeOpenParenDefnSite = source
indent.extraBeforeOpenParenDefnSite = 3
newlines.sometimesBeforeColonInMethodReturnType = true
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (implicit foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
     (foo1: String)
     (
         foo2: String,
         foo3: String,
         foo4: Map[String, Map[
           String,
           Map[String, String]
         ]]
     ) // this line doesn't fit
     (foo5: String) {
  def fooFunc
       (foo1: String)
       (foo2: String)
       : String = ???
  def fooFunc
       (foo1: String)
       (foo2: String)
       (foo3: String)
       (foo4: String)
       (foo5: String)
       : (
           String,
           String,
           String,
           String
       ) = ???
  def notAnInterestingFunction
       (foo1: String)
       (
           foo2: String,
           foo3: String,
           foo4: Map[String, Map[
             String,
             Map[String, String]
           ]]
       ) // this line doesn't fit
       (foo5: String)
       (implicit
           foo6: Int,
           foo7: Int,
           foo8: Int,
           foo9: Int,
           foo10: Int,
           foo11: Int,
           foo12: Int
       ) // this line also doesn't fit
       : (
           String,
           String,
           String,
           String
       ) = ???
}
<<< #2561 scala 2: defn, align
align.preset = none
align.openParenDefnSite = true
newlines.beforeOpenParenDefnSite = unfold
newlines.sometimesBeforeColonInMethodReturnType = true
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (implicit foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
  (foo1: String)
  (foo2: String,
   foo3: String,
   foo4: Map[
     String,
     Map[String, Map[String, String]]
   ]
  ) // this line doesn't fit
  (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) =
    ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String,
     foo3: String,
     foo4: Map[
       String,
       Map[String, Map[String, String]]
     ]
    ) // this line doesn't fit
    (foo5: String)
    (implicit
        foo6: Int,
        foo7: Int,
        foo8: Int,
        foo9: Int,
        foo10: Int,
        foo11: Int,
        foo12: Int
    ) // this line also doesn't fit
    : (String, String, String, String) =
    ???
}
<<< #2561 scala 3: defn, no align
align.preset = none
runner.dialect = scala3
newlines.beforeOpenParenDefnSite = unfold
newlines.sometimesBeforeColonInMethodReturnType = false
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) = ???
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (using foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
  (foo1: String)
  (
      foo2: String,
      foo3: String,
      foo4: Map[
        String,
        Map[String, Map[String, String]]
      ]
  ) // this line doesn't fit
  (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String): String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String): (
      String,
      String,
      String,
      String
  ) = ???
  def notAnInterestingFunction
    (foo1: String)
    (
        foo2: String,
        foo3: String,
        foo4: Map[String, Map[
          String,
          Map[String, String]
        ]]
    ) // this line doesn't fit
    (foo5: String)
    (using
        foo6: Int,
        foo7: Int,
        foo8: Int,
        foo9: Int,
        foo10: Int,
        foo11: Int,
        foo12: Int
    ) // this line also doesn't fit
    : (String, String, String, String) =
    ???
}
<<< #2561 scala 3: defn, align
align.preset = none
align.openParenDefnSite = true
runner.dialect = scala3
newlines.beforeOpenParenDefnSite = source
indent.extraBeforeOpenParenDefnSite = 3
newlines.sometimesBeforeColonInMethodReturnType = false
indent.significant = 3
===
class fooClass
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String
  def fooFunc
    (foo1: String)
    (foo2: String)
    : String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String)
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String)
    : (String, String, String, String) =
    bar
    baz
  def notAnInterestingFunction
    (foo1: String)
    (foo2: String, foo3: String, foo4: Map[String, Map[String, Map[String, String]]]) // this line doesn't fit
    (foo5: String)
    (using foo6: Int,  foo7: Int,  foo8: Int,  foo9: Int,  foo10: Int,  foo11: Int,  foo12: Int) // this line also doesn't fit
    : (String, String, String, String) = ???
}
>>>
class fooClass
     (foo1: String)
     (foo2: String,
      foo3: String,
      foo4: Map[
        String,
        Map[String, Map[String, String]]
      ]
     ) // this line doesn't fit
     (foo5: String) {
  def fooFunc
    (foo1: String)
    (foo2: String): String
  def fooFunc
       (foo1: String)
       (foo2: String): String = ???
  def fooFunc
    (foo1: String)
    (foo2: String)
    (foo3: String)
    (foo4: String)
    (foo5: String): (
      String,
      String,
      String,
      String
  )
  def fooFunc
        (foo1: String)
        (foo2: String)
        (foo3: String)
        (foo4: String)
        (foo5: String): (
      String,
      String,
      String,
      String
  ) =
     bar
     baz
  def notAnInterestingFunction
       (foo1: String)
       (foo2: String,
        foo3: String,
        foo4: Map[String, Map[
          String,
          Map[String, String]
        ]]
       ) // this line doesn't fit
       (foo5: String)
       (using
           foo6: Int,
           foo7: Int,
           foo8: Int,
           foo9: Int,
           foo10: Int,
           foo11: Int,
           foo12: Int
       ) // this line also doesn't fit
       : (
           String,
           String,
           String,
           String
       ) = ???
}
<<< #2561 scala 3: call, no align
maxColumn = 25
align.preset = none
runner.dialect = scala3
newlines.beforeOpenParenCallSite = source
newlines.beforeOpenParenDefnSite = source
===
object a {
  // class with no body
  case class fooClass
   (foo1: String)
   (foo2: String,
    foo3: String,
    foo4: Map[
      String,
      Map[String, Map[String, String]]
    ]
   )
   (foo5: String)
  def f = fooFunc("foo1")("foo2")("foo3")("foo4")("foo5")
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2", "foo3", "foo4")
      ("foo5")
      (using "foo6", "foo7", "foo8", "foo9", "foo10", "foo11", "foo12")
}
>>>
object a {
  // class with no body
  case class fooClass
    (foo1: String)
    (
        foo2: String,
        foo3: String,
        foo4: Map[
          String,
          Map[
            String,
            Map[
              String,
              String
            ]
          ]
        ]
    )
    (foo5: String)
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      (
        "foo2",
        "foo3",
        "foo4"
      )
      ("foo5")
      (using
        "foo6",
        "foo7",
        "foo8",
        "foo9",
        "foo10",
        "foo11",
        "foo12"
      )
}
<<< #2561 scala 3: call, align
maxColumn = 25
align.preset = none
align.openParenCallSite = true
runner.dialect = scala3
newlines.beforeOpenParenCallSite = unfold
===
object a {
  def f = fooFunc("foo1")("foo2")("foo3")("foo4")("foo5")
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2", "foo3", "foo4")
      ("foo5")
      (using "foo6", "foo7", "foo8", "foo9", "foo10", "foo11", "foo12")
}
>>>
object a {
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    fooFunc
      ("foo1")
      ("foo2")
      ("foo3")
      ("foo4")
      ("foo5")
  def f =
    notAnInterestingFunction
      ("foo1")
      ("foo2",
       "foo3",
       "foo4"
      )
      ("foo5")
      (using
        "foo6",
        "foo7",
        "foo8",
        "foo9",
        "foo10",
        "foo11",
        "foo12"
      )
}
<<< #2561 enum, single arg, wide
maxColumn = 80
runner.parser = source
runner.dialect = scala3
newlines {
  beforeOpenParenDefnSite = source
  beforeOpenParenCallSite = source
}
===
package dev.muve.vdom

enum Namespace(val uri: String | Null):
   case xhtml extends Namespace("http://www.w3.org/1999/xhtml")
   case xlink extends Namespace("http://www.w3.org/1999/xlink")
   case xmlns extends Namespace("http://www.w3.org/2000/xmlns/")
   case svg extends Namespace("http://www.w3.org/2000/svg")
   case muve extends Namespace("http://dev.muve/2021/muve")

   case none extends Namespace(null)
>>>
package dev.muve.vdom

enum Namespace(val uri: String | Null):
  case xhtml extends Namespace("http://www.w3.org/1999/xhtml")
  case xlink extends Namespace("http://www.w3.org/1999/xlink")
  case xmlns extends Namespace("http://www.w3.org/2000/xmlns/")
  case svg extends Namespace("http://www.w3.org/2000/svg")
  case muve extends Namespace("http://dev.muve/2021/muve")

  case none extends Namespace(null)
<<< #2561 enum, single arg, narrow
maxColumn = 35
runner.parser = source
runner.dialect = scala3
newlines {
  beforeOpenParenDefnSite = source
  beforeOpenParenCallSite = source
  avoidForSimpleOverflow = [punct]
}
===
package dev.muve.vdom

enum Namespace(val uri: String | Null):
   case xhtml extends Namespace("http://www.w3.org/1999/xhtml")
   case xlink extends Namespace("http://www.w3.org/1999/xlink")
   case xmlns extends Namespace("http://www.w3.org/2000/xmlns/")
   case svg extends Namespace("http://www.w3.org/2000/svg")
   case muve extends Namespace("http://dev.muve/2021/muve")

   case none extends Namespace(null)
>>>
package dev.muve.vdom

enum Namespace
  (val uri: String | Null):
  case xhtml
      extends Namespace
        ("http://www.w3.org/1999/xhtml")
  case xlink
      extends Namespace
        ("http://www.w3.org/1999/xlink")
  case xmlns
      extends Namespace
        ("http://www.w3.org/2000/xmlns/")
  case svg
      extends Namespace
        ("http://www.w3.org/2000/svg")
  case muve
      extends Namespace
        ("http://dev.muve/2021/muve")

  case none extends Namespace(null)
<<< #2561 nested apply as parameter
maxColumn = 80
runner.dialect = scala3
newlines.beforeOpenParenCallSite = unfold
===
line
  (x1 := centre - offset * s,
   y1 := centre + offset * c,
   x2 := centre + (length - offset) * s,
   y2 := centre - (length - offset) * c,
   (SvgA.filter := "url(#handShadow)").when(hasShadow),
   strokeWidth := width,
   stroke := colour)
>>>
line
  (
    x1 := centre - offset * s,
    y1 := centre + offset * c,
    x2 := centre + (length - offset) * s,
    y2 := centre - (length - offset) * c,
    (SvgA.filter := "url(#handShadow)").when(hasShadow),
    strokeWidth := width,
    stroke := colour
  )
<<< bracketDefnSite=oneline
maxColumn = 100
binPack.bracketCallSite = oneline
binPack.bracketDefnSite = oneline
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketDefnSite=always
maxColumn = 100
binPack.bracketCallSite = always
binPack.bracketDefnSite = always
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketDefnSite=never
maxColumn = 100
binPack.bracketCallSite = never
binPack.bracketDefnSite = never
===
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
>>>
object a {
  private def getAudiencesWithStatus(statuses: AudienceStatus*): RIO[Blocking, Seq[Audience]] =
    effectBlocking {
      audienceManager.list(InternalAudienceFilter(statuses = Contains(statuses.map(_.name))))
    }
}
<<< bracketCallSite = Oneline in return type, !sometimesBeforeColonInMethodReturnType
maxColumn = 50
binPack.bracketCallSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(bb: BB, cc: CC,
    dd: DD = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      bb: BB,
      cc: CC,
      dd: DD = DDD.ddd
  ): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.xxxSite = Oneline, !sometimesBeforeColonInMethodReturnType
maxColumn = 50
binPack.callSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(bb: BB, cc: CC,
    dd: DD = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(bb: BB, cc: CC, dd: DD = DDD.ddd): Bar[
    Baz
  ] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      dd: DD[AA[BB], CC] = DDD.ddd
  ): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also bracketCallSite
binPack.bracketCallSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = false
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDD.ddd): Bar[Baz] = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      dd: DD[AA[BB], CC] = DDD.ddd
  ): Bar[Baz] = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also align
align.openParenDefnSite = true
optIn.configStyleArguments = false
danglingParentheses.preset = false
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = true
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDDD.dddd) = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      dd: DD[AA[BB], CC] =
        DDDD.dddd) = {
    // c
    qux
  }
}
<<< binPack.defnSite = Oneline, one arg, also bracketCallSite+align
align.openParenDefnSite = true
optIn.configStyleArguments = false
danglingParentheses.preset = false
binPack.bracketCallSite = Oneline
binPack.defnSite = Oneline
newlines.sometimesBeforeColonInMethodReturnType = true
===
object a {
  def foo(dd: DD[AA[BB], CC] = DDDD.dddd) = {
      // c
      qux
    }
}
>>>
object a {
  def foo(
      dd: DD[AA[BB], CC] =
        DDDD.dddd) = {
    // c
    qux
  }
}
<<< bracketCallSite = Oneline, nested with one arg
maxColumn = 100
binPack.bracketCallSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe
    Some(
      Left(
        s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
      )
    )

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](
      apiAudience.copy(status = AudienceStatus.Pending.name)
    )
  )
}
<<< bracketCallSite = always, nested with one arg
maxColumn = 100
binPack.bracketCallSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe
    Some(
      Left(
        s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
      )
    )

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](
      apiAudience.copy(status = AudienceStatus.Pending.name)
    )
  )
}
<<< binPack.callSite = Oneline, nested with one arg
maxColumn = 100
binPack.callSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe
    Some(
      Left(
        s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
      )
    )

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](
      apiAudience.copy(status = AudienceStatus.Pending.name)
    )
  )
}
<<< binPack.callSite = Oneline, nested with one arg, several options
maxColumn = 100
binPack.callSite = Oneline
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
  PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(
    service.list(
      ApiAudienceFilter(tenants = Contains(Seq(ATenant))), Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(
      ApiAudienceFilter(tenants), Contains(Seq(ATenant)), Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))), Page(0, Page.maxPageLimit),
    Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))), Page(0, Page.maxPageLimit),
    Order.default, PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))
  ).thenReturn(None)
}
<<< binPack.callSite = always, nested with one arg
maxColumn = 100
binPack.callSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
    binder.bind("f", params) shouldBe Some(Left(
      s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
    ))


    when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
      Success[NonEmptyList[String], ApiAudience](apiAudience
          .copy(status = AudienceStatus.Pending.name))
    )
}
>>>
object a {
  binder.bind("f", params) shouldBe
    Some(
      Left(
        s"Cannot parse parameter f as DummyEnum, $wrongValue is not a member of Enum (dummy-value)"
      )
    )

  when(audienceService.publish(any[Tenant], any[Int])).thenReturn(
    Success[NonEmptyList[String], ApiAudience](
      apiAudience.copy(status = AudienceStatus.Pending.name)
    )
  )
}
<<< binPack.callSite = always, nested with one arg, several options
maxColumn = 100
binPack.callSite = always
runner.optimizer.forceConfigStyleMinArgCount = 100
===
object a {
  when(service.list(ApiAudienceFilter(tenants = Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant)),
    Page(0, Page.maxPageLimit), Order.default
  )).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))),
    Page(0, Page.maxPageLimit), Order.default,
  PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))).thenReturn(None)
}
>>>
object a {
  when(
    service.list(
      ApiAudienceFilter(tenants = Contains(Seq(ATenant))), Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(
      ApiAudienceFilter(tenants), Contains(Seq(ATenant)), Page(0, Page.maxPageLimit), Order.default
    )
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))), Page(0, Page.maxPageLimit),
    Order.default
  ).thenReturn(PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10)))

  when(
    service.list(ApiAudienceFilter(tenants), Contains(Seq(ATenant))), Page(0, Page.maxPageLimit),
    Order.default, PageResult(Seq(audience, audience.copy(id = 2)), PageInfo(50, 0, 10))
  ).thenReturn(None)
}
<<< #2821 default
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) =>
    D.e
  case _ =>
    E.f
}
<<< #2821 fold
newlines.beforeMultiline = fold
===
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
<<< #2821 unfold
newlines.beforeMultiline = unfold
===
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) => D.e
  case _ => E.f
}
>>>
assembly / assemblyMergeStrategy := {
  case A("B", c @ _*) =>
    D.e
  case _ =>
    E.f
}
<<< TryWithHandler: newline after catch
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch bar
    finally a
}
<<< TryWithHandler: newline after catch, short
maxColumn = 12
===
object a {
  def foo = try
    a
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch
      bar
    finally
      a
}
<<< TryWithHandler: newline after catch, space comment
object a {
  def foo = try
    a
  catch /* c1 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, break comment
object a {
  def foo = try
    a
  catch
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch
      /* c2 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */
    /* c2 */
    bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */
      /* c2 */
      bar
    finally a
}
<<< TryWithHandler: newline after catch, comments
object a {
  def foo = try
    a
  catch /* c1 */ bar
  finally
    a
}
>>>
object a {
  def foo =
    try a
    catch /* c1 */ bar
    finally a
}
<<< #2019 infix
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
===
object a {
  def foo =
    a +
    b
  val foo =
    a +
    b
  var foo =
    a +
    b
}
>>>
object a {
  def foo = {
    a +
      b
  }
  val foo = {
    a +
      b
  }
  var foo = {
    a +
      b
  }
}
<<< #2019 if-else !alwaysBeforeElseAfterCurlyIf
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = {
    if (a) {
      a +
        b
    } else {
      a +
        b
    }
  }
  val foo = {
    if (a) {
      a +
        b
    } else if (b) {
      a +
        b
    } else if (c) {
      a +
        b
    }
  }
  var foo = {
    if (a) {
      a +
        b
    } else {
      a +
        b
    }
  }
}
<<< #2019 if-else alwaysBeforeElseAfterCurlyIf
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = if (a)
    a +
    b
  else
    a +
    b
  val foo = if (a)
    a +
    b
  else if (b)
    a +
    b
  else if (c)
    a +
    b
  var foo = if (a)
    a +
    b
  else
    a +
    b
}
>>>
object a {
  def foo = {
    if (a) {
      a +
        b
    }
    else {
      a +
        b
    }
  }
  val foo = {
    if (a) {
      a +
        b
    }
    else if (b) {
      a +
        b
    }
    else if (c) {
      a +
        b
    }
  }
  var foo = {
    if (a) {
      a +
        b
    }
    else {
      a +
        b
    }
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch
      bar
    finally
      a
  }
}
<<< #2019 try !alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = false
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    } catch {
      bar
    } finally {
      a
    }
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf !allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch
      bar
    finally
      a
  }
}
<<< #2019 try alwaysBeforeElseAfterCurlyIf allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
newlines.alwaysBeforeElseAfterCurlyIf = true
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  def foo = try
    a +
      b
  catch
    bar
  finally
    a
}
>>>
object a {
  def foo = {
    try {
      a +
        b
    }
    catch {
      bar
    }
    finally {
      a
    }
  }
}
<<< #2019 function
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
===
object a {
  foo(x =>
    a +
      b
  )
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
>>>
object a {
  foo(x => {
    a +
      b
  })
  foo(x =>
    a
      + b
  )
  foo { x =>
    a +
      b
  }
}
<<< #2019 partial function
maxColumn = 25
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
===
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
>>>
object a {
  foo { case (x, y) =>
    a +
      b
  }
}
<<< #2019 for-yield !allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-yield allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } yield // c
    a
  for { a <- b } yield // c
    a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } yield { // c
    a
  }
  for {
    a <- b
  } yield { // c
    a +
      b
  }
}
<<< #2019 for-do !allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
}
<<< #2019 for-do allBlocks
maxColumn = 12
newlines.infix.termSite.maxCountPerFile = 0
rewrite.insertBraces.minLines = 2
rewrite.insertBraces.allBlocks = true
===
object a {
  for {
    a <- b
    c <- d
  } // c
    a
  for ( a <- b ) // c
    a +
      b
  for { a <- b } // c
    a +
      b
  for ( a <- b )
    a +
      b
  for { a <- b }
    a +
      b
  for ( a <- b ) a +
      b
  for { a <- b } a +
      b
}
>>>
object a {
  for {
    a <- b
    c <- d
  } { // c
    a
  }
  for (
    a <- b
  ) { // c
    a +
      b
  }
  for {
    a <- b
  } { // c
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
  for (
    a <- b
  ) {
    a +
      b
  }
  for {
    a <- b
  } {
    a +
      b
  }
}
<<< comment in select chain
object a {
  foo
    // c2
    .bar(baz).foo(bar, baz)
  foo // c1
    // c2
    .bar(baz).foo(bar, baz)
  foo.bar(baz) // c1
    // c2
    .foo(bar, baz)
}
>>>
object a {
  foo
    // c2
    .bar(baz)
    .foo(bar, baz)
  foo // c1
    // c2
    .bar(baz)
    .foo(bar, baz)
  foo
    .bar(baz) // c1
    // c2
    .foo(bar, baz)
}
<<< comment in select chain, after dot 1
object a {
  foo.
    // c2
    bar(baz).foo(bar, baz)
  foo. // c1
    // c2
    bar(baz).foo(bar, baz)
  foo.bar(baz) // c1
    . // c2
    foo(bar, baz)
}
>>>
object a {
  foo
    .
    // c2
    bar(baz)
    .foo(bar, baz)
  foo
    . // c1
    // c2
    bar(baz)
    .foo(bar, baz)
  foo
    .bar(baz) // c1
    . // c2
    foo(bar, baz)
}
<<< comment in select chain, after dot 2
object a {
  lazy val `scala3-sbt-bridge` = project.in(file("sbt-bridge/src")).
    // We cannot depend on any bootstrapped project to compile the bridge, since the
    // bridge is needed to compile these projects.
    dependsOn(`scala3-compiler` % Provided).
    settings(commonJavaSettings).
    settings(foo)
}
>>>
object a {
  lazy val `scala3-sbt-bridge` = project
    .in(file("sbt-bridge/src"))
    .
    // We cannot depend on any bootstrapped project to compile the bridge, since the
    // bridge is needed to compile these projects.
    dependsOn(
      `scala3-compiler` % Provided
    )
    .settings(commonJavaSettings)
    .settings(foo)
}
<<< comment in select chain, after dot 3
object a {
  foo. // c1
    bar(baz). // c2
    foo(bar, baz). // c3
    qux
  foo.
    // c1
    bar(baz).
    // c2
    foo(bar, baz).
    // c3
    qux
  foo // c1
    .bar(baz). // c2
    foo(bar, baz). // c3
    qux
  foo
    // c1
    .bar(baz).
    // c2
    foo(bar, baz).
    // c3
    qux
  foo. // c1
    bar(baz) // c2
    .foo(bar, baz). // c2
    qux
  foo.
    // c1
    bar(baz)
    // c2
    .foo(bar, baz).
    // c2
    qux
  foo. // c1
    bar(baz). // c2
    foo(bar, baz) // c3
    .qux
  foo.
    // c1
    bar(baz).
    // c2
    foo(bar, baz)
    // c3
    .qux
}
>>>
object a {
  foo
    . // c1
    bar(baz)
    . // c2
    foo(bar, baz)
    . // c3
    qux
  foo
    .
    // c1
    bar(baz)
    .
    // c2
    foo(bar, baz)
    .
    // c3
    qux
  foo // c1
    .bar(baz)
    . // c2
    foo(bar, baz)
    . // c3
    qux
  foo
    // c1
    .bar(baz)
    .
    // c2
    foo(bar, baz)
    .
    // c3
    qux
  foo
    . // c1
    bar(baz) // c2
    .foo(bar, baz)
    . // c2
    qux
  foo
    .
    // c1
    bar(baz)
    // c2
    .foo(bar, baz)
    .
    // c2
    qux
  foo
    . // c1
    bar(baz)
    . // c2
    foo(bar, baz) // c3
    .qux
  foo
    .
    // c1
    bar(baz)
    .
    // c2
    foo(bar, baz)
    // c3
    .qux
}
<<< break in select chain, after dot 3
maxColumn = 20
===
object a {
  foo.
    bar(baz).
    foo(bar, baz).
    qux
  foo
    .bar(baz).
    foo(bar, baz).
    qux
  foo.
    bar(baz)
    .foo(bar, baz).
    qux
  foo.
    bar(baz).
    foo(bar, baz)
    .qux
}
>>>
object a {
  foo
    .bar(baz)
    .foo(bar, baz)
    .qux
  foo
    .bar(baz)
    .foo(bar, baz)
    .qux
  foo
    .bar(baz)
    .foo(bar, baz)
    .qux
  foo
    .bar(baz)
    .foo(bar, baz)
    .qux
}
<<< try with match expr
object a {
  try ta match {
    case Success(a) => bind(a); case Failure(e) => recover(e)
  } catch { case NonFatal(e) => Failure(e) }
}
>>>
object a {
  try
    ta match {
      case Success(a) =>
        bind(a);
      case Failure(e) =>
        recover(e)
    }
  catch {
    case NonFatal(e) =>
      Failure(e)
  }
}
<<<  if with match expr
object a {
  if (checkCondition()) ta match {
    case Success(a) => bind(a); case Failure(e) => recover(e)
  } else doSomethingOtherwise()
}
>>>
object a {
  if (checkCondition())
    ta match {
      case Success(a) =>
        bind(a);
      case Failure(e) =>
        recover(e)
    }
  else
    doSomethingOtherwise()
}
<<< align.beforeOpenParenDefnSite
maxColumn = 100
align.closeParenSite = true
align.beforeOpenParenDefnSite = true
newlines.beforeOpenParenDefnSite = source
===
def allMatching(versionString: String)
                 (partialFunctions: PartialFunction[options.Common, List[String]]*): List[String] = {

                 }
>>>
def allMatching
  (versionString: String)
  (partialFunctions: PartialFunction[options.Common, List[String]]*)
  : List[String] = {}
<<< align.beforeOpenParenDefnSite + align.openParenDefnSite
maxColumn = 85
danglingParentheses.defnSite = false
align.closeParenSite = true
align.openParenDefnSite = true
align.beforeOpenParenDefnSite = true
newlines.beforeOpenParenDefnSite = source
===
def allMatching(versionString: String, partialFunctions: PartialFunction[options.Common, List[String]]*)
                 (partialFunctions: PartialFunction[options.Common, List[String]]*): List[String] = {

                 }
>>>
def allMatching
  (versionString: String,
   partialFunctions: PartialFunction[options.Common, List[String]]*)
  (partialFunctions: PartialFunction[options.Common, List[String]]*)
  : List[String] = {}
<<< #3173 beforeMultiline = fold
newlines.beforeMultiline = fold
===
class Foo {
  val foo = if (true) {
    ""
  } else {
    "a"
  }
  val foo = if (true)
    ""
  else
    "a"
  val foo = if (true) "" else "a"
  val foo = if (true) "aaaaa" else "bbbbb"
  val foo = if (true) "aaaaa"
  else "bbbbb"
}
>>>
class Foo {
  val foo =
    if (true) {
      ""
    } else {
      "a"
    }
  val foo =
    if (true) ""
    else "a"
  val foo =
    if (true) ""
    else "a"
  val foo =
    if (true) "aaaaa"
    else "bbbbb"
  val foo =
    if (true) "aaaaa"
    else "bbbbb"
}
<<< #3276
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1) {
      true
    } else
      false

  def notOK: Boolean =
    if (1 == 1) {
      println("Some code")
      true
    } else
      false
}
<<< #3276 2
class Foo() {
  def notOK: Boolean =
    if (1 == 1)
      {c; a + b}.foo
    else
      false
}
>>>
class Foo() {
  def notOK: Boolean =
    if (1 == 1) {
      c;
      a + b
    }.foo
    else
      false
}
<<< #3276 4
class Foo() {
  def notOK: Boolean =
    try {c; a + b}.foo
    finally {c; a + b}.foo
}
>>>
class Foo() {
  def notOK: Boolean =
    try
      {
        c;
        a + b
      }.foo
    finally
      {
        c;
        a + b
      }.foo
}
<<< #3271
newlines.forceBeforeAssign = def
===
def sum(a: Int, b: Int): Int =
  a + b
>>>
def sum(a: Int, b: Int): Int =
  a + b
<<< #3295 1
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
>>>
class Foo() {
  def ok: Boolean =
    if (1 == 1)
      true
    else {
      false
    }

  def notOK: Boolean =
    if (1 == 1)
      true
    else {
      println("Some code")
      false
    }
}
<<< #3327 match
indent.relativeToLhsLastLine = [match]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ match /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ match /* c2 */ {
          case Some(Row(value: Long)) =>
            value
          case _ =>
            0
        }
    }
}
<<< #3327 infix
indent.relativeToLhsLastLine = [infix]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
            case Some(
                  Row(value: Long)
                ) =>
              value
            case _ =>
              0
          }
    }
}
<<< #3327 infix 2
indent.relativeToLhsLastLine = [infix]
===
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        } /* c3 */ infix /* c4 */ {
          case Some(Row(value: Long)) => value
          case _                      => 0
        }
    }
}
>>>
object A {
  private def get(ds: Any): IO[Long] =
    IO.delay {
      ds // c1
        .headOption /* c1 */ infix /* c2 */ {
            case Some(
                  Row(value: Long)
                ) =>
              value
            case _ =>
              0
          } /* c3 */ infix /* c4 */ {
            case Some(
                  Row(value: Long)
                ) =>
              value
            case _ =>
              0
          }
    }
}
<<< #3369 always
binPack.defnSite = always
===
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[CommittableOffsetBatch],
      TestOffsetFactory) = {
    val (source, control, sink) = streamProbes(committerSettings)
    val factory = TestOffsetFactory(new TestBatchCommitter(committerSettings))
    (source, control, sink, factory)
  }
}
>>>
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (
      TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[
        CommittableOffsetBatch
      ], TestOffsetFactory
  ) = {
    val (source, control, sink) =
      streamProbes(committerSettings)
    val factory = TestOffsetFactory(
      new TestBatchCommitter(
        committerSettings
      )
    )
    (source, control, sink, factory)
  }
}
<<< #3369 always, source folded
binPack.defnSite = always
===
object Test {
  private def
    streamProbesWithOffsetFactory(committerSettings: CommitterSettings):
      (TestPublisher.Probe[Committable], Consumer.Control, TestSubscriber.Probe[CommittableOffsetBatch], TestOffsetFactory) = {
    val (source, control, sink) = streamProbes(committerSettings)
    val factory = TestOffsetFactory(new TestBatchCommitter(committerSettings))
    (source, control, sink, factory)
  }
}
>>>
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (
      TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[
        CommittableOffsetBatch
      ], TestOffsetFactory
  ) = {
    val (source, control, sink) =
      streamProbes(committerSettings)
    val factory = TestOffsetFactory(
      new TestBatchCommitter(
        committerSettings
      )
    )
    (source, control, sink, factory)
  }
}
<<< #3369 oneline
binPack.defnSite = oneline
===
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[CommittableOffsetBatch],
      TestOffsetFactory) = {
    val (source, control, sink) = streamProbes(committerSettings)
    val factory = TestOffsetFactory(new TestBatchCommitter(committerSettings))
    (source, control, sink, factory)
  }
}
>>>
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (
      TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[
        CommittableOffsetBatch
      ],
      TestOffsetFactory
  ) = {
    val (source, control, sink) =
      streamProbes(committerSettings)
    val factory = TestOffsetFactory(
      new TestBatchCommitter(
        committerSettings
      )
    )
    (source, control, sink, factory)
  }
}
<<< #3369 oneline, source folded
binPack.defnSite = oneline
===
object Test {
  private def
    streamProbesWithOffsetFactory(committerSettings: CommitterSettings):
      (TestPublisher.Probe[Committable], Consumer.Control, TestSubscriber.Probe[CommittableOffsetBatch], TestOffsetFactory) = {
    val (source, control, sink) = streamProbes(committerSettings)
    val factory = TestOffsetFactory(new TestBatchCommitter(committerSettings))
    (source, control, sink, factory)
  }
}
>>>
object Test {
  private def streamProbesWithOffsetFactory(
      committerSettings: CommitterSettings
  ): (
      TestPublisher.Probe[Committable],
      Consumer.Control,
      TestSubscriber.Probe[
        CommittableOffsetBatch
      ],
      TestOffsetFactory
  ) = {
    val (source, control, sink) =
      streamProbes(committerSettings)
    val factory = TestOffsetFactory(
      new TestBatchCommitter(
        committerSettings
      )
    )
    (source, control, sink, factory)
  }
}
<<< SM 4.7.0: 1
object a {
  @volatile private var _foo: Bar =
    _ // This must be volatile since it isn't protected by the mailbox status
}
>>>
object a {
  @volatile
  private var _foo: Bar =
    _ // This must be volatile since it isn't protected by the mailbox status
}
<<< SM 4.7.0: 2
object a {
  private[this] var _mailboxDoNotCallMeDirectly
      : Bar =
    _
}
>>>
object a {
  private[this] var _mailboxDoNotCallMeDirectly
      : Bar = _
}
<<< SM 4.7.0: 3
object a {
  if ((a > b && c > 0)) {
    true // Allow messages larger than capacity through, it will be recorded as negative tokens
  }
}
>>>
object a {
  if ((a > b && c > 0)) {
    true // Allow messages larger than capacity through, it will be recorded as negative tokens
  }
}
<<< SM 4.7.0: 4
object a {
  (
    registry ⇒
      Props(classOf[TcpOutgoingConnection], tcp, registry, commander, c)
  )
}
>>>
object a {
  (
      registry ⇒
        Props(
          classOf[
            TcpOutgoingConnection
          ],
          tcp,
          registry,
          commander,
          c
        )
  )
}
<<< SM 4.7.0: 5
object a {
  ((
    server,
    serverSet.join(
      server.address,
      Map[String, InetSocketAddress](),
      shardId)))
}
>>>
object a {
  (
    (
      server,
      serverSet.join(
        server.address,
        Map[
          String,
          InetSocketAddress
        ](),
        shardId
      )
    )
  )
}
<<< SM 4.7.0: 6
object a {
  val expected = Map(
    "foos" -> ((
      "xyz",
      "1"
    )), // the "cas unique" values are predictable from a fresh memcached
    a -> b)
}
>>>
object a {
  val expected = Map(
    "foos" -> (
      ("xyz", "1")
    ), // the "cas unique" values are predictable from a fresh memcached
    a -> b
  )
}
<<< SM 4.7.0: 7
maxColumn = 100
===
object a {
  foo match {
    case f: Float if f == 42f => (<float>perfect</float>: Elem)
    case f: Float if f == 0f  => (<float>zero</float>: Node)
    case f: Float if f > 0f   => (<float>positive</float>: NodeSeq)
    case f: Float if f < 0f   => (<float>negative</float>: Seq[Node])
  }
}
>>>
object a {
  foo match {
    case f: Float if f == 42f => (<float>perfect</float>: Elem)
    case f: Float if f == 0f => (<float>zero</float>: Node)
    case f: Float if f > 0f => (<float>positive</float>: NodeSeq)
    case f: Float if f < 0f => (<float>negative</float>: Seq[Node])
  }
}
<<< SM 4.7.0: 8
maxColumn = 80
===
foo match {
      case (exp: ScReferenceExpression) childOf ((_: ScGenericCall) childOf (_: ScMethodCall)) =>
}
>>>
foo match {
  case (exp: ScReferenceExpression) childOf
      ((_: ScGenericCall) childOf (_: ScMethodCall)) =>
}
<<< SM 4.7.0: 9
maxColumn = 100
===
object a {
    val ui = LiftRules.jsArtifacts
    (<span>{
      rs % ("onclick" -> (ui.hide(sid).cmd &
        ui.showAndFocus(hid).cmd & JsRaw("return false;")))
    }</span>)
}
>>>
object a {
  val ui = LiftRules.jsArtifacts
  (
    <span>{
      rs % ("onclick" -> (ui.hide(sid).cmd & ui.showAndFocus(hid).cmd & JsRaw("return false;")))
    }</span>
  )
}
<<< SM 4.7.0: 10
object a {
  XhtmlResponse(
    (<html> <body>Exception occured while processing {r.uri}<pre>{
      showException(e)
    }</pre> </body> </html>),
    foo
  )
}
>>>
object a {
  XhtmlResponse(
    (
      <html> <body>Exception occured while processing {
        r.uri
      }<pre>{
        showException(e)
      }</pre> </body> </html>
    ),
    foo
  )
}
<<< SM 4.7.0: 11
foo match {
    case ScWhileStmt(
          Some(
            ScInfixExpr(
              (ref: ScReferenceExpression) && (ResolvesTo(
                target @ Parent(Parent(entity: ScVariable))
              )),
              ElementText(operator),
              _
            )
          ),
          Some(body)
        ) =>
}
>>>
foo match {
  case ScWhileStmt(
        Some(
          ScInfixExpr(
            (
              ref: ScReferenceExpression
            ) && (
              ResolvesTo(
                target @ Parent(
                  Parent(
                    entity: ScVariable
                  )
                )
              )
            ),
            ElementText(operator),
            _
          )
        ),
        Some(body)
      ) =>
}
<<< SM 4.7.0: 12
object a {
  case class MaxReusableBufferSize(maxReusableBufferSize: Int)
  implicit
  object MaxReusableBufferSize extends Stack.Param[MaxReusableBufferSize] {
  }
}
>>>
object a {
  case class MaxReusableBufferSize(
      maxReusableBufferSize: Int
  )
  implicit object MaxReusableBufferSize
      extends Stack.Param[
        MaxReusableBufferSize
      ] {}
}
<<< SM 4.7.0: 13
runner.parser = source
===
/*ref*/be()
/*
import scala.collection.immutable

immutable.HashSet
*/
>>>
/*ref*/
be()
/*
import scala.collection.immutable

immutable.HashSet
 */
<<< SM 4.7.0: 14
maxColumn = 100
===
object a {
 foldedTopics + shortStringLength(topic) + 4 + /* partition count */
   partitionFetchInfos.size *
   (4 + /* partition id */
     8 + /* offset */
     4 /* fetch size */
   )
}
>>>
object a {
  foldedTopics + shortStringLength(topic) + 4 + /* partition count */
    partitionFetchInfos.size * (
      4 + /* partition id */
        8 + /* offset */
        4 /* fetch size */
    )
}
<<< SM 4.7.0: 15
class a {
  def this(x: Int) {
    this()
    class Q
    trait R
    object S
    new T {}
    (() => () => "5")
  }
}
>>>
class a {
  def this(x: Int) {
    this()
    class Q
    trait R
    object S
    new T {}
    (() => () => "5")
  }
}
<<< SM 4.7.0: 16
maxColumn = 80
===
object a {
  jID =
    new SerializableWritable[JobID](SparkHadoopWriter.createJobID(now, jobid))
}
>>>
object a {
  jID =
    new SerializableWritable[JobID](SparkHadoopWriter.createJobID(now, jobid))
}
<<< SM 4.7.0: 17
object a {
  info(
    "ZKConsumerConnector shutdown completed in " +
     (System.nanoTime() - startTime) / 1000000 + " ms"
  )
}
>>>
object a {
  info(
    "ZKConsumerConnector shutdown completed in " +
      (System.nanoTime() - startTime) /
      1000000 + " ms"
  )
}
<<< SM 4.7.0: 18
maxColumn = 80
===
object a {
  @(SourceAnnotation @getter)("http://apple.com")
  val x = 0
}
>>>
object a {
  @(SourceAnnotation @getter)("http://apple.com")
  val x = 0
}
<<< SM 4.7.0: 19
maxColumn = 80
===
object a {
  val d = foo.< ref > pal (42) ("abc")
}
>>>
object a {
  val d = foo.< ref > pal (42)("abc")
}
<<< SM 4.7.0: 20
maxColumn = 80
===
object a {
  def step: (Input[I] => IterateeT[I, F, A]) => (
    Input[O] => IterateeT[O, F, StepT[I, F, A]]
  ) = ???
}
>>>
object a {
  def step: (Input[I] => IterateeT[I, F, A]) => (
      Input[O] => IterateeT[O, F, StepT[I, F, A]]
  ) = ???
}
<<< SM 4.7.0: 21
maxColumn = 50
===
object a {
  avgMem.add(
    heapUsed.used / nrOfActors
  ) // average actor size, over nrOfRepeats
}
>>>
object a {
  avgMem.add(
    heapUsed.used / nrOfActors
  ) // average actor size, over nrOfRepeats
}
<<< SM 4.7.0: 22
maxColumn = 60
===
object CapabilityFlag {
  def on(): CapabilityFlag =
    new CapabilityFlag { override def value = true }
}
>>>
object CapabilityFlag {
  def on(): CapabilityFlag =
    new CapabilityFlag {
      override def value = true
    }
}
<<< SM 4.7.0: 23
val boss = system.actorOf(Props(new Supervisor(
  OneForOneStrategy()(List(classOf[Exception]))
)))
>>>
val boss = system.actorOf(
  Props(
    new Supervisor(
      OneForOneStrategy()(
        List(classOf[Exception])
      )
    )
  )
)
<<< SM 4.7.0: 24.1
maxColumn = 80
optIn.annotationNewlines = true
===
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
>>>
def using(
    @foo
    @bar('nextStateDate)
    nextStateData: D
): State[S, D] = {
  copy(stateData = nextStateData)
}
<<< SM 4.7.0: 24.2
maxColumn = 80
optIn.annotationNewlines = false
===
def using(@foo @bar('nextStateDate) nextStateData: D): State[S, D] = {
  copy(stateData = nextStateData)
}
>>>
def using(
    @foo @bar('nextStateDate)
    nextStateData: D
): State[S, D] = {
  copy(stateData = nextStateData)
}
<<< SM 4.7.0: 25
maxColumn = 80
===
if (
  settings.fuzzingMode && !system.settings.config.hasPath(
    "akka.stream.secret-test-fuzzing-warning-disable"
  )
) {
  //
}
>>>
if (
  settings.fuzzingMode &&
  !system
    .settings
    .config
    .hasPath("akka.stream.secret-test-fuzzing-warning-disable")
) {
  //
}
<<< SM 4.7.0: 26
maxColumn = 80
===
assert((-9223372036854775807L - 1L ==
  (bytesToInt64(ba(0), ba(1), ba(2), ba(3), ba(4), ba(5), ba(6), ba(7)))))
>>>
assert(
  (
    -9223372036854775807L - 1L ==
      (bytesToInt64(ba(0), ba(1), ba(2), ba(3), ba(4), ba(5), ba(6), ba(7)))
  )
)
<<< SM 4.7.0: 27
maxColumn = 80
===
object a {
  sb.append((if (msb < 10) ('0' + msb).asInstanceOf[Char]
             else ('a' + (msb - 10)).asInstanceOf[Char]))
  sb.append((if (lsb < 10) ('0' + lsb).asInstanceOf[Char]
             else ('a' + (lsb - 10)).asInstanceOf[Char]))
}
>>>
object a {
  sb.append(
    (
      if (msb < 10)
        ('0' + msb).asInstanceOf[Char]
      else
        ('a' + (msb - 10)).asInstanceOf[Char]
    )
  )
  sb.append(
    (
      if (lsb < 10)
        ('0' + lsb).asInstanceOf[Char]
      else
        ('a' + (lsb - 10)).asInstanceOf[Char]
    )
  )
}
<<< SM 4.7.0: 28
maxColumn = 80
===
object a {
  val pebblesAndBammBammsParents = Person.findAll(("childId" ->
    ("$in" -> List(pebblesId, bammbammId))))
}
>>>
object a {
  val pebblesAndBammBammsParents = Person.findAll(
    ("childId" -> ("$in" -> List(pebblesId, bammbammId)))
  )
}
<<< SM 4.7.0: 29.1
maxColumn = 75
===
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldContent = None,
        newContent = None,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        oldPath = null,
        newPath = null,
        oldIsImage = false,
        newIsImage = newIsImage,
        oldContent = None,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        oldObjectId = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooSmall = false,
        tooLarge = false
      )
    }
  ))
}
>>>
object a {
  buffer.append(
    (
      if (!fetchContent) {
        DiffInfo(
          changeType = ChangeType.ADD,
          oldPath = null,
          newPath = null,
          oldContent = None,
          newContent = None,
          oldIsImage = false,
          newIsImage = newIsImage,
          oldObjectId = None,
          newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
          tooSmall = false,
          tooLarge = false
        )
      } else {
        DiffInfo(
          changeType = ChangeType.ADD,
          oldPath = null,
          newPath = null,
          oldIsImage = false,
          newIsImage = newIsImage,
          oldContent = None,
          newContent = JGitUtil
            .getContentFromId(git, treeWalk.getObjectId(0), false)
            .filter(FileUtil.isText)
            .map(convertFromByteArray),
          oldObjectId = None,
          newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
          tooSmall = false,
          tooLarge = false
        )
      }
    )
  )
}
<<< SM 4.7.0: 29.2
maxColumn = 75
===
object a {
  buffer.append((
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  ))
}
>>>
object a {
  buffer.append(
    (
      if (!fetchContent) {
        DiffInfo(
          changeType = ChangeType.ADD,
          newContent = None,
          newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
          tooLarge = false
        )
      } else {
        DiffInfo(
          changeType = ChangeType.ADD,
          newContent = JGitUtil
            .getContentFromId(git, treeWalk.getObjectId(0), false)
            .filter(FileUtil.isText)
            .map(convertFromByteArray),
          newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
          tooLarge = false
        )
      }
    )
  )
}
<<< SM 4.7.0: 29.3
maxColumn = 75
===
object a {
  buffer.append(
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText).map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  )
}
>>>
object a {
  buffer.append(
    if (!fetchContent) {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = None,
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    } else {
      DiffInfo(
        changeType = ChangeType.ADD,
        newContent = JGitUtil
          .getContentFromId(git, treeWalk.getObjectId(0), false)
          .filter(FileUtil.isText)
          .map(convertFromByteArray),
        newObjectId = Option(treeWalk.getObjectId(0)).map(_.name),
        tooLarge = false
      )
    }
  )
}
<<< SM 7.4.0: 30
maxColumn = 80
===
object Test { (tree: Tree) =>
  tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
(tree: Tree) => tree match { case LetL(CharLit) => ??? }
}
>>>
object Test {
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
  (tree: Tree) =>
    tree match {
      case LetL(CharLit) =>
        ???
    }
}
<<< SM 7.4.0: 31
maxColumn = 80
===
object a {
  licenses +=
    (
      "BSD New",
      url("https://github.com/scala-js/scala-js/blob/master/LICENSE")
    )
}
>>>
object a {
  licenses +=
    ("BSD New", url("https://github.com/scala-js/scala-js/blob/master/LICENSE"))
}
<<< SM 7.4.0: 32
maxColumn = 80
===
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
          AnyMimeType -> (XJsonStream, XJsonStream),
          OctetStream -> (XJsonStream, OctetStream)
        )).toMap
}
>>>
object a {
  val acceptableMimeTypes = (
    (
      Seq(ApplicationJson, XJsonStream, TextCSV).map { mt =>
        mt -> (mt, mt)
      }
    ) ++
      Seq(
        AnyMimeType -> (XJsonStream, XJsonStream),
        OctetStream -> (XJsonStream, OctetStream)
      )
  ).toMap
}
<<< SM 7.4.0: 33
maxColumn = 80
===
object a {
  val acceptableMimeTypes =
    ((Seq(ApplicationJson, XJsonStream, TextCSV)
      .map { mt => mt -> (mt, mt) }) ++ Seq(
          AnyMimeType -> (XJsonStream, XJsonStream),
          OctetStream -> (XJsonStream, OctetStream)
        )).toMap
}
>>>
object a {
  val acceptableMimeTypes = (
    (
      Seq(ApplicationJson, XJsonStream, TextCSV).map { mt =>
        mt -> (mt, mt)
      }
    ) ++
      Seq(
        AnyMimeType -> (XJsonStream, XJsonStream),
        OctetStream -> (XJsonStream, OctetStream)
      )
  ).toMap
}
<<< SM 7.4.0: 34.1
maxColumn = 80
===
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"), tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
>>>
object a {
  val default =
    methodSym newValueParameter
      (newTermName("default"), tree.pos.focus, SYNTHETIC) setInfo
      functionType(List(A1.tpe), B1.tpe)
}
<<< SM 7.4.0: 34.2
maxColumn = 60
===
object a {
  val default = methodSym newValueParameter
    (
      newTermName("default"), tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
>>>
object a {
  val default =
    methodSym newValueParameter (
      newTermName("default"),
      tree.pos.focus,
      SYNTHETIC
    ) setInfo functionType(List(A1.tpe), B1.tpe)
}
<<< SM 7.4.0: 35
maxColumn = 76
===
object a {
  ECNotUsed(ec =>
    f.onFailure({ case _ =>
      fail("onFailure should not have been called")
    })(ec)
  )
}
>>>
object a {
  ECNotUsed(ec =>
    f.onFailure({ case _ =>
      fail("onFailure should not have been called")
    })(ec)
  )
}
<<< SM 7.4.0: 36
maxColumn = 76
===
object a {
  foo match {
    case _ => buildConditions(
        names.tail,
        ((
          node: AbstractTestProxy
        ) => node.getName == names.head && !node.isLeaf) :: acc
    )
  }
}
>>>
object a {
  foo match {
    case _ =>
      buildConditions(
        names.tail,
        (
            (node: AbstractTestProxy) =>
              node.getName == names.head && !node.isLeaf
        ) :: acc
      )
  }
}
<<< SM 7.4.0: 37
maxColumn = 76
===
object a {
  var sessionCheckFuncs
      : List[(Map[String, SessionInfo], SessionInfo => Unit) => Unit] =
    (
        (
            ses: Map[String, SessionInfo],
            destroyer: SessionInfo => Unit
        ) => {
          foo
        }
    ) :: Nil
}
>>>
object a {
  var sessionCheckFuncs
      : List[(Map[String, SessionInfo], SessionInfo => Unit) => Unit] =
    (
        (ses: Map[String, SessionInfo], destroyer: SessionInfo => Unit) => {
          foo
        }
    ) :: Nil
}
<<< SM 7.4.0: 38
maxColumn = 76
===
object a {
  private def test_sort_on_comparables[T <: AnyRef with Comparable[
    T
  ]: ClassTag](
      factory: ListFactory,
      toElem: Int => T,
      absoluteOrder: Boolean = true
  ): Unit = {
    foo
  }
}
>>>
object a {
  private def test_sort_on_comparables[T <: AnyRef with Comparable[
    T
  ]: ClassTag](
      factory: ListFactory,
      toElem: Int => T,
      absoluteOrder: Boolean = true
  ): Unit = {
    foo
  }
}
<<< SM 7.4.0: 39
maxColumn = 76
===
object a {
  def curried: T1 => T2 => T3 => T4 => T5 => T6 => R = { (x1: T1) =>
    (
        (
            x2: T2,
            x3: T3,
            x4: T4,
            x5: T5,
            x6: T6
        ) => self.apply(x1, x2, x3, x4, x5, x6)
    ).curried
  }
}
>>>
object a {
  def curried: T1 => T2 => T3 => T4 => T5 => T6 => R = { (x1: T1) =>
    (
        (x2: T2, x3: T3, x4: T4, x5: T5, x6: T6) =>
          self.apply(x1, x2, x3, x4, x5, x6)
    ).curried
  }
}
<<< SM 7.4.0: 40.1
maxColumn = 76
===
object a {
  override def !(message: Any)(implicit
      sender: ActorRef = Actor.noSender
  ): Unit = ()
}
>>>
object a {
  override def !(message: Any)(implicit
      sender: ActorRef = Actor.noSender
  ): Unit = ()
}
<<< SM 7.4.0: 40.1
maxColumn = 76
===
object a {
  implicit def convertToScala[J](j: J)(implicit
      mapping: J2SMapping[J]
  ): mapping.S = mapping.toScala(j)
}
>>>
object a {
  implicit def convertToScala[J](j: J)(implicit
      mapping: J2SMapping[J]
  ): mapping.S = mapping.toScala(j)
}
<<< SM 7.4.0: 41
maxColumn = 76
===
object a {
    (
        (a: A) => {
          class N extends M[a.C] {
            def m(x: a.C) = true
          }
          new N: M[Null]
        }
    ).apply(a).m(null) // NPE, missing bridge
}
>>>
object a {
  (
      (a: A) => {
        class N extends M[a.C] {
          def m(x: a.C) = true
        }
        new N: M[Null]
      }
  ).apply(a).m(null) // NPE, missing bridge
}
<<< SM 7.4.0: 42.1
maxColumn = 76
===
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S]): Result[S]
}
>>>
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S]): Result[S]
}
<<< SM 7.4.0: 42.2
maxColumn = 76
===
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](f: T => Result[S], foo: String): Result[S]
}
>>>
object a {
  def flatMap[S <: RBound[S], RContainer[x <: RBound[x]], RBound[_], Result[
      x <: RBound[x]
  ] <: Monad[x, RContainer, RBound]](
      f: T => Result[S],
      foo: String
  ): Result[S]
}
<<< SM 7.4.0: 42.3
maxColumn = 76
===
object a {
  def span[a, s <: Seq[
    a
  ] { type MyType /*look ma, no type parameters!*/ <: s }](xs: s): s = xs f
}
>>>
object a {
  def span[
      a,
      s <: Seq[a] {
        type MyType /*look ma, no type parameters!*/ <: s
      }
  ](xs: s): s = xs f
}
<<< SM 7.4.0: 43
maxColumn = 76
===
object a {
    assert(
      t21 ==
        (
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21
        )
    )
}
>>>
object a {
  assert(
    t21 == (
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
      21
    )
  )
}
<<< SM 7.4.0: 44
maxColumn = 76
===
object a {
  private val capturedStack =
    (new Throwable().getStackTrace)
      .filter(_.getMethodName.startsWith("supports"))
      .find { el ⇒
        val clazz = Class.forName(el.getClassName)
        clazz
          .getDeclaredMethod(el.getMethodName)
          .getReturnType == classOf[CapabilityFlag]
      } map { _.getMethodName } getOrElse "[unknown]"
}
>>>
object a {
  private val capturedStack =
    (new Throwable().getStackTrace)
      .filter(_.getMethodName.startsWith("supports"))
      .find { el ⇒
        val clazz = Class.forName(el.getClassName)
        clazz.getDeclaredMethod(el.getMethodName).getReturnType ==
          classOf[CapabilityFlag]
      } map {
      _.getMethodName
    } getOrElse "[unknown]"
}
<<< SM 7.4.0: 45
maxColumn = 76
===
object a {
  protected override def newAppended[B >: A](
      that: GenTraversable[B]
  ): Transformed[B] = new { val rest = that } with AbstractTransformed[B]
    with Appended[B]
}
>>>
object a {
  protected override def newAppended[B >: A](
      that: GenTraversable[B]
  ): Transformed[B] =
    new {
      val rest = that
    } with AbstractTransformed[B] with Appended[B]
}
<<< SM 7.4.0: 46
maxColumn = 76
===
object a {
  slice match {
    case (xs, from, until) ⇒
      likeVector(xs)({ _.drop(from).take(until - from) })
  }
}
>>>
object a {
  slice match {
    case (xs, from, until) ⇒
      likeVector(xs)({
        _.drop(from).take(until - from)
      })
  }
}
<<< SM 7.4.0: 47.1
maxColumn = 76
===
class a {
  def this(settings: Settings, eventStream: EventStream) = this(() ⇒
    eventStream.logLevel
  )
}
>>>
class a {
  def this(settings: Settings, eventStream: EventStream) = this(() ⇒
    eventStream.logLevel
  )
}
<<< SM 7.4.0: 47.2
maxColumn = 76
===
class a {
  def thiz(settings: Settings, eventStream: EventStream) = thiz(() ⇒
    eventStream.logLevel
  )
}
>>>
class a {
  def thiz(settings: Settings, eventStream: EventStream) = thiz(() ⇒
    eventStream.logLevel
  )
}
<<< SM 7.4.0: 48
maxColumn = 76
===
class a {
  val ipv4: immutable.Seq[Inet4Address] = addresses
    .collect({ case a: Inet4Address ⇒ a })(breakOut)
}
>>>
class a {
  val ipv4: immutable.Seq[Inet4Address] =
    addresses.collect({ case a: Inet4Address ⇒
      a
    })(breakOut)
}
<<< SM 7.4.0: 49
maxColumn = 76
===
class a {
  def this(
    trapExit: Array[Class[_ <: Throwable]],
    maxNrOfRetries: Int,
    withinTimeRange: Int
  ) = this(
    trapExit.toList,
    if (maxNrOfRetries < 0) None else Some(maxNrOfRetries),
    if (withinTimeRange < 0) None else Some(withinTimeRange)
  )
}
>>>
class a {
  def this(
      trapExit: Array[Class[_ <: Throwable]],
      maxNrOfRetries: Int,
      withinTimeRange: Int
  ) = this(
    trapExit.toList,
    if (maxNrOfRetries < 0)
      None
    else
      Some(maxNrOfRetries),
    if (withinTimeRange < 0)
      None
    else
      Some(withinTimeRange)
  )
}
<<< SM 7.4.0: 50
maxColumn = 70
===
class a {
  def step(
      inner: Iteratee[E, A]
  )(in: Input[E]): Iteratee[E, Iteratee[E, A]] = in match {
    case Input.El(e) => Iteratee.flatten(
        Future(p(e))(pec).map(b =>
          if (b) Done(inner, in)
          else stepNoBreak(inner)(in)
        )(dec)
      )
    case _ => stepNoBreak(inner)(in)
  }
}
>>>
class a {
  def step(
      inner: Iteratee[E, A]
  )(in: Input[E]): Iteratee[E, Iteratee[E, A]] =
    in match {
      case Input.El(e) =>
        Iteratee.flatten(
          Future(p(e))(pec).map(b =>
            if (b)
              Done(inner, in)
            else
              stepNoBreak(inner)(in)
          )(dec)
        )
      case _ =>
        stepNoBreak(inner)(in)
    }
}
<<< SM 7.4.0: 51
maxColumn = 76
===
class a {
  atPos(body.pos)(casegen.one(substitution(
    body
  ))) // since SubstOnly treemakers are dropped, need to do it here
}
>>>
class a {
  atPos(body.pos)(
    casegen.one(substitution(body))
  ) // since SubstOnly treemakers are dropped, need to do it here
}
<<< SM 7.4.0: 52
maxColumn = 76
===
class a {
  val o2 =
    v1.changes
      .register(Witness({ i =>
        result = result * i * i
      })) // result = 2 * 2 * 2 = 8
}
>>>
class a {
  val o2 = v1
    .changes
    .register(
      Witness({ i =>
        result = result * i * i
      })
    ) // result = 2 * 2 * 2 = 8
}
<<< SM 7.4.0: 53
maxColumn = 76
===
object a {
  def toJsCmd = """var x=document.getElementById(""" + select.encJs + """);
    if (x) {
    while (x.length > 0) {x.remove(0);}
    var y = null;
  """ + opts.map { case (value, text) =>
    "y=document.createElement('option'); " + "y.text = " + text.encJs + "; " +
      "y.value = " + value.encJs + "; " +
      (if (Full(value) == dflt) "y.selected = true; " else "") +
      " try {x.add(y, null);} catch(e) {if (typeof(e) == 'object' && typeof(e.number) == 'number' && (e.number & 0xFFFF) == 5){ x.add(y,x.options.length); } } "
  }
}
>>>
object a {
  def toJsCmd =
    """var x=document.getElementById(""" + select.encJs + """);
    if (x) {
    while (x.length > 0) {x.remove(0);}
    var y = null;
  """ +
      opts.map { case (value, text) =>
        "y=document.createElement('option'); " + "y.text = " + text.encJs +
          "; " + "y.value = " + value.encJs + "; " + (
            if (Full(value) == dflt)
              "y.selected = true; "
            else
              ""
          ) +
          " try {x.add(y, null);} catch(e) {if (typeof(e) == 'object' && typeof(e.number) == 'number' && (e.number & 0xFFFF) == 5){ x.add(y,x.options.length); } } "
      }
}
<<< binPack.callSite with configStyle, danglingParentheses
newlines.configStyleCallSite.prefer = true
danglingParentheses.callSite = true
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar0 = foo0(
    1, 2, 3 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar0 = foo0(1, 2, 3 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar2 = foo2(
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10 + 0
  )
}
<<< binPack.defnSite with configStyle, danglingParentheses
newlines.configStyleDefnSite.prefer = true
danglingParentheses.defnSite = true
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo2(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
  def foo3(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
}
<<< binPack.callSite with !configStyle, danglingParentheses
newlines.configStyleCallSite.prefer = false
danglingParentheses.callSite = true
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar0 = foo0(
    1, 2, 3 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar0 = foo0(1, 2, 3 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar1 = foo1(
    10000, 10001, 10002 + 0
  )
  val bar2 = foo2(
    0, 1, 2, 3, 4, 5, 6, 7, 8,
    9, 10 + 0
  )
}
<<< binPack.defnSite with !configStyle, danglingParentheses
newlines.configStyleDefnSite.prefer = false
danglingParentheses.defnSite = true
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*
  ): Set[Int]
  def foo2(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*
  ): Set[Int]
  def foo3(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*
  ): Set[Int]
}
<<< binPack.callSite with configStyle, !danglingParentheses
newlines.configStyleCallSite.prefer = true
danglingParentheses.callSite = false
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar0 = foo0(
    1, 2, 3 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar0 = foo0(1, 2, 3 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10 + 0
  )
}
<<< binPack.defnSite with configStyle, !danglingParentheses
newlines.configStyleDefnSite.prefer = true
danglingParentheses.defnSite = false
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo2(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
  def foo3(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
}
<<< binPack.callSite with !configStyle, !danglingParentheses
newlines.configStyleCallSite.prefer = false
danglingParentheses.callSite = false
binPack.unsafeCallSite = always
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar0 = foo0(
    1, 2, 3 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar0 = foo0(1, 2, 3 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar1 = foo1(
    10000, 10001, 10002 + 0)
  val bar2 = foo2(
    0, 1, 2, 3, 4, 5, 6, 7, 8,
    9, 10 + 0)
}
<<< binPack.defnSite with !configStyle, !danglingParentheses
newlines.configStyleDefnSite.prefer = false
danglingParentheses.defnSite = false
binPack.unsafeDefnSite = always
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
      x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo2(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*): Set[Int]
  def foo3(
      x1: X, x2: X, x3: X,
      x4: X, xs: X*): Set[Int]
}
<<< binPack.callSite with configStyle, !danglingParentheses, ind=2/4
newlines.configStyleCallSite.prefer = true
danglingParentheses.callSite = false
binPack.callSite = always
indent.callSite = 2
indent.binPackCallSite = 4
maxColumn = 30
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10 + 0
  )
}
<<< binPack.defnSite with configStyle, !danglingParentheses, ind=4/6
newlines.configStyleDefnSite.prefer = true
danglingParentheses.defnSite = false
binPack.defnSite = always
indent.defnSite = 4
indent.binPackDefnSite = 6
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo2(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
  def foo3(
      x1: X,
      x2: X,
      x3: X,
      x4: X,
      xs: X*
  ): Set[Int]
}
<<< binPack.callSite with !configStyle, !danglingParentheses, ind=2/4
newlines.configStyleCallSite.prefer = false
danglingParentheses.callSite = false
binPack.callSite = always
indent.callSite = 2
indent.binPackCallSite = 4
maxColumn = 32
runner.optimizer.callSite { minSpan = 20, minCount = 5 }
===
object Main {
  val bar1 = foo1(
    10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(10000,
    10001, 10002 + 0)
  val bar1 = foo1(10000,
    10001, 10002 + 0
  )
  val bar1 = foo1(
    10000,
    10001, 10002 + 0)
  val bar2 = foo2(
    0,
    1, 2, 3,
    4, 5, 6, 7, 8, 9, 10 + 0)
}
>>>
object Main {
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar1 = foo1(
      10000, 10001, 10002 + 0)
  val bar2 = foo2(
      0, 1, 2, 3, 4, 5, 6, 7, 8,
      9, 10 + 0)
}
<<< binPack.defnSite with !configStyle, !danglingParentheses, ind=4/6
newlines.configStyleDefnSite.prefer = false
danglingParentheses.defnSite = false
binPack.defnSite = always
indent.defnSite = 4
indent.binPackDefnSite = 6
maxColumn = 30
runner.optimizer.defnSite { minSpan = 20, minCount = 5 }
===
object Main {
  def foo1(
    x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*
  ): Set[Int]
  def foo1(
    x1: X,
    x2: X, xs: X*): Set[Int]
  def foo1(x1: X,
    x2: X, xs: X*): Set[Int]
  def foo2(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*
  ): Set[Int]
  def foo3(
    x1: X, x2: X, x3: X,
    x4: X, xs: X*): Set[Int]
}
>>>
object Main {
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo1(
        x1: X, x2: X, xs: X*)
      : Set[Int]
  def foo2(
        x1: X, x2: X, x3: X,
        x4: X, xs: X*)
      : Set[Int]
  def foo3(
        x1: X, x2: X, x3: X,
        x4: X, xs: X*)
      : Set[Int]
}
<<< two statements separated by semicolon
foo match {
  case a =>
    bara;
    baza
  case b => barb;
    bazb
  case c => barc; bazc
}
>>>
foo match {
  case a =>
    bara;
    baza
  case b =>
    barb;
    bazb
  case c =>
    barc;
    bazc
}
<<< redundant braces around nested lambda, parens around outer
rewrite.rules = [RedundantBraces]
===
object a {
  foo := bar {
    val baz = qux(x => {
      plugh => xyzzy
    })
    val baz = qux(x => {
      quux => fred
    })
  }
}
>>>
object a {
  foo :=
    bar {
      val baz = qux(x => plugh => xyzzy)
      val baz = qux(x => quux => fred)
    }
}
<<< no braces around nested lambda, braces around outer
rewrite.rules = [RedundantBraces]
===
object a {
  foo := bar {
    val baz = qux { x => 
      plugh => xyzzy
    }
    val baz = qux { x => 
      quux => fred
    }
  }
}
>>>
object a {
  foo :=
    bar {
      val baz = qux { x => plugh =>
        xyzzy
      }
      val baz = qux { x => quux =>
        fred
      }
    }
}
<<< #4133 for-yield with multiple semicolon-separated enumerators 1
align.preset = some
===
object a {
  val foo =
    for (barBarBarBarBarBarBarBarBar <- bars; baz <- bazs if qux)
    yield baz
}
>>>
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs
      if qux
    )
      yield baz
}
<<< #4133 for-yield with multiple semicolon-separated enumerators 2
align.preset = some
===
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <- bars;
      baz <- bazs
      if qux
    )
    yield bar
}
>>>
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs
      if qux
    )
      yield bar
}
<<< #4133 for-yield with multiple semicolon-separated enumerators 3
align.preset = some
===
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs if qux
    )
    yield bar
}
>>>
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs
      if qux
    )
      yield bar
}
<<< #4133 for-yield with multiple semicolon-separated enumerators 4
align.preset = some
===
object a {
  val foo =
    for (barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs if qux)
    yield bar
}
>>>
object a {
  val foo =
    for (
      barBarBarBarBarBarBarBarBar <-
        bars;
      baz <- bazs
      if qux
    )
      yield bar
}
<<< #4133 block with multiple semicolon-separated statements 1
align.preset = some
===
object a {
  val foo = barBarBarBarBarBarBarBarBarBar; val baz = foo
}
>>>
object a {
  val foo =
    barBarBarBarBarBarBarBarBarBar;
  val baz = foo
}
<<< #4133 block with multiple semicolon-separated statements 2
align.preset = some
===
object a {
  val foo = barBarBarBarBarBarBarBarBarBar;
  val baz = foo
}
>>>
object a {
  val foo =
    barBarBarBarBarBarBarBarBarBar;
  val baz = foo
}
<<< #4133 block with multiple semicolon-separated statements 3
align.preset = some
===
object a {
  val foo =
    barBarBarBarBarBarBarBarBarBar;
  val baz = foo
}
>>>
object a {
  val foo =
    barBarBarBarBarBarBarBarBarBar;
  val baz = foo
}
<<< #4133 block with multiple semicolon-separated statements 4
align.preset = some
===
object a {
  val foo =
    barBarBarBarBarBarBar; val baz = foo
}
>>>
object a {
  val foo = barBarBarBarBarBarBar;
  val baz = foo
}
<<< #4133 binpack with complex nested applies and not forcing config style, !dangling
binPack.preset = always
danglingParentheses.preset = false
runner.optimizer {
  forceConfigStyleMinSpan = 500
  forceConfigStyleMinArgCount = 5
}
===
object a {
  div(cls := "cover")(
    div(cls := "doc")(bodyContents),
    Option.when(full)(
      section(id := "attributes")(
        Option.when(memberTypeParams.nonEmpty)(Seq(
          h2(cls := "h500")("Type parameters"),
          dl(cls := "attributes")(memberTypeParams*)
        )).toSeq.flatten,
        Option.when(memberValueParams.nonEmpty)(Seq(
          h2(cls := "h500")("Value parameters"),
          dl(cls := "attributes")(memberValueParams*)
        )).toSeq.flatten,
        h2(cls := "h500")("Attributes"),
        dl(cls := "attributes")(attributes*)
      )
    ).getOrElse(
      Option.when(memberTypeParams.nonEmpty)(Seq(
        h2(cls := "h200")("Type parameters"),
        dl(cls := "attributes attributes-small")(memberTypeParams *)
      )).toSeq.flatten ++
      Option.when(memberValueParams.nonEmpty)(Seq(
        h2(cls := "h200")("Value parameters"),
        dl(cls := "attributes attributes-small")(memberValueParams *)
      )).toSeq.flatten :+
      h2(cls := "h200")("Attributes") :+
      dl(cls := "attributes attributes-small")(attributes *)
    )
  )
}
>>>
object a {
  div(cls := "cover")(
    div(cls := "doc")(bodyContents),
    Option
      .when(full)(
        section(id := "attributes")(
          Option
            .when(
              memberTypeParams
                .nonEmpty)(
              Seq(
                h2(cls := "h500")(
                  "Type parameters"),
                dl(cls := "attributes")(
                  memberTypeParams *)))
            .toSeq
            .flatten,
          Option
            .when(
              memberValueParams
                .nonEmpty)(
              Seq(
                h2(cls := "h500")(
                  "Value parameters"),
                dl(cls := "attributes")(
                  memberValueParams *)))
            .toSeq
            .flatten,
          h2(cls := "h500")(
            "Attributes"),
          dl(cls := "attributes")(
            attributes *)))
      .getOrElse(
        Option
          .when(
            memberTypeParams.nonEmpty)(
            Seq(
              h2(cls := "h200")(
                "Type parameters"),
              dl(
                cls :=
                  "attributes attributes-small")(
                memberTypeParams *)))
          .toSeq
          .flatten ++
          Option
            .when(
              memberValueParams
                .nonEmpty)(
              Seq(
                h2(cls := "h200")(
                  "Value parameters"),
                dl(
                  cls :=
                    "attributes attributes-small")(
                  memberValueParams *)))
            .toSeq
            .flatten :+
          h2(cls := "h200")(
            "Attributes") :+
          dl(
            cls :=
              "attributes attributes-small")(
            attributes *)))
}
<<< #4133 binpack with complex nested applies and not forcing config style, dangling
binPack.preset = always
danglingParentheses.preset = true
runner.optimizer {
  forceConfigStyleMinSpan = 500
  forceConfigStyleMinArgCount = 5
}
===
object a {
  div(cls := "cover")(
    div(cls := "doc")(bodyContents),
    Option.when(full)(
      section(id := "attributes")(
        Option.when(memberTypeParams.nonEmpty)(Seq(
          h2(cls := "h500")("Type parameters"),
          dl(cls := "attributes")(memberTypeParams*)
        )).toSeq.flatten,
        Option.when(memberValueParams.nonEmpty)(Seq(
          h2(cls := "h500")("Value parameters"),
          dl(cls := "attributes")(memberValueParams*)
        )).toSeq.flatten,
        h2(cls := "h500")("Attributes"),
        dl(cls := "attributes")(attributes*)
      )
    ).getOrElse(
      Option.when(memberTypeParams.nonEmpty)(Seq(
        h2(cls := "h200")("Type parameters"),
        dl(cls := "attributes attributes-small")(memberTypeParams *)
      )).toSeq.flatten ++
      Option.when(memberValueParams.nonEmpty)(Seq(
        h2(cls := "h200")("Value parameters"),
        dl(cls := "attributes attributes-small")(memberValueParams *)
      )).toSeq.flatten :+
      h2(cls := "h200")("Attributes") :+
      dl(cls := "attributes attributes-small")(attributes *)
    )
  )
}
>>>
object a {
  div(cls := "cover")(
    div(cls := "doc")(bodyContents),
    Option
      .when(full)(
        section(id := "attributes")(
          Option
            .when(
              memberTypeParams.nonEmpty
            )(
              Seq(
                h2(cls := "h500")(
                  "Type parameters"
                ),
                dl(cls := "attributes")(
                  memberTypeParams *
                )
              )
            )
            .toSeq
            .flatten,
          Option
            .when(
              memberValueParams.nonEmpty
            )(
              Seq(
                h2(cls := "h500")(
                  "Value parameters"
                ),
                dl(cls := "attributes")(
                  memberValueParams *
                )
              )
            )
            .toSeq
            .flatten,
          h2(cls := "h500")(
            "Attributes"
          ),
          dl(cls := "attributes")(
            attributes *
          )
        )
      )
      .getOrElse(
        Option
          .when(
            memberTypeParams.nonEmpty
          )(
            Seq(
              h2(cls := "h200")(
                "Type parameters"
              ),
              dl(
                cls :=
                  "attributes attributes-small"
              )(memberTypeParams *)
            )
          )
          .toSeq
          .flatten ++
          Option
            .when(
              memberValueParams.nonEmpty
            )(
              Seq(
                h2(cls := "h200")(
                  "Value parameters"
                ),
                dl(
                  cls :=
                    "attributes attributes-small"
                )(memberValueParams *)
              )
            )
            .toSeq
            .flatten :+
          h2(cls := "h200")(
            "Attributes"
          ) :+
          dl(
            cls :=
              "attributes attributes-small"
          )(attributes *)
      )
  )
}
<<< #4187 dangling
optIn.configStyleArguments = false
danglingParentheses.preset = true
maxColumn = 98
===
object a {
  logWarning(
    log"Session plan cache is disabled due to non-positive cache size." +
      log" Current value of " +
      log"'${MDC(LogKeys.CONFIG, Connect.CONNECT_SESSION_PLAN_CACHE_SIZE.key)}' is ${MDC(
          LogKeys.CACHE_SIZE,
          SparkEnv.get.conf.get(Connect.CONNECT_SESSION_PLAN_CACHE_SIZE))}")
}
>>>
object a {
  logWarning(
    log"Session plan cache is disabled due to non-positive cache size." +
      log" Current value of " +
      log"'${MDC(LogKeys.CONFIG, Connect.CONNECT_SESSION_PLAN_CACHE_SIZE.key)}' is ${MDC(
          LogKeys.CACHE_SIZE,
          SparkEnv.get.conf.get(Connect.CONNECT_SESSION_PLAN_CACHE_SIZE)
        )}"
  )
}
<<< #4187 !dangling
optIn.configStyleArguments = false
danglingParentheses.preset = false
maxColumn = 98
===
object a {
  logWarning(
    log"Session plan cache is disabled due to non-positive cache size." +
      log" Current value of " +
      log"'${MDC(LogKeys.CONFIG, Connect.CONNECT_SESSION_PLAN_CACHE_SIZE.key)}' is ${MDC(
          LogKeys.CACHE_SIZE,
          SparkEnv.get.conf.get(Connect.CONNECT_SESSION_PLAN_CACHE_SIZE))}")
}
>>>
object a {
  logWarning(
    log"Session plan cache is disabled due to non-positive cache size." +
      log" Current value of " +
      log"'${MDC(LogKeys.CONFIG, Connect.CONNECT_SESSION_PLAN_CACHE_SIZE.key)}' is ${MDC(
          LogKeys.CACHE_SIZE,
          SparkEnv.get.conf.get(Connect.CONNECT_SESSION_PLAN_CACHE_SIZE))}")
}
<<< #4133 overflow select within interpolate
object a {
  def lub(tp1: Type, tp2: Type, canConstrain: Boolean = false, isSoft: Boolean = true): Type = /*>|>*/ trace(s"lub(${tp1.show}, ${tp2.show}, canConstrain=$canConstrain, isSoft=$isSoft)", subtyping, show = true) /*<|<*/ {
    // foo
  }
}
>>>
object a {
  def lub(
      tp1: Type,
      tp2: Type,
      canConstrain: Boolean = false,
      isSoft: Boolean = true
  ): Type = /*>|>*/
    trace(
      s"lub(${tp1.show}, ${tp2
          .show}, canConstrain=$canConstrain, isSoft=$isSoft)",
      subtyping,
      show = true
    ) /*<|<*/ {
      // foo
    }
}
<<< #4133 case with multiple patterns, all on one line
maxColumn = 78
===
object a {
    if (foo) bar match {
      case nme.IMPORT | nme.OUTER | nme.ANON_CLASS_NAME | nme.ANON_FUN_NAME | nme.CONSTRUCTOR => ()
    }
}
>>>
object a {
  if (foo)
    bar match {
      case nme.IMPORT | nme.OUTER | nme.ANON_CLASS_NAME | nme.ANON_FUN_NAME |
          nme.CONSTRUCTOR =>
        ()
    }
}
<<< #4133 control body with complex apply/select/try 1
maxColumn = 70
===
object a {
  def fn(): Boolean =
    try in.readYesOrNo(explain + replayQuestionMessage, { echo("\nYou must enter y or n.") ; fn() })
    catch { case _: RuntimeException => false }
}
>>>
object a {
  def fn(): Boolean =
    try in.readYesOrNo(
        explain + replayQuestionMessage, {
          echo("\nYou must enter y or n.");
          fn()
        }
      )
    catch {
      case _: RuntimeException =>
        false
    }
}
<<< #4133 control body with complex apply/select/try 2
maxColumn = 70
===
object a {
  val altArgPts =
    try alts.map(alt => formalTypes(alt.info.paramTypes, argslen).map(ft => (ft, alt))).transpose
    catch { case _: IllegalArgumentException => }
}
>>>
object a {
  val altArgPts =
    try
      alts
        .map(alt =>
          formalTypes(alt.info.paramTypes, argslen).map(ft =>
            (ft, alt)
          )
        )
        .transpose
    catch {
      case _: IllegalArgumentException =>
    }
}
<<< single-line block as arg in one-arg-per-line, solo expression
object a {
  new EntrySpliterator[K, V](
    tab,
    baseSize,
    { baseLimit = h; h },
    f,
    { est >>>= 1; est },
    map
  )
}
>>>
object a {
  new EntrySpliterator[K, V](
    tab,
    baseSize, {
      baseLimit = h;
      h
    },
    f, {
      est >>>= 1;
      est
    },
    map
  )
}
<<< single-line block as arg in one-arg-per-line, `else` expression
object a {
  if (foo) null
  else
    new EntrySpliterator[K, V](
      tab,
      baseSize,
      { baseLimit = h; h },
      f,
      { est >>>= 1; est },
      map
    )
}
>>>
object a {
  if (foo)
    null
  else
    new EntrySpliterator[K, V](
      tab,
      baseSize, {
        baseLimit = h;
        h
      },
      f, {
        est >>>= 1;
        est
      },
      map
    )
}
<<< single-line block as infix arg
maxColumn = 80
===
object a {
  if ({ rs = counterCells; rs } != null &&
    { m = rs.length; m } > 0 && rs({ j = (m - 1) & h; j }
  ) == null) {
    rs(j) = r
  }
}
>>>
object a {
  if (
    {
      rs = counterCells;
      rs
    } != null && {
      m = rs.length;
      m
    } > 0 &&
    rs({
      j = (m - 1) & h;
      j
    }) == null
  ) {
    rs(j) = r
  }
}
<<< #4133 case body enclosed, no break before lparen, no break after lparen
object a {
  foo match {
    case bar => ( // c1a
        // c2a
        qux
      )
  }
}
>>>
object a {
  foo match {
    case bar => ( // c1a
      // c2a
      qux
    )
  }
}
<<< #4133 case body enclosed, no break before lparen, break after lparen
object a {
  foo match {
    case bar => (
        // c1a
        // c2a
        qux
      )
  }
}
>>>
object a {
  foo match {
    case bar => (
      // c1a
      // c2a
      qux
    )
  }
}
<<< #4133 case body enclosed, break before lparen
object a {
  foo match {
    case bar =>
      ( // c1a
        // c2a
        qux
      )
  }
}
>>>
object a {
  foo match {
    case bar => ( // c1a
      // c2a
      qux
    )
  }
}
<<< #4133 case body enclosed, break before lparen, comment after arrow
object a {
  foo match {
    case bar => // c1b
      ( // c1a
        // c2a
        qux
      )
  }
}
>>>
object a {
  foo match {
    case bar => // c1b
      ( // c1a
        // c2a
        qux
      )
  }
}
<<< #4133 case body enclosed, break before lparen, comments after arrow
object a {
  foo match {
    case bar => // c1b
      // c2b
      ( // c1a
        // c2a
        qux
      )
  }
}
>>>
object a {
  foo match {
    case bar => // c1b
      // c2b
      ( // c1a
        // c2a
        qux
      )
  }
}
<<< #4133 complex case clause with non-idempotent `if` guard
maxColumn = 80
===
trait Infer {
  class Inferencer {
    def checkAccessible() = {
      if (sym.isError)
        tree setSymbol sym setType ErrorType
      else accessible match {
        case sym                                                      =>
          tree setSymbol sym1 setType (
            pre match {
              // OPT: avoid lambda allocation and Type.map for super constructor calls
              case _: SuperType if !sym.isConstructor && !owntype.isInstanceOf[OverloadedType] =>
                owntype map ((tp: Type) => if (tp eq pre) site.symbol.thisType else tp)
              case _ => owntype
            }
          )
      }
    }
  }
}
>>>
trait Infer {
  class Inferencer {
    def checkAccessible() = {
      if (sym.isError)
        tree setSymbol sym setType ErrorType
      else
        accessible match {
          case sym =>
            tree setSymbol sym1 setType (
              pre match {
                // OPT: avoid lambda allocation and Type.map for super constructor calls
                case _: SuperType
                    if !sym.isConstructor &&
                      !owntype.isInstanceOf[OverloadedType] =>
                  owntype map (
                    (tp: Type) =>
                      if (tp eq pre)
                        site.symbol.thisType
                      else
                        tp
                  )
                case _ =>
                  owntype
              }
            )
        }
    }
  }
}
<<< #4133 very long one-liner with chain of infixes, full method
class UDFRegistration private[sql] (functionRegistry: FunctionRegistry) extends Logging {
  def register[RT: TypeTag, A1: TypeTag, A2: TypeTag, A3: TypeTag, A4: TypeTag, A5: TypeTag, A6: TypeTag, A7: TypeTag, A8: TypeTag, A9: TypeTag, A10: TypeTag, A11: TypeTag, A12: TypeTag, A13: TypeTag, A14: TypeTag, A15: TypeTag, A16: TypeTag, A17: TypeTag, A18: TypeTag, A19: TypeTag, A20: TypeTag, A21: TypeTag, A22: TypeTag](name: String, func: Function22[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, RT]): UserDefinedFunction = {
    val inputEncoders: Seq[Option[ExpressionEncoder[_]]] = Try(ExpressionEncoder[A1]()).toOption :: Try(ExpressionEncoder[A2]()).toOption :: Try(ExpressionEncoder[A3]()).toOption :: Try(ExpressionEncoder[A4]()).toOption :: Try(ExpressionEncoder[A5]()).toOption :: Try(ExpressionEncoder[A6]()).toOption :: Try(ExpressionEncoder[A7]()).toOption :: Try(ExpressionEncoder[A8]()).toOption :: Try(ExpressionEncoder[A9]()).toOption :: Try(ExpressionEncoder[A10]()).toOption :: Try(ExpressionEncoder[A11]()).toOption :: Try(ExpressionEncoder[A12]()).toOption :: Try(ExpressionEncoder[A13]()).toOption :: Try(ExpressionEncoder[A14]()).toOption :: Try(ExpressionEncoder[A15]()).toOption :: Try(ExpressionEncoder[A16]()).toOption :: Try(ExpressionEncoder[A17]()).toOption :: Try(ExpressionEncoder[A18]()).toOption :: Try(ExpressionEncoder[A19]()).toOption :: Try(ExpressionEncoder[A20]()).toOption :: Try(ExpressionEncoder[A21]()).toOption :: Try(ExpressionEncoder[A22]()).toOption :: Nil
  }
}
>>>
class UDFRegistration private[sql] (
    functionRegistry: FunctionRegistry
) extends Logging {
  def register[
      RT: TypeTag,
      A1: TypeTag,
      A2: TypeTag,
      A3: TypeTag,
      A4: TypeTag,
      A5: TypeTag,
      A6: TypeTag,
      A7: TypeTag,
      A8: TypeTag,
      A9: TypeTag,
      A10: TypeTag,
      A11: TypeTag,
      A12: TypeTag,
      A13: TypeTag,
      A14: TypeTag,
      A15: TypeTag,
      A16: TypeTag,
      A17: TypeTag,
      A18: TypeTag,
      A19: TypeTag,
      A20: TypeTag,
      A21: TypeTag,
      A22: TypeTag
  ](
      name: String,
      func: Function22[
        A1,
        A2,
        A3,
        A4,
        A5,
        A6,
        A7,
        A8,
        A9,
        A10,
        A11,
        A12,
        A13,
        A14,
        A15,
        A16,
        A17,
        A18,
        A19,
        A20,
        A21,
        A22,
        RT
      ]
  ): UserDefinedFunction = {
    val inputEncoders: Seq[
      Option[ExpressionEncoder[_]]
    ] =
      Try(ExpressionEncoder[A1]())
        .toOption ::
        Try(ExpressionEncoder[A2]())
          .toOption ::
        Try(ExpressionEncoder[A3]())
          .toOption ::
        Try(ExpressionEncoder[A4]())
          .toOption ::
        Try(ExpressionEncoder[A5]())
          .toOption ::
        Try(ExpressionEncoder[A6]())
          .toOption ::
        Try(ExpressionEncoder[A7]())
          .toOption ::
        Try(ExpressionEncoder[A8]())
          .toOption ::
        Try(ExpressionEncoder[A9]())
          .toOption ::
        Try(ExpressionEncoder[A10]())
          .toOption ::
        Try(ExpressionEncoder[A11]())
          .toOption ::
        Try(ExpressionEncoder[A12]())
          .toOption ::
        Try(ExpressionEncoder[A13]())
          .toOption ::
        Try(ExpressionEncoder[A14]())
          .toOption ::
        Try(ExpressionEncoder[A15]())
          .toOption ::
        Try(ExpressionEncoder[A16]())
          .toOption ::
        Try(ExpressionEncoder[A17]())
          .toOption ::
        Try(ExpressionEncoder[A18]())
          .toOption ::
        Try(ExpressionEncoder[A19]())
          .toOption ::
        Try(ExpressionEncoder[A20]())
          .toOption ::
        Try(ExpressionEncoder[A21]())
          .toOption ::
        Try(ExpressionEncoder[A22]())
          .toOption :: Nil
  }
}
<<< #4133 very long one-liner with chain of infixes
runner.maxStateVisits = 1000
===
class UDFRegistration {
  def foo = {
    val inputEncoders: Seq_Option_ExpressionEncoder_____ = Try(ExpressionEncoder_A1_) :: Try(ExpressionEncoder_A2_) :: Try(ExpressionEncoder_A3_) :: Try(ExpressionEncoder_A4_) :: Try(ExpressionEncoder_A5_) :: Try(ExpressionEncoder_A6_) :: Try(ExpressionEncoder_A7_) :: Try(ExpressionEncoder_A8_) :: Try(ExpressionEncoder_A9_) :: Try(ExpressionEncoder_A10_) :: Try(ExpressionEncoder_A11_) :: Try(ExpressionEncoder_A12_) :: Try(ExpressionEncoder_A13_) :: Try(ExpressionEncoder_A14_) :: Try(ExpressionEncoder_A15_) :: Try(ExpressionEncoder_A16_) :: Try(ExpressionEncoder_A17_) :: Try(ExpressionEncoder_A18_) :: Try(ExpressionEncoder_A19_) :: Try(ExpressionEncoder_A20_) :: Try(ExpressionEncoder_A21_) :: Try(ExpressionEncoder_A22_) :: Nil
  }
}
>>>
class UDFRegistration {
  def foo = {
    val inputEncoders
        : Seq_Option_ExpressionEncoder_____ =
      Try(ExpressionEncoder_A1_) ::
        Try(ExpressionEncoder_A2_) ::
        Try(ExpressionEncoder_A3_) ::
        Try(ExpressionEncoder_A4_) ::
        Try(ExpressionEncoder_A5_) ::
        Try(ExpressionEncoder_A6_) ::
        Try(ExpressionEncoder_A7_) ::
        Try(ExpressionEncoder_A8_) ::
        Try(ExpressionEncoder_A9_) ::
        Try(ExpressionEncoder_A10_) ::
        Try(ExpressionEncoder_A11_) ::
        Try(ExpressionEncoder_A12_) ::
        Try(ExpressionEncoder_A13_) ::
        Try(ExpressionEncoder_A14_) ::
        Try(ExpressionEncoder_A15_) ::
        Try(ExpressionEncoder_A16_) ::
        Try(ExpressionEncoder_A17_) ::
        Try(ExpressionEncoder_A18_) ::
        Try(ExpressionEncoder_A19_) ::
        Try(ExpressionEncoder_A20_) ::
        Try(ExpressionEncoder_A21_) ::
        Try(ExpressionEncoder_A22_) ::
        Nil
  }
}
<<< #4133 very long one-liner with chain of infixes, with selects
runner.maxStateVisits = 5000
===
class UDFRegistration {
  def foo = {
    val inputEncoders: Seq_Option_ExpressionEncoder_____ = Try(ExpressionEncoder_A1_).toOption :: Try(ExpressionEncoder_A2_).toOption :: Try(ExpressionEncoder_A3_).toOption :: Try(ExpressionEncoder_A4_).toOption :: Try(ExpressionEncoder_A5_).toOption :: Try(ExpressionEncoder_A6_).toOption :: Try(ExpressionEncoder_A7_).toOption :: Try(ExpressionEncoder_A8_).toOption :: Try(ExpressionEncoder_A9_).toOption :: Try(ExpressionEncoder_A10_).toOption :: Try(ExpressionEncoder_A11_).toOption :: Try(ExpressionEncoder_A12_).toOption :: Try(ExpressionEncoder_A13_).toOption :: Try(ExpressionEncoder_A14_).toOption :: Try(ExpressionEncoder_A15_).toOption :: Try(ExpressionEncoder_A16_).toOption :: Try(ExpressionEncoder_A17_).toOption :: Try(ExpressionEncoder_A18_).toOption :: Try(ExpressionEncoder_A19_).toOption :: Try(ExpressionEncoder_A20_).toOption :: Try(ExpressionEncoder_A21_).toOption :: Try(ExpressionEncoder_A22_).toOption :: Nil
  }
}
>>>
class UDFRegistration {
  def foo = {
    val inputEncoders
        : Seq_Option_ExpressionEncoder_____ =
      Try(ExpressionEncoder_A1_)
        .toOption ::
        Try(ExpressionEncoder_A2_)
          .toOption ::
        Try(ExpressionEncoder_A3_)
          .toOption ::
        Try(ExpressionEncoder_A4_)
          .toOption ::
        Try(ExpressionEncoder_A5_)
          .toOption ::
        Try(ExpressionEncoder_A6_)
          .toOption ::
        Try(ExpressionEncoder_A7_)
          .toOption ::
        Try(ExpressionEncoder_A8_)
          .toOption ::
        Try(ExpressionEncoder_A9_)
          .toOption ::
        Try(ExpressionEncoder_A10_)
          .toOption ::
        Try(ExpressionEncoder_A11_)
          .toOption ::
        Try(ExpressionEncoder_A12_)
          .toOption ::
        Try(ExpressionEncoder_A13_)
          .toOption ::
        Try(ExpressionEncoder_A14_)
          .toOption ::
        Try(ExpressionEncoder_A15_)
          .toOption ::
        Try(ExpressionEncoder_A16_)
          .toOption ::
        Try(ExpressionEncoder_A17_)
          .toOption ::
        Try(ExpressionEncoder_A18_)
          .toOption ::
        Try(ExpressionEncoder_A19_)
          .toOption ::
        Try(ExpressionEncoder_A20_)
          .toOption ::
        Try(ExpressionEncoder_A21_)
          .toOption ::
        Try(ExpressionEncoder_A22_)
          .toOption :: Nil
  }
}
<<< #4133 very long one-liner with chain of infixes, with select and types
runner.maxStateVisits = 100000
===
class UDFRegistration {
  def foo = {
    val inputEncoders: Seq[Option[ExpressionEncoder[_]]] = Try(ExpressionEncoder[A1]).toOption :: Try(ExpressionEncoder[A2]).toOption :: Try(ExpressionEncoder[A3]).toOption :: Try(ExpressionEncoder[A4]).toOption :: Try(ExpressionEncoder[A5]).toOption :: Try(ExpressionEncoder[A6]).toOption :: Try(ExpressionEncoder[A7]).toOption :: Try(ExpressionEncoder[A8]).toOption :: Try(ExpressionEncoder[A9]).toOption :: Try(ExpressionEncoder[A10]).toOption :: Try(ExpressionEncoder[A11]).toOption :: Try(ExpressionEncoder[A12]).toOption :: Try(ExpressionEncoder[A13]).toOption :: Try(ExpressionEncoder[A14]).toOption :: Try(ExpressionEncoder[A15]).toOption :: Try(ExpressionEncoder[A16]).toOption :: Try(ExpressionEncoder[A17]).toOption :: Try(ExpressionEncoder[A18]).toOption :: Try(ExpressionEncoder[A19]).toOption :: Try(ExpressionEncoder[A20]).toOption :: Try(ExpressionEncoder[A21]).toOption :: Try(ExpressionEncoder[A22]).toOption :: Nil
  }
}
>>>
class UDFRegistration {
  def foo = {
    val inputEncoders: Seq[
      Option[ExpressionEncoder[_]]
    ] =
      Try(ExpressionEncoder[A1])
        .toOption ::
        Try(ExpressionEncoder[A2])
          .toOption ::
        Try(ExpressionEncoder[A3])
          .toOption ::
        Try(ExpressionEncoder[A4])
          .toOption ::
        Try(ExpressionEncoder[A5])
          .toOption ::
        Try(ExpressionEncoder[A6])
          .toOption ::
        Try(ExpressionEncoder[A7])
          .toOption ::
        Try(ExpressionEncoder[A8])
          .toOption ::
        Try(ExpressionEncoder[A9])
          .toOption ::
        Try(ExpressionEncoder[A10])
          .toOption ::
        Try(ExpressionEncoder[A11])
          .toOption ::
        Try(ExpressionEncoder[A12])
          .toOption ::
        Try(ExpressionEncoder[A13])
          .toOption ::
        Try(ExpressionEncoder[A14])
          .toOption ::
        Try(ExpressionEncoder[A15])
          .toOption ::
        Try(ExpressionEncoder[A16])
          .toOption ::
        Try(ExpressionEncoder[A17])
          .toOption ::
        Try(ExpressionEncoder[A18])
          .toOption ::
        Try(ExpressionEncoder[A19])
          .toOption ::
        Try(ExpressionEncoder[A20])
          .toOption ::
        Try(ExpressionEncoder[A21])
          .toOption ::
        Try(ExpressionEncoder[A22])
          .toOption :: Nil
  }
}
<<< #4133 infix after xml block
maxColumn = 80
===
object a {
  private def waitingBatchRow(batch: BatchUIData): Seq[Node] = {
    baseRow(batch) ++ createOutputOperationProgressBar(batch) ++ <td>queued</td>++ {
      if (firstFailureReason.nonEmpty) {
        // Waiting batches have not run yet, so must have no failure reasons.
        <td>-</td>
      } else {
        Nil
      }
    }
  }
}
>>>
object a {
  private def waitingBatchRow(batch: BatchUIData): Seq[Node] = {
    baseRow(batch) ++ createOutputOperationProgressBar(batch) ++
      <td>queued</td> ++ {
        if (firstFailureReason.nonEmpty) {
          // Waiting batches have not run yet, so must have no failure reasons.
          <td>-</td>
        } else {
          Nil
        }
      }
  }
}
<<< #4133 applies and selects with a partial function 1
maxColumn = 76
runner.parser = source
===
val fieldsCasts = from.fields.zip(to.fields).map {
  case (fromField, toField) => nullSafeCastFunction(fromField.dataType, toField.dataType, ctx)
}
>>>
val fieldsCasts = from
  .fields
  .zip(to.fields)
  .map { case (fromField, toField) =>
    nullSafeCastFunction(fromField.dataType, toField.dataType, ctx)
  }
<<< #4133 applies and selects with a partial function 2
maxColumn = 76
===
val stats = Profiler.getStatistics().asScala.toSeq.map {
  case (trace, count) => MethodCallTrace(trace.className, trace.methodName, trace.methodDescriptor) -> count.intValue
}
>>>
val stats = Profiler
  .getStatistics()
  .asScala
  .toSeq
  .map { case (trace, count) =>
    MethodCallTrace(
      trace.className,
      trace.methodName,
      trace.methodDescriptor
    ) -> count.intValue
  }
<<< #4133 partial function within apply, short
rdd.map(
    {case (id, count) => (count, id)})
>>>
rdd.map({ case (id, count) =>
  (count, id)
})
<<< #4133 partial function within apply, long
maxColumn = 80
===
rdd.map(
    {case (id, count) => (count, id)})
>>>
rdd.map({ case (id, count) =>
  (count, id)
})
<<< #4133 RedundantParens around infix with an embedded blank lin
maxColumn = 80
rewrite {
  rules = [RedundantParens, RedundantBraces]
  redundantBraces.maxLines = 100
  redundantParens.infixSide = all
}
===
class ClassEmitter {

  def genScalaClassConstructor = {

    if (useESClass) {
      for {
        chainProto <- chainProtoWithGlobals
      } yield {
        (
          // Real constructor
          js.JSDocConstructor(realCtorDef.head) ::
          realCtorDef.tail :::
          chainProto :::
          (genIdentBracketSelect(prototypeFor(ctorVar), "constructor") := ctorVar) ::

          // Inheritable constructor
          js.JSDocConstructor(inheritableCtorDef.head) ::
          inheritableCtorDef.tail :::
          (globalVar(VarField.h, className).prototype := prototypeFor(ctorVar)) :: Nil
        )
      }
    }
  }

}
>>>
class ClassEmitter {

  def genScalaClassConstructor =

    if (useESClass) {
      for {
        chainProto <- chainProtoWithGlobals
      } yield
        // Real constructor
        js.JSDocConstructor(realCtorDef.head) :: realCtorDef.tail :::
          chainProto ::: (
            genIdentBracketSelect(prototypeFor(ctorVar), "constructor") :=
              ctorVar
          ) ::
          // Inheritable constructor
          js.JSDocConstructor(inheritableCtorDef.head) ::
          inheritableCtorDef.tail ::: (
            globalVar(VarField.h, className).prototype := prototypeFor(ctorVar)
          ) :: Nil
    }

}
<<< #4133 lambda in braces, overflow after brace
maxColumn = 76
===
validateStructuralIntegrityWithReasonImpl(row, expectedSchema).map {
  errorMessage => s"Error message is: $errorMessage, " +
      s"UnsafeRow status: ${getStructuralIntegrityStatus(row, expectedSchema)}"
}
>>>
validateStructuralIntegrityWithReasonImpl(row, expectedSchema).map {
  errorMessage =>
    s"Error message is: $errorMessage, " +
      s"UnsafeRow status: ${getStructuralIntegrityStatus(
          row,
          expectedSchema
        )}"
}
<<< #4133 lambda in braces, overflow after brace 2
maxColumn = 74
===
val finalProperties = properties.get(SupportsNamespaces.PROP_LOCATION).map { loc =>
  properties + (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
}
>>>
val finalProperties = properties
  .get(SupportsNamespaces.PROP_LOCATION)
  .map { loc =>
    properties +
      (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
  }
<<< #4133 contextual lambda in braces, overflow after brace 2
maxColumn = 74
runner.dialect = scala3
===
val finalProperties = properties.get(SupportsNamespaces.PROP_LOCATION).map { loc ?=>
  properties + (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
}
>>>
val finalProperties = properties
  .get(SupportsNamespaces.PROP_LOCATION)
  .map { loc ?=>
    properties +
      (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
  }
<<< #4133 poly lambda in braces, overflow after brace 2
maxColumn = 74
runner.dialect = scala3
===
val finalProperties = properties.get(SupportsNamespaces.PROP_LOCATION).map { [loc] =>
  properties + (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
}
>>>
val finalProperties = properties
  .get(SupportsNamespaces.PROP_LOCATION)
  .map { [loc] =>
    properties +
      (SupportsNamespaces.PROP_LOCATION -> makeQualifiedDBObjectPath(loc))
  }
<<< #4133 lambda in parens rewritten to braces
maxColumn = 80
rewrite.rules = [RedundantBraces]
===
object Build {
  lazy val scaladoc = project.in(file("scaladoc")).
    settings(
      generateScalaDocumentation := Def.inputTaskDyn {
        val outputDirOverride = extraArgs.headOption.fold(identity[GenerationConfig](_))(newDir => {
          config: GenerationConfig => config.add(OutputDir(newDir))
        })
        val justAPI = justAPIArg.fold(identity[GenerationConfig](_))(_ => {
          config: GenerationConfig => config.remove[SiteRoot]
        })
      }.evaluated,
    )
}
>>>
object Build {
  lazy val scaladoc = project
    .in(file("scaladoc"))
    .settings(
      generateScalaDocumentation :=
        Def
          .inputTaskDyn {
            val outputDirOverride =
              extraArgs
                .headOption
                .fold(identity[GenerationConfig](_)) {
                  newDir => config: GenerationConfig =>
                    config.add(OutputDir(newDir))
                }
            val justAPI =
              justAPIArg.fold(identity[GenerationConfig](_)) {
                _ => config: GenerationConfig =>
                  config.remove[SiteRoot]
              }
          }
          .evaluated
    )
}
<<< #4133 monads with binpack and no newlines in types
maxColumn = 80
binPack.preset = always
newlines {
  avoidInResultType = true
  sometimesBeforeColonInMethodReturnType = false
}
===
trait FunctionInstances extends FunctionInstances0 {
  implicit def function6Instance[T1, T2, T3, T4, T5, T6]: Monad[(T1, T2, T3, T4, T5, T6) => *] with BindRec[(T1, T2, T3, T4, T5, T6) => *] =
    new Monad[(T1, T2, T3, T4, T5, T6) => *] with BindRec[(T1, T2, T3, T4, T5, T6) => *] {
      //
    }
}
>>>
trait FunctionInstances extends FunctionInstances0 {
  implicit def function6Instance[
      T1, T2, T3, T4, T5,
      T6
  ]: Monad[(T1, T2, T3, T4, T5, T6) => *] with BindRec[(T1, T2, T3, T4, T5, T6) => *] =
    new Monad[(T1, T2, T3, T4, T5, T6) => *]
      with BindRec[(T1, T2, T3, T4, T5, T6) => *] {
      //
    }
}
<<< #4133 overflowing complex result type 1
preset = default
maxColumn = 76
===
object Multipart {
  def format(
     //
  ): Flow[MultipartFormData.Part[Source_ByteString], ByteString, NotUsed] = {
    //
  }
}
>>>
object Multipart {
  def format(
      //
  ): Flow[
    MultipartFormData.Part[Source_ByteString],
    ByteString,
    NotUsed
  ] = {
    //
  }
}
<<< #4133 overflowing complex result type 2
preset = default
maxColumn = 80
===
object Multipart {
  private def streamed(
    //
  ): GraphStage[FlowShape[MultipartFormData.Part[Source[ByteString, _]], Source[ByteString, Any]]] =
    new GraphStage[FlowShape[MultipartFormData.Part[Source[ByteString, _]], Source[ByteString, Any]]] {
      //
    }
}
>>>
object Multipart {
  private def streamed(
      //
  ): GraphStage[FlowShape[
    MultipartFormData.Part[Source[ByteString, _]],
    Source[ByteString, Any]
  ]] =
    new GraphStage[FlowShape[MultipartFormData.Part[
      Source[ByteString, _]
    ], Source[ByteString, Any]]] {
      //
    }
}
<<< #4133 complex nested applies/lambdas with for and tuple, narrow
private object MemoMap {
  def make(implicit trace: Trace): UIO[MemoMap] =
    Ref.Synchronized
      .map { ref =>
        new MemoMap { self =>
          final def getOrElseMemoize[E, A, B](scope: Scope)(
            layer: ZLayer[A, E, B]
          ): ZIO[A, E, ZEnvironment[B]] =
            ref.modifyZIO { map =>
              map.get(layer) match {
                case None =>
                  for {
                    memoized = (
                                 promise.await.onExit {
                                   case Exit.Failure(_) => ZIO.unit
                                   case Exit.Success(_) => observers.update(_ + 1)
                                 },
                                 (exit: Exit[Any, Any]) => finalizerRef.get.flatMap(_(exit))
                               )
                  } yield (resource, if (layer.isFresh) map else map.updated(layer, memoized))
              }
            }.flatten
        }
      }
}
>>>
private object MemoMap {
  def make(implicit
      trace: Trace
  ): UIO[MemoMap] = Ref
    .Synchronized
    .map { ref =>
      new MemoMap {
        self =>
        final def getOrElseMemoize[
            E,
            A,
            B
        ](scope: Scope)(
            layer: ZLayer[A, E, B]
        ): ZIO[A, E, ZEnvironment[B]] =
          ref
            .modifyZIO { map =>
              map.get(layer) match {
                case None =>
                  for {
                    memoized = (
                      promise
                        .await
                        .onExit {
                          case Exit
                                .Failure(
                                  _
                                ) =>
                            ZIO.unit
                          case Exit
                                .Success(
                                  _
                                ) =>
                            observers
                              .update(
                                _ + 1
                              )
                        },
                      (
                        exit: Exit[
                          Any,
                          Any
                        ]
                      ) =>
                        finalizerRef
                          .get
                          .flatMap(
                            _(exit)
                          )
                    )
                  } yield (
                    resource,
                    if (layer.isFresh)
                      map
                    else
                      map.updated(
                        layer,
                        memoized
                      )
                  )
              }
            }
            .flatten
      }
    }
}
<<< #4133 complex nested applies/lambdas with for and tuple, wide and long
maxColumn = 80
===
object a {
  private object MemoMap {
    def make(implicit trace: Trace): UIO[MemoMap] =
      Ref.Synchronized
        .make[Map[ZLayer[Nothing, Any, Any], (IO[Any, Any], Exit[Any, Any] => UIO[Any])]](Map.empty)
        .map { ref =>
          new MemoMap { self =>
            final def getOrElseMemoize[E, A, B](scope: Scope)(
              layer: ZLayer[A, E, B]
            ): ZIO[A, E, ZEnvironment[B]] =
              ref.modifyZIO { map =>
                map.get(layer) match {
                  case Some((acquire, release)) =>
                    val cached: ZIO[Any, E, ZEnvironment[B]] = acquire
                      .asInstanceOf[IO[E, (FiberRefs.Patch, ZEnvironment[B])]]
                      .flatMap { case (patch, b) => ZIO.patchFiberRefs(patch).as(b) }
                      .onExit {
                        case Exit.Success(_) => scope.addFinalizerExit(release)
                        case Exit.Failure(_) => ZIO.unit
                      }

                    ZIO.succeed((cached, map))
                  case None =>
                    for {
                      observers    <- Ref.make(0)
                      promise      <- Promise.make[E, (FiberRefs.Patch, ZEnvironment[B])]
                      finalizerRef <- Ref.make[Exit[Any, Any] => UIO[Any]](_ => ZIO.unit)

                      resource = ZIO.uninterruptibleMask { restore =>
                                   for {
                                     a          <- ZIO.environment[A]
                                     outerScope  = scope
                                     innerScope <- Scope.make
                                     tp <-
                                       restore(
                                         layer
                                           .scope(innerScope)
                                           .flatMap(_.apply(self).diffFiberRefs)
                                       ).exit.flatMap {
                                         case e @ Exit.Failure(cause) =>
                                           promise.failCause(cause) *> innerScope.close(e) *> ZIO
                                             .failCause(cause)

                                         case Exit.Success((patch, b)) =>
                                           for {
                                             _ <- finalizerRef.set { (e: Exit[Any, Any]) =>
                                                    ZIO.whenZIO(observers.modify(n => (n == 1, n - 1)))(
                                                      innerScope.close(e)
                                                    )
                                                  }
                                             _ <- observers.update(_ + 1)
                                             outerFinalizer <-
                                               outerScope.addFinalizerExit(e => finalizerRef.get.flatMap(_.apply(e)))
                                             _ <- promise.succeed((patch, b))
                                           } yield b
                                       }
                                   } yield tp
                                 }

                      memoized = (
                                   promise.await.onExit {
                                     case Exit.Failure(_) => ZIO.unit
                                     case Exit.Success(_) => observers.update(_ + 1)
                                   },
                                   (exit: Exit[Any, Any]) => finalizerRef.get.flatMap(_(exit))
                                 )
                    } yield (resource, if (layer.isFresh) map else map.updated(layer, memoized))

                }
              }.flatten
          }
        }
  }
}
>>>
object a {
  private object MemoMap {
    def make(implicit trace: Trace): UIO[MemoMap] = Ref
      .Synchronized
      .make[Map[
        ZLayer[Nothing, Any, Any],
        (IO[Any, Any], Exit[Any, Any] => UIO[Any])
      ]](Map.empty)
      .map { ref =>
        new MemoMap {
          self =>
          final def getOrElseMemoize[E, A, B](
              scope: Scope
          )(layer: ZLayer[A, E, B]): ZIO[A, E, ZEnvironment[B]] =
            ref
              .modifyZIO { map =>
                map.get(layer) match {
                  case Some((acquire, release)) =>
                    val cached: ZIO[Any, E, ZEnvironment[B]] = acquire
                      .asInstanceOf[IO[E, (FiberRefs.Patch, ZEnvironment[B])]]
                      .flatMap { case (patch, b) =>
                        ZIO.patchFiberRefs(patch).as(b)
                      }
                      .onExit {
                        case Exit.Success(_) =>
                          scope.addFinalizerExit(release)
                        case Exit.Failure(_) =>
                          ZIO.unit
                      }

                    ZIO.succeed((cached, map))
                  case None =>
                    for {
                      observers <- Ref.make(0)
                      promise <- Promise.make[
                        E,
                        (FiberRefs.Patch, ZEnvironment[B])
                      ]
                      finalizerRef <- Ref.make[Exit[Any, Any] => UIO[Any]](_ =>
                        ZIO.unit
                      )

                      resource = ZIO.uninterruptibleMask { restore =>
                        for {
                          a <- ZIO.environment[A]
                          outerScope = scope
                          innerScope <- Scope.make
                          tp <- restore(
                            layer
                              .scope(innerScope)
                              .flatMap(_.apply(self).diffFiberRefs)
                          ).exit
                            .flatMap {
                              case e @ Exit.Failure(cause) =>
                                promise.failCause(cause) *>
                                  innerScope.close(e) *> ZIO.failCause(cause)

                              case Exit.Success((patch, b)) =>
                                for {
                                  _ <- finalizerRef.set { (e: Exit[Any, Any]) =>
                                    ZIO.whenZIO(
                                      observers.modify(n => (n == 1, n - 1))
                                    )(innerScope.close(e))
                                  }
                                  _ <- observers.update(_ + 1)
                                  outerFinalizer <- outerScope.addFinalizerExit(
                                    e => finalizerRef.get.flatMap(_.apply(e))
                                  )
                                  _ <- promise.succeed((patch, b))
                                } yield b
                            }
                        } yield tp
                      }

                      memoized = (
                        promise
                          .await
                          .onExit {
                            case Exit.Failure(_) =>
                              ZIO.unit
                            case Exit.Success(_) =>
                              observers.update(_ + 1)
                          },
                        (exit: Exit[Any, Any]) =>
                          finalizerRef.get.flatMap(_(exit))
                      )
                    } yield (
                      resource,
                      if (layer.isFresh)
                        map
                      else
                        map.updated(layer, memoized)
                    )

                }
              }
              .flatten
        }
      }
  }
}
<<< #4133 spark: massive chain of applies with anonymous function calls
maxColumn = 80
runner.maxStateVisits = 10000000
runner.optimizer.maxVisitsPerToken=1000000
===
object a {
  private def ignoreUndocumentedPackages(packages: Seq[Seq[File]]): Seq[Seq[File]] = {
    packages
      .map(_.filterNot(_.getName.contains("$")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/deploy")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/examples")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/internal")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/memory")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/network")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/rpc")))
      .map(_.filterNot(f =>
        f.getCanonicalPath.contains("org/apache/spark/shuffle") &&
        !f.getCanonicalPath.contains("org/apache/spark/shuffle/api")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/executor")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/ExecutorAllocationClient")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/scheduler/cluster/CoarseGrainedSchedulerBackend")))
      .map(_.filterNot(f =>
        f.getCanonicalPath.contains("org/apache/spark/unsafe") &&
        !f.getCanonicalPath.contains("org/apache/spark/unsafe/types/CalendarInterval")))
      .map(_.filterNot(_.getCanonicalPath.contains("python")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/util/collection")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/util/io")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/util/kvstore")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/catalyst")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/connect/")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/execution")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/internal")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/hive")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/catalog/v2/utils")))
      .map(_.filterNot(_.getCanonicalPath.contains("org.apache.spark.errors")))
      .map(_.filterNot(_.getCanonicalPath.contains("org.apache.spark.sql.errors")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/hive")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/v2/avro")))
      .map(_.filterNot(_.getCanonicalPath.contains("SSLOptions")))
  }
}
>>>
object a {
  private def ignoreUndocumentedPackages(
      packages: Seq[Seq[File]]
  ): Seq[Seq[File]] = {
    packages
      .map(_.filterNot(_.getName.contains("$")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/deploy")))
      .map(
        _.filterNot(_.getCanonicalPath.contains("org/apache/spark/examples"))
      )
      .map(
        _.filterNot(_.getCanonicalPath.contains("org/apache/spark/internal"))
      )
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/memory")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/network")))
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/rpc")))
      .map(
        _.filterNot(f =>
          f.getCanonicalPath.contains("org/apache/spark/shuffle") &&
            !f.getCanonicalPath.contains("org/apache/spark/shuffle/api")
        )
      )
      .map(
        _.filterNot(_.getCanonicalPath.contains("org/apache/spark/executor"))
      )
      .map(
        _.filterNot(
          _.getCanonicalPath
            .contains("org/apache/spark/ExecutorAllocationClient")
        )
      )
      .map(
        _.filterNot(
          _.getCanonicalPath
            .contains(
              "org/apache/spark/scheduler/cluster/CoarseGrainedSchedulerBackend"
            )
        )
      )
      .map(
        _.filterNot(f =>
          f.getCanonicalPath.contains("org/apache/spark/unsafe") &&
            !f.getCanonicalPath
              .contains("org/apache/spark/unsafe/types/CalendarInterval")
        )
      )
      .map(_.filterNot(_.getCanonicalPath.contains("python")))
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/util/collection")
        )
      )
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/spark/util/io")))
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/util/kvstore")
        )
      )
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/sql/catalyst")
        )
      )
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/sql/connect/")
        )
      )
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/sql/execution")
        )
      )
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/sql/internal")
        )
      )
      .map(
        _.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/hive"))
      )
      .map(
        _.filterNot(
          _.getCanonicalPath.contains("org/apache/spark/sql/catalog/v2/utils")
        )
      )
      .map(_.filterNot(_.getCanonicalPath.contains("org.apache.spark.errors")))
      .map(
        _.filterNot(_.getCanonicalPath.contains("org.apache.spark.sql.errors"))
      )
      .map(_.filterNot(_.getCanonicalPath.contains("org/apache/hive")))
      .map(
        _.filterNot(_.getCanonicalPath.contains("org/apache/spark/sql/v2/avro"))
      )
      .map(_.filterNot(_.getCanonicalPath.contains("SSLOptions")))
  }
}
<<< #4133 #4133 spark: massive chain of applies with function calls
maxColumn = 80
runner.maxStateVisits = 10000000
runner.optimizer.maxVisitsPerToken=1000000
===
object a {
  private def ignoreUndocumentedPackages(packages: Seq[Seq[File]]): Seq[Seq[File]] = {
    packages
      .map(filterNot(getName.contains("$")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/deploy")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/examples")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/internal")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/memory")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/network")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/rpc")))
      .map(filterNot(f =>
        f.getCanonicalPath.contains("org/apache/spark/shuffle") &&
        !f.getCanonicalPath.contains("org/apache/spark/shuffle/api")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/executor")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/ExecutorAllocationClient")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/scheduler/cluster/CoarseGrainedSchedulerBackend")))
      .map(filterNot(f =>
        f.getCanonicalPath.contains("org/apache/spark/unsafe") &&
        !f.getCanonicalPath.contains("org/apache/spark/unsafe/types/CalendarInterval")))
      .map(filterNot(getCanonicalPath.contains("python")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/util/collection")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/util/io")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/util/kvstore")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/catalyst")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/connect/")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/execution")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/internal")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/hive")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/catalog/v2/utils")))
      .map(filterNot(getCanonicalPath.contains("org.apache.spark.errors")))
      .map(filterNot(getCanonicalPath.contains("org.apache.spark.sql.errors")))
      .map(filterNot(getCanonicalPath.contains("org/apache/hive")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/v2/avro")))
      .map(filterNot(getCanonicalPath.contains("SSLOptions")))
  }
}
>>>
object a {
  private def ignoreUndocumentedPackages(
      packages: Seq[Seq[File]]
  ): Seq[Seq[File]] = {
    packages
      .map(filterNot(getName.contains("$")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/deploy")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/examples")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/internal")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/memory")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/network")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/rpc")))
      .map(
        filterNot(f =>
          f.getCanonicalPath.contains("org/apache/spark/shuffle") &&
            !f.getCanonicalPath.contains("org/apache/spark/shuffle/api")
        )
      )
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/executor")))
      .map(
        filterNot(
          getCanonicalPath.contains("org/apache/spark/ExecutorAllocationClient")
        )
      )
      .map(
        filterNot(
          getCanonicalPath.contains(
            "org/apache/spark/scheduler/cluster/CoarseGrainedSchedulerBackend"
          )
        )
      )
      .map(
        filterNot(f =>
          f.getCanonicalPath.contains("org/apache/spark/unsafe") &&
            !f.getCanonicalPath
              .contains("org/apache/spark/unsafe/types/CalendarInterval")
        )
      )
      .map(filterNot(getCanonicalPath.contains("python")))
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/util/collection"))
      )
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/util/io")))
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/util/kvstore"))
      )
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/sql/catalyst"))
      )
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/sql/connect/"))
      )
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/sql/execution"))
      )
      .map(
        filterNot(getCanonicalPath.contains("org/apache/spark/sql/internal"))
      )
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/hive")))
      .map(
        filterNot(
          getCanonicalPath.contains("org/apache/spark/sql/catalog/v2/utils")
        )
      )
      .map(filterNot(getCanonicalPath.contains("org.apache.spark.errors")))
      .map(filterNot(getCanonicalPath.contains("org.apache.spark.sql.errors")))
      .map(filterNot(getCanonicalPath.contains("org/apache/hive")))
      .map(filterNot(getCanonicalPath.contains("org/apache/spark/sql/v2/avro")))
      .map(filterNot(getCanonicalPath.contains("SSLOptions")))
  }
}
<<< #4318
runner.dialect = scala213source3
align.openParenCallSite = true
newlines.configStyleCallSite.prefer = false
===
object A {
  def f(a: (
             Seq[Int],
               Seq[Int]) =
           (Seq(), Seq())): Unit = ???
}
>>>
object A {
  def f(
      a: (Seq[Int], Seq[Int]) =
        (Seq(), Seq())
  ): Unit = ???
}
<<< #4219
object a {
  val expression = for (
    x <- loremipsumdolorsitametconsecteturadipiscingelitseddoeiusmodtemporincididu;
    y <- loremipsumdolorsitametconsecteturadipiscingelitseddoeiusmodtemporincididu
  ) yield x + y
}
>>>
object a {
  val expression =
    for (
      x <-
        loremipsumdolorsitametconsecteturadipiscingelitseddoeiusmodtemporincididu;
      y <-
        loremipsumdolorsitametconsecteturadipiscingelitseddoeiusmodtemporincididu
    )
      yield x + y
}
<<< #4133 select chain with no-break comment before dot, short
maxColumn = 37
===
sel.getContext /*ScImportSelectors*/ .getContext.asInstanceOf[ScImportExpr].reference
>>>
sel
  .getContext /*ScImportSelectors*/
  .getContext
  .asInstanceOf[ScImportExpr]
  .reference
<<< #4133 select chain with no-break comment before dot, long
maxColumn = 80
===
sel.getContext /*ScImportSelectors*/ .getContext.asInstanceOf[ScImportExpr].reference
>>>
sel
  .getContext /*ScImportSelectors*/
  .getContext
  .asInstanceOf[ScImportExpr]
  .reference
<<< #4133 overflow ending in a `+`
maxColumn = 75
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
===
fraction.fold(" " * 6)(p => f"${100.0 * p}%5.1f%%") + " [" + ("#" * decile) +
  (" " * (10 - decile)) + "] " + downloaded + " source files formatted"
>>>
fraction.fold(" " * 6)(p => f"${100.0 * p}%5.1f%%") + " [" +
  ("#" * decile) +
  (" " * (10 - decile)) + "] " + downloaded + " source files formatted"
<<< #4133 multiple annotations
maxColumn = 80
===
@org.openjdk.jmh.annotations.State(Scope.Benchmark)
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@BenchmarkMode(Array(Mode.AverageTime)) @OutputTimeUnit(TimeUnit.SECONDS)
abstract class MacroBenchmark(parallel: Boolean, maxFiles: Int)
    extends FormatBenchmark {
  var files: GenIterable[String] = _
  }
>>>
@org.openjdk.jmh.annotations.State(Scope.Benchmark)
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.SECONDS)
abstract class MacroBenchmark(parallel: Boolean, maxFiles: Int)
    extends FormatBenchmark {
  var files: GenIterable[String] = _
}
<<< #4133 multiline string as case body
maxColumn = 80
===
val output = evaluated match {
  case s: String =>
    s"""|
        |"$s"""".stripMargin
  case x => x.toString
}
>>>
val output =
  evaluated match {
    case s: String =>
      s"""|
        |"$s"""".stripMargin
    case x =>
      x.toString
  }
<<< #4133 breaks in overflowing interpolation, allow
maxColumn = 76
===
object a {
  options.common.debug
    .print(s"Files to be formatted:\n${projectFiles.mkString("\n")}\n")
  options.common.debug.print(s"Files to be formatted:\n${projectFiles.mkString("\n")}\n")
}
>>>
object a {
  options
    .common
    .debug
    .print(s"Files to be formatted:\n${projectFiles.mkString("\n")}\n")
  options
    .common
    .debug
    .print(s"Files to be formatted:\n${projectFiles.mkString("\n")}\n")
}
<<< #4133 block function with rewritten empty-block body
maxColumn = 74
rewrite.rules = [RedundantBraces]
===
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner.runUninterruptibly {
  // Call `position` to wait until the potential offset request triggered by `poll(0)` is
  // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
  // `poll(0)` may reset offsets that should have been set by another request.
  partitions.asScala.map(p => p -> consumer.position(p)).foreach(_ => {})
}
>>>
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner
  .runUninterruptibly {
    // Call `position` to wait until the potential offset request triggered by `poll(0)` is
    // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
    // `poll(0)` may reset offsets that should have been set by another request.
    partitions
      .asScala
      .map(p => p -> consumer.position(p))
      .foreach { _ =>
      }
  }
<<< #4133 block function with rewritten empty-block body, braces to parens
maxColumn = 74
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.oneStatApply.parensMaxSpan = 500
===
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner.runUninterruptibly {
  // Call `position` to wait until the potential offset request triggered by `poll(0)` is
  // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
  // `poll(0)` may reset offsets that should have been set by another request.
  partitions.asScala.map(p => p -> consumer.position(p)).foreach(_ => {})
}
>>>
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner
  .runUninterruptibly(
    // Call `position` to wait until the potential offset request triggered by `poll(0)` is
    // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
    // `poll(0)` may reset offsets that should have been set by another request.
    partitions
      .asScala
      .map(p => p -> consumer.position(p))
      .foreach { _ =>
      }
  )
<<< #4133 block function with rewritten empty-block body, parens to braces 
maxColumn = 74
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.oneStatApply.bracesMinSpan = 1
===
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner.runUninterruptibly {
  // Call `position` to wait until the potential offset request triggered by `poll(0)` is
  // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
  // `poll(0)` may reset offsets that should have been set by another request.
  partitions.asScala.map(p => p -> consumer.position(p)).foreach(_ => {})
}
>>>
private def partitionsAssignedToConsumer = uninterruptibleThreadRunner
  .runUninterruptibly {
    // Call `position` to wait until the potential offset request triggered by `poll(0)` is
    // done. This is a workaround for KAFKA-7703, which an async `seekToBeginning` triggered by
    // `poll(0)` may reset offsets that should have been set by another request.
    partitions
      .asScala
      .map { p =>
        p -> consumer.position(p)
      }
      .foreach { _ =>
      }
  }
<<< #4133 rewritten def body as infix in parens with break before op
maxColumn = 76
rewrite {
  rules = [RedundantParens, RedundantBraces]
  redundantParens.infixSide = all
}
===
// Checks if sending a new push request will exceed the max no. of blocks being pushed to a
// given remote address.
def isRemoteAddressMaxedOut(remoteAddress: BlockManagerId, request: PushRequest): Boolean = {
  (numBlocksInFlightPerAddress.getOrElse(remoteAddress, 0)
    + request.blocks.size) > maxBlocksInFlightPerAddress
}
>>>
// Checks if sending a new push request will exceed the max no. of blocks being pushed to a
// given remote address.
def isRemoteAddressMaxedOut(
    remoteAddress: BlockManagerId,
    request: PushRequest
): Boolean =
  numBlocksInFlightPerAddress.getOrElse(remoteAddress, 0) +
    request.blocks.size > maxBlocksInFlightPerAddress
<<< #4133 redundant braces with an assign parameter
rewrite.rules = [RedundantBraces]
===
tryWithSafeFinallyAndFailureCallbacks {
  commitTask(taskContext)
}(catchBlock = {
  try {
    closeWriter(taskContext)
  } finally {
    abortTask(taskContext)
  }
})
>>>
tryWithSafeFinallyAndFailureCallbacks {
  commitTask(taskContext)
}(catchBlock =
  try closeWriter(taskContext)
  finally abortTask(taskContext)
)
<<< #4133 fold attached single-line comment, overflow
maxColumn = 80
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite {
  rules = [RedundantBraces]
  redundantBraces.ifElseExpressions = yes
}
===
object a {
  if (!mapStage.isAvailable) {
    waitingForVisit.prepend(mapStage.rdd)
  }  // Otherwise there's no need to follow the dependency back
}
>>>
object a {
  if (!mapStage.isAvailable)
    waitingForVisit.prepend(mapStage.rdd)
  // Otherwise there's no need to follow the dependency back
}
<<< #4133 fold attached single-line comment, !overflow
maxColumn = 80
rewrite {
  rules = [RedundantBraces]
  redundantBraces.ifElseExpressions = yes
}
===
object a {
  if (!mapStage.isAvailable) {
    waitingForVisit.prepend(mapStage.rdd)
  }  // Otherwise there's no need to follow the dependency back
}
>>>
object a {
  if (!mapStage.isAvailable)
    waitingForVisit.prepend(mapStage.rdd)
  // Otherwise there's no need to follow the dependency back
}
<<< #4133 braces to parens for single-line apply, with rewrite
maxColumn = 76
preset = default
newlines.source = fold
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite.rules = [RedundantBraces, RedundantParens]
===
convertStream(inputStream, tokenizer, handleHeader, parser.options.charset) { tokens =>
  safeParser.parse(tokens)
}.flatten
>>>
convertStream(inputStream, tokenizer, handleHeader, parser.options.charset) {
  tokens => safeParser.parse(tokens)
}.flatten
<<< #4133 braces to parens for single-line apply, with nested partial function
maxColumn = 74
newlines.source = fold
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite.rules = [RedundantBraces, RedundantParens]
===
val newExprs = exprs.map { _.transform {
  case a: AttributeReference => attrMap.getOrElse(a, a)
}}
>>>
val newExprs = exprs
  .map(_.transform { case a: AttributeReference => attrMap.getOrElse(a, a) })
<<< #4133 overflow comment with a forced break 1 
maxColumn = 76
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
===
if (c.name == "<local child>" /*scala.tools.nsc.symtab.StdNames.LOCAL_CHILD.toString()*/ ) {
  print("\n")
}
>>>
if (c.name == "<local child>" /*scala.tools.nsc.symtab.StdNames.LOCAL_CHILD.toString()*/ ) {
  print("\n")
}
<<< #4133 overflow comment with a forced break 2
maxColumn = 78
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite.rules = [RedundantBraces, RedundantParens]
===
def templates = symbols.filter(x => x.isClass || x.isTrait || x == AnyRefClass/* which is now a type alias */).toSet
>>>
def templates =
  symbols
    .filter(x => x.isClass || x.isTrait || x == AnyRefClass /* which is now a type alias */ )
    .toSet
<<< #4133 overflow comment with a forced break 3
maxColumn = 76
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite.rules = [RedundantBraces, RedundantParens]
===
def isNeverSubType(tp1: Type, tp2: Type): Boolean = /*logResult(s"isNeverSubType($tp1, $tp2)")*/((tp1.dealias, tp2.dealias) match {
  case (TypeRef(_, sym1, args1), TypeRef(_, sym2, args2)) =>
    isNeverSubClass(sym1, sym2) || {
      (sym1 isSubClass sym2) && {
        val tp1seen = tp1 baseType sym2
        isNeverSubArgs(tp1seen.typeArgs, args2, sym2.typeParams)
      }
    }
  case _ => false
})
>>>
def isNeverSubType(tp1: Type, tp2: Type): Boolean = /*logResult(s"isNeverSubType($tp1, $tp2)")*/
  (tp1.dealias, tp2.dealias) match {
    case (TypeRef(_, sym1, args1), TypeRef(_, sym2, args2)) =>
      isNeverSubClass(sym1, sym2) ||
      (sym1 isSubClass sym2) && {
        val tp1seen = tp1 baseType sym2
        isNeverSubArgs(tp1seen.typeArgs, args2, sym2.typeParams)
      }
    case _ =>
      false
  }
<<< #4133 redundant braces around assignment rhs infix
maxColumn = 70
rewrite.rules = [RedundantBraces]
===
if (buf.nonEmpty || privateWithin != "")
  buf += {"TypeName(\"" + privateWithin + "\")"}
>>>
if (buf.nonEmpty || privateWithin != "")
  buf += "TypeName(\"" + privateWithin + "\")"
<<< #4133 redundant braces around inner infix with overflow
maxColumn = 78
runner.dialect = scala3
newlines.avoidForSimpleOverflow = [tooLong, punct, slc]
rewrite.rules = [RedundantBraces]
===
override def isHidden(dia: Diagnostic)(using Context): Boolean =
  super.isHidden(dia) || {
      dia.msg.isNonSensical &&
      hasErrors && // if there are no errors yet, report even if diagnostic is non-sensical
      !ctx.settings.YshowSuppressedErrors.value
  }
>>>
override def isHidden(dia: Diagnostic)(using Context): Boolean =
  super.isHidden(dia) ||
    dia.msg.isNonSensical && hasErrors && // if there are no errors yet, report even if diagnostic is non-sensical
    !ctx.settings.YshowSuppressedErrors.value
<<< #4133 redundant braces around inner infix
maxColumn = 78
rewrite.rules = [RedundantBraces, RedundantParens]
===
lazy val defaultSettings: Seq[Setting[_]] = Def.settings(
  Dependencies.Versions,
  Compile / javacOptions ++= {
    DefaultJavacOptions ++
    JdkOptions.targetJdkJavacOptions(targetSystemJdk.value)
  },
  resolverSettings,
)
>>>
lazy val defaultSettings: Seq[Setting[_]] = Def.settings(
  Dependencies.Versions,
  Compile / javacOptions ++= DefaultJavacOptions ++
    JdkOptions.targetJdkJavacOptions(targetSystemJdk.value),
  resolverSettings
)
<<< #4133 redundant braces with overflow
maxColumn = 80
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
object a {
  def logAll(events: Seq[LogEvent]) = System.out.synchronized { events.foreach(log) } 
}
>>>
object a {
  def logAll(events: Seq[LogEvent]) = System
    .out
    .synchronized {
      events.foreach(log)
    }
}
<<< #4133 nested partial functions with overflow
preset = default
maxColumn = 80
newlines.source = unfold
#newlines.avoidForSimpleOverflow = all
===
system.dynamicAccess.createInstanceFor[Serializer](fqn, Nil).recoverWith {
  case _: NoSuchMethodException =>
    system.dynamicAccess
      .createInstanceFor[Serializer](
        fqn,
        List(classOf[ExtendedActorSystem] -> system, classOf[String] -> bindingName))
      .recoverWith {
        case _: NoSuchMethodException =>
          system.dynamicAccess
            .createInstanceFor[Serializer](
              fqn,
              List(classOf[ActorSystem] -> system, classOf[String] -> bindingName))
            .recoverWith {
              case _: NoSuchMethodException =>
                system.dynamicAccess
                  .createInstanceFor[Serializer](
                    fqn,
                    List(
                      classOf[ClassicActorSystemProvider] -> system,
                      classOf[String] -> bindingName))
                  .recoverWith {
                    case _: NoSuchMethodException =>
                      Failure(new NoSuchMethodException(
                        s"The serializer [$fqn] for binding [$bindingName] doesn't have a matching " +
                        s"constructor, see API documentation of ${classOf[Serializer].getName}"))
                  }
            }
      }
}
>>>
system
  .dynamicAccess
  .createInstanceFor[Serializer](fqn, Nil)
  .recoverWith { case _: NoSuchMethodException =>
    system
      .dynamicAccess
      .createInstanceFor[Serializer](
        fqn,
        List(
          classOf[ExtendedActorSystem] -> system,
          classOf[String] -> bindingName
        )
      )
      .recoverWith { case _: NoSuchMethodException =>
        system
          .dynamicAccess
          .createInstanceFor[Serializer](
            fqn,
            List(classOf[ActorSystem] -> system, classOf[String] -> bindingName)
          )
          .recoverWith { case _: NoSuchMethodException =>
            system
              .dynamicAccess
              .createInstanceFor[Serializer](
                fqn,
                List(
                  classOf[ClassicActorSystemProvider] -> system,
                  classOf[String] -> bindingName
                )
              )
              .recoverWith { case _: NoSuchMethodException =>
                Failure(
                  new NoSuchMethodException(
                    s"The serializer [$fqn] for binding [$bindingName] doesn't have a matching " +
                      s"constructor, see API documentation of ${classOf[
                          Serializer
                        ].getName}"
                  )
                )
              }
          }
      }
  }
<<< #4133 braces to parens with inner parens, possible non-idempotency
preset = default
newlines.source = unfold
rewrite.rules = [RedundantBraces]
===
object a {
  override def deleteAsync(persistenceId: String, criteria: SnapshotSelectionCriteria): Future[Unit] = {
    val metadatas = snapshotMetadatas(persistenceId, criteria)
    Future
      .sequence {
        metadatas.map(deleteAsync)
      }(scala.collection.immutable.IndexedSeq, streamDispatcher)
      .map(_ => ())(streamDispatcher)
  }
}
>>>
object a {
  override def deleteAsync(
      persistenceId: String,
      criteria: SnapshotSelectionCriteria
  ): Future[Unit] = {
    val metadatas = snapshotMetadatas(persistenceId, criteria)
    Future
      .sequence {
        metadatas.map(deleteAsync)
      }(scala.collection.immutable.IndexedSeq, streamDispatcher)
      .map(_ => ())(streamDispatcher)
  }
}
<<< #4133 braces to parens with anon func and inner parens, possible non-idempotency
maxColumn = 76
rewrite.rules = [RedundantBraces]
===
val accumUpdatesWithTaskIds: Array[(Long, Int, Int, Seq[AccumulableInfo])] = {
  accumUpdates { case (id, updates) =>
    taskIdToTaskSetManager { taskSetMgr =>
      getTaskAccumulableInfosAndProcessRate(updates)
      if (efficientTaskCalcualtionEnabled) {
        taskSetMgr.taskProcessRateCalculator.foreach {
          _.updateRunningTaskProcessRate(id, taskProcessRate)
        }
      }
    }
  }
}
>>>
val accumUpdatesWithTaskIds: Array[(Long, Int, Int, Seq[AccumulableInfo])] =
  accumUpdates { case (id, updates) =>
    taskIdToTaskSetManager { taskSetMgr =>
      getTaskAccumulableInfosAndProcessRate(updates)
      if (efficientTaskCalcualtionEnabled) {
        taskSetMgr
          .taskProcessRateCalculator
          .foreach {
            _.updateRunningTaskProcessRate(id, taskProcessRate)
          }
      }
    }
  }
<<< #4133 redundant braces with nested partial function 
maxColumn = 76
rewrite.rules = [RedundantBraces]
===
object a {
  val defaultMethodNames = defaultGetterNames.map { _.replace {
    case DefaultGetterName(methName, _) => methName
  }}
}
>>>
object a {
  val defaultMethodNames = defaultGetterNames.map {
    _.replace { case DefaultGetterName(methName, _) =>
      methName
    }
  }
}
<<< #4133 braces to parens with two curried params
maxColumn = 74
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
Utils.tryWithSafeFinally {
  serializeStream.writeObject(partitioner)
} {
  serializeStream.close()
}
>>>
Utils.tryWithSafeFinally {
  serializeStream.writeObject(partitioner)
} {
  serializeStream.close()
}
<<< #4133 braces to parens with two curried params 2
maxColumn = 74
rewrite.rules = [RedundantBraces]
===
adjustStart(accept(AT)) {
  ensureApplied(parArgumentExprss(wrapNew(simpleType1())))
}
>>>
adjustStart(accept(AT)) {
  ensureApplied(parArgumentExprss(wrapNew(simpleType1())))
}
<<< #4133 braces to parens with two curried params, second func
maxColumn = 76
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
val offsets = Utils.tryWithResource {
  new DataInputStream(Files.newInputStream(indexFile.toPath))
} { dis =>
  dis.readFully(buffer.array)
  buffer.asLongBuffer
}
>>>
val offsets =
  Utils.tryWithResource {
    new DataInputStream(Files.newInputStream(indexFile.toPath))
  } { dis =>
    dis.readFully(buffer.array)
    buffer.asLongBuffer
  }
<<< #4133 braces to parens with two curried params, second contextual func
maxColumn = 76
runner.dialect = scala3
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
val offsets = Utils.tryWithResource {
  new DataInputStream(Files.newInputStream(indexFile.toPath))
} { dis ?=>
  dis.readFully(buffer.array)
  buffer.asLongBuffer
}
>>>
val offsets =
  Utils.tryWithResource {
    new DataInputStream(Files.newInputStream(indexFile.toPath))
  } { dis ?=>
    dis.readFully(buffer.array)
    buffer.asLongBuffer
  }
<<< #4133 braces to parens with two curried params, second poly func
maxColumn = 76
runner.dialect = scala3
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
val offsets = Utils.tryWithResource {
  new DataInputStream(Files.newInputStream(indexFile.toPath))
} { [dis] =>
  dis.readFully(buffer.array)
  buffer.asLongBuffer
}
>>>
val offsets =
  Utils.tryWithResource {
    new DataInputStream(Files.newInputStream(indexFile.toPath))
  } { [dis] =>
    dis.readFully(buffer.array)
    buffer.asLongBuffer
  }
<<< #4133 braces to parens with two curried params, second func and comment
maxColumn = 76
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
val offsets = Utils.tryWithResource {
  new DataInputStream(Files.newInputStream(indexFile.toPath))
} { dis =>
  // dis.readFully(buffer.array)
  buffer.asLongBuffer
}
>>>
val offsets =
  Utils.tryWithResource {
    new DataInputStream(Files.newInputStream(indexFile.toPath))
  } { dis =>
    // dis.readFully(buffer.array)
    buffer.asLongBuffer
  }
<<< #4133 braces to parens with func
preset = default
newlines.source = fold
maxColumn = 80
newlines.avoidForSimpleOverflow = all
rewrite {
  rules = [RedundantBraces, RedundantParens]
  redundantBraces.preset = all
}
===
object a {
  def union(other: Dataset[T]): Dataset[T] = {
    buildSetOp(other, proto.SetOperation.SetOpType.SET_OP_TYPE_UNION) { builder =>
      builder.setIsAll(true)
    }
  }
}
>>>
object a {
  def union(other: Dataset[T]): Dataset[T] =
    buildSetOp(other, proto.SetOperation.SetOpType.SET_OP_TYPE_UNION) { builder =>
      builder.setIsAll(true)
    }
}
<<< #4133 braces to parens with func
maxColumn = 68
rewrite.rules = [RedundantBraces]
===
val worker = Flow[T]
  .fold(new FirstCollectorState(factory): CollectorState[T, R]) { (state, elem) =>
    state.update(elem)
  }
>>>
val worker =
  Flow[T].fold(
    new FirstCollectorState(factory): CollectorState[T, R]
  ) { (state, elem) =>
    state.update(elem)
  }
<<< #4133 braces to parens with func, originally in parens with body block
maxColumn = 76
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
repeatTakeMapAndFold = fuse(
  Source
    .repeat(new MutableElement(0))
    .take(ElementCount)
    .map(addFunc)
    .map(addFunc)
    .fold(new MutableElement(0))((acc, x) => { acc.value += x.value; acc })
    .toMat(testSink)(Keep.right))
>>>
repeatTakeMapAndFold = fuse(
  Source
    .repeat(new MutableElement(0))
    .take(ElementCount)
    .map(addFunc)
    .map(addFunc)
    .fold(new MutableElement(0)) { (acc, x) =>
      acc.value += x.value;
      acc
    }
    .toMat(testSink)(Keep.right)
)
<<< #4133 parens to braces, with function as argument
maxColumn = 72
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.maxBreaks = 3 
===
val seqArgs = map3(newPs, oldPs, isRepeated)((param, oldParam, isRep) => {
  if (!isRep) Ident(param)
  else {
    val parTp = elementType(ArrayClass, param.tpe)
    val wrap = gen.mkWrapArray(Ident(param), parTp)
  }
})
>>>
val seqArgs =
  map3(newPs, oldPs, isRepeated) { (param, oldParam, isRep) =>
    if (!isRep)
      Ident(param)
    else {
      val parTp = elementType(ArrayClass, param.tpe)
      val wrap = gen.mkWrapArray(Ident(param), parTp)
    }
  }
<<< #4133 parens to braces, with contextual function as argument
maxColumn = 72
runner.dialect = scala3
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.maxBreaks = 3 
===
val seqArgs = map3(newPs, oldPs, isRepeated)((param, oldParam, isRep) ?=> {
  if (!isRep) Ident(param)
  else {
    val parTp = elementType(ArrayClass, param.tpe)
    val wrap = gen.mkWrapArray(Ident(param), parTp)
  }
})
>>>
val seqArgs =
  map3(newPs, oldPs, isRepeated) { (param, oldParam, isRep) ?=>
    if (!isRep)
      Ident(param)
    else {
      val parTp = elementType(ArrayClass, param.tpe)
      val wrap = gen.mkWrapArray(Ident(param), parTp)
    }
  }
<<< #4133 parens to braces, with poly function as argument
maxColumn = 72
runner.dialect = scala3
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.maxBreaks = 3 
===
val seqArgs = map3(newPs, oldPs, isRepeated)([param__oldParam__isRep] => {
  if (!isRep) Ident(param)
  else {
    val parTp = elementType(ArrayClass, param.tpe)
    val wrap = gen.mkWrapArray(Ident(param), parTp)
  }
})
>>>
val seqArgs =
  map3(newPs, oldPs, isRepeated) { [param__oldParam__isRep] =>
    if (!isRep)
      Ident(param)
    else {
      val parTp = elementType(ArrayClass, param.tpe)
      val wrap = gen.mkWrapArray(Ident(param), parTp)
    }
  }
<<< #4133 keep parens, remove braces, with function as argument
maxColumn = 72
rewrite.rules = [RedundantBraces]
===
val seqArgs = map3(newPs, oldPs, isRepeated)((param, oldParam, isRep) => {
  if (!isRep) Ident(param)
  else {
    val parTp = elementType(ArrayClass, param.tpe)
    val wrap = gen.mkWrapArray(Ident(param), parTp)
  }
})
>>>
val seqArgs =
  map3(newPs, oldPs, isRepeated)((param, oldParam, isRep) =>
    if (!isRep)
      Ident(param)
    else {
      val parTp = elementType(ArrayClass, param.tpe)
      val wrap = gen.mkWrapArray(Ident(param), parTp)
    }
  )
<<< #4133 nested apply followed by select
maxColumn = 80
newlines.avoidForSimpleOverflow = all
===
object a {
  def encodeCookieHeader(cookies: Seq[Cookie]): String = {
    encoder.encode(cookies.map(cookie => new DefaultCookie(cookie.name, cookie.value)).asJava)
  }
}
>>>
object a {
  def encodeCookieHeader(cookies: Seq[Cookie]): String = {
    encoder.encode(
      cookies.map(cookie => new DefaultCookie(cookie.name, cookie.value)).asJava
    )
  }
}
<<< #4133 braces-to-parens with nested apply followed by select
maxColumn = 80
newlines.avoidForSimpleOverflow = all
rewrite {
  rules = [RedundantBraces, RedundantParens]
  redundantBraces.preset = all
}
===
object a {
  def encodeCookieHeader(cookies: Seq[Cookie]): String = {
    encoder.encode(cookies.map { cookie => new DefaultCookie(cookie.name, cookie.value) }.asJava)
  }
}
>>>
object a {
  def encodeCookieHeader(cookies: Seq[Cookie]): String = encoder.encode(
    cookies
      .map { cookie =>
        new DefaultCookie(cookie.name, cookie.value)
      }
      .asJava
  )
}
<<< #4133 braces-to-parens with select, apply of nested match
maxColumn = 76
rewrite.rules = [RedundantBraces]
===
val properties = propertyArgs.map {
  _.drop(2).span(_ != '=') match {
    case (key, v) => key -> v.tail
  }
}
>>>
val properties = propertyArgs.map {
  _.drop(2).span(_ != '=') match {
    case (key, v) =>
      key -> v.tail
  }
}
<<< #4133 braces-to-parens with select, apply of nested for-yield, with overflow
maxColumn = 74
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
runtime.unsafe.run {
  for {
    _ <- ZIO.foreachDiscard(1.to(n))(_ => ZIO.yieldNow)
  } yield ()
}.getOrThrowFiberFailure()
>>>
runtime
  .unsafe
  .run {
    for {
      _ <- ZIO.foreachDiscard(1.to(n))(_ => ZIO.yieldNow)
    } yield ()
  }
  .getOrThrowFiberFailure()
<<< #4133 first call in removed braces
maxColumn = 78
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
val WatchHeartBeatInterval: FiniteDuration = {
  WatchFailureDetectorConfig.getMillisDuration("heartbeat-interval")
}.requiring(_ > Duration.Zero, "watch-failure-detector.heartbeat-interval must be > 0")
>>>
val WatchHeartBeatInterval: FiniteDuration = WatchFailureDetectorConfig
  .getMillisDuration("heartbeat-interval")
  .requiring(
    _ > Duration.Zero,
    "watch-failure-detector.heartbeat-interval must be > 0"
  )
<<< #4133 braces-to-parens with select, apply of nested apply, with overflow
maxColumn = 76
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces]
===
def commaSeparated[T](part: () => T): List[T] =
  in.currentRegion.withCommasExpected {
    commaSeparatedRest(part(), part)
  }
>>>
def commaSeparated[T](part: () => T): List[T] = in
  .currentRegion
  .withCommasExpected {
    commaSeparatedRest(part(), part)
  }
<<< #4133 enclosed infix within removed defn body block
maxColumn = 76
newlines.avoidForSimpleOverflow = all
rewrite.rules = [RedundantBraces, RedundantParens, AvoidInfix]
===
def stop(step: Double, ndir: Double, nx: Double): Boolean = {
    ((step.isNaN) // NaN
  || (step < 1e-7) // too small or negative
  || (step > 1e40) // too small; almost certainly numerical problems
  || (ndir < 1e-12 * nx) // gradient relatively too small
  || (ndir < 1e-32) // gradient absolutely too small; numerical issues may lurk
  )
}
>>>
def stop(step: Double, ndir: Double, nx: Double): Boolean = (
  (step.isNaN) // NaN
  ||
    (step < 1e-7) // too small or negative
    ||
    (step > 1e40) // too small; almost certainly numerical problems
    ||
    (ndir < 1e-12 * nx) // gradient relatively too small
    ||
    (ndir < 1e-32) // gradient absolutely too small; numerical issues may lurk
)
<<< #4542 narrow
maxColumn = 40
binPack.parentConstructors = source
===
class SomeClass(a: Int, b: Double, c: String)
extends SomeBaseClass
with SomeTrait
>>>
class SomeClass(
    a: Int,
    b: Double,
    c: String
) extends SomeBaseClass
    with SomeTrait
<<< #4542 medium
maxColumn = 50
binPack.parentConstructors = source
===
class SomeClass(a: Int, b: Double, c: String)
extends SomeBaseClass
with SomeTrait
>>>
class SomeClass(a: Int, b: Double, c: String)
    extends SomeBaseClass
    with SomeTrait
<<< #4542 wide
maxColumn = 100
binPack.parentConstructors = source
===
class SomeClass(a: Int, b: Double, c: String)
extends SomeBaseClass
with SomeTrait
>>>
class SomeClass(a: Int, b: Double, c: String) extends SomeBaseClass with SomeTrait
<<< if-else with one block, short
maxColumn = 40
===
object a {
  if (s.costWithPenalty > 0) { preFork = false; false } else true

  if (s.costWithPenalty <= 0) true else { preFork = false; false }
}
>>>
object a {
  if (s.costWithPenalty > 0) {
    preFork = false;
    false
  } else
    true

  if (s.costWithPenalty <= 0)
    true
  else {
    preFork = false;
    false
  }
}
<<< if-else with one block, medium
maxColumn = 60
===
object a {
  if (s.costWithPenalty > 0) { preFork = false; false } else true

  if (s.costWithPenalty <= 0) true else { preFork = false; false }
}
>>>
object a {
  if (s.costWithPenalty > 0) {
    preFork = false;
    false
  } else
    true

  if (s.costWithPenalty <= 0)
    true
  else {
    preFork = false;
    false
  }
}
<<< if-else with one block, long
maxColumn = 80
===
object a {
  if (s.costWithPenalty > 0) { preFork = false; false } else true

  if (s.costWithPenalty <= 0) true else { preFork = false; false }
}
>>>
object a {
  if (s.costWithPenalty > 0) {
    preFork = false;
    false
  } else
    true

  if (s.costWithPenalty <= 0)
    true
  else {
    preFork = false;
    false
  }
}
<<< chained maps with multi-line blocks, with braces-to-parens OK
rewrite.rules = [RedundantBraces]
===
object a {
  def foo = bar {
    // c1
    baz
  }.qux { x =>
    // c2
    quux(x)
  }
}
>>>
object a {
  def foo = bar {
    // c1
    baz
  }.qux { x =>
    // c2
    quux(x)
  }
}
<<< chained maps with multi-line blocks, with braces-to-parens not OK
object a {
  def foo = bar {
    // c1
    baz
  }.qux { x =>
      // c2
      quux(x)
    }
}
>>>
object a {
  def foo = bar {
    // c1
    baz
  }.qux { x =>
    // c2
    quux(x)
  }
}
<<< #4133 select with braced apply and single function arg, !parensForOneLineApply
maxColumn = 74
newlines {
  avoidForSimpleOverflow = [punct, slc, tooLong]
  ignoreInSyntax = false
}
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.parensForOneLineApply = false
===
  topLevelStatementBlankLines.filter(x => x.minNest <= x.maxNest).sortBy { x =>
    (x.minBreaks, x.maxNest, -x.minNest, x.regex.fold(0)(-_.length))
  }
>>>
topLevelStatementBlankLines
  .filter(x => x.minNest <= x.maxNest)
  .sortBy { x =>
    (x.minBreaks, x.maxNest, -x.minNest, x.regex.fold(0)(-_.length))
  }
<<< #4133 select with braced apply and single function arg, parensForOneLineApply
maxColumn = 74
newlines {
  avoidForSimpleOverflow = [punct, slc, tooLong]
  ignoreInSyntax = false
}
rewrite.rules = [RedundantBraces]
rewrite.redundantBraces.parensForOneLineApply = true
===
  topLevelStatementBlankLines.filter(x => x.minNest <= x.maxNest).sortBy { x =>
    (x.minBreaks, x.maxNest, -x.minNest, x.regex.fold(0)(-_.length))
  }
>>>
topLevelStatementBlankLines
  .filter(x => x.minNest <= x.maxNest)
  .sortBy { x =>
    (x.minBreaks, x.maxNest, -x.minNest, x.regex.fold(0)(-_.length))
  }
<<< complex infix with final rhs an apply with multiline block
maxColumn = 80
===
object a {
  def memberRef(description: String) = u2 ~ u2 ^^ add1 {
    case classRef ~ nameAndTypeRef => pool => description + ": " + pool(classRe
f) + ", " + pool(nameAndTypeRef)
  }
}
>>>
object a {
  def memberRef(description: String) =
    u2 ~ u2 ^^
      add1 { case classRef ~ nameAndTypeRef =>
        pool =>
          description + ": " + pool(classRe f) + ", " + pool(nameAndTypeRef)
      }
}
<<< don't rewrite to braces apply with function and infix as arg
rewrite.redundantBraces.oneStatApply.bracesMinSpan = 1
rewrite.rules = [RedundantBraces, RedundantParens]
===
val sym1 = sym filter (alt =>
     isApplicableBasedOnArity(pre memberType alt, argtypes.length, varargsStar = false, tuplingAllowed = false)
  || alt.tpe.params.exists(_.hasDefault)
)
>>>
val sym1 =
  sym filter { alt =>
    isApplicableBasedOnArity(
      pre memberType alt,
      argtypes.length,
      varargsStar = false,
      tuplingAllowed = false
    ) ||
    alt
      .tpe
      .params
      .exists {
        _.hasDefault
      }
  }
<<< zio, nested tests and suites, with redundant braces to parens rewrite
maxColumn = 80
runner.optimizer.maxVisitsPerToken = 20000
newlines.avoidForSimpleOverflow = all
rewrite {
  rules = [RedundantBraces]
  redundantBraces.preset = all
  redundantBraces.oneStatApply.parensMaxSpan = 500
}
===
object ZStreamSpec extends DefaultRunnableSpec {
  def spec: ZSpec[Environment, Failure] =
    suite("ZStreamSpec")(
      suite("Combinators")(
        suite("aggregateAsyncWithin")(
          testM("aggregateAsyncWithin") (
            assertM(
              ZStream(1, 1, 1, 1, 2, 2)
                .aggregateAsyncWithin(
                  ZTransducer
                    .fold((List[Int](), true))(_._2) ( (acc, el: Int) =>
                      if (el == 1) (el :: acc._1, true)
                      else if (el == 2 && acc._1.isEmpty) (el :: acc._1, false)
                      else (el :: acc._1, false)
                    )
                    .map(_._1),
                  Schedule.spaced(30.minutes)
                )
                .runCollect
            )(equalTo(Chunk(List(2, 1, 1, 1, 1), List(2))))
          )
        ),
        
        
        suite("bufferDropping")(
          testM("buffer the Stream with Error") (
            assertM(
              (ZStream.range(1, 1000) ++ ZStream.fail(e) ++ ZStream.range(1001, 2000))
            )(fails(equalTo(e)))
          ),
          testM("fast producer progress independently") (
            for {
              s1 = ZStream(0) ++ ZStream
                .fromEffect(latch1.await)
                .flatMap(_ => ZStream.range(1, 17).chunkN(1).ensuring(latch2.succeed(())))
              snapshots <- s.process.use ( as =>
                for {
                  _         <- latch1.succeed(())
                  _         <- as.flatMap(a => ref.update(a.toList ::: _)).repeatN(7)
                  snapshot1 <- ref.get
                  _         <- latch3.succeed(())
                  _         <- latch4.await
                  _         <- as.flatMap(a => ref.update(a.toList ::: _)).repeatN(7)
                  snapshot2 <- ref.get
                } yield (zero, snapshot1, snapshot2)
              )
            } yield assert(snapshots._1)(equalTo(Chunk.single(0))) && assert(snapshots._2)(
              equalTo(List(8, 7, 6, 5, 4, 3, 2, 1))
            ) &&
              assert(snapshots._3)(
                equalTo(List(24, 23, 22, 21, 20, 19, 18, 17, 8, 7, 6, 5, 4, 3, 2, 1))
              )
          )
        ),
      ),
    )

}
>>>
object ZStreamSpec extends DefaultRunnableSpec {
  def spec: ZSpec[Environment, Failure] =
    suite("ZStreamSpec")(
      suite("Combinators")(
        suite("aggregateAsyncWithin")(
          testM("aggregateAsyncWithin")(
            assertM(
              ZStream(1, 1, 1, 1, 2, 2)
                .aggregateAsyncWithin(
                  ZTransducer
                    .fold((List[Int](), true))(_._2)((acc, el: Int) =>
                      if (el == 1)
                        (el :: acc._1, true)
                      else if (el == 2 && acc._1.isEmpty)
                        (el :: acc._1, false)
                      else
                        (el :: acc._1, false)
                    )
                    .map(_._1),
                  Schedule.spaced(30.minutes)
                )
                .runCollect
            )(equalTo(Chunk(List(2, 1, 1, 1, 1), List(2))))
          )
        ),

        suite("bufferDropping")(
          testM("buffer the Stream with Error")(
            assertM(
              (
                ZStream.range(1, 1000) ++ ZStream.fail(e) ++
                  ZStream.range(1001, 2000)
              )
            )(fails(equalTo(e)))
          ),
          testM("fast producer progress independently")(
            for {
              s1 =
                ZStream(0) ++
                  ZStream
                    .fromEffect(latch1.await)
                    .flatMap(_ =>
                      ZStream.range(1, 17).chunkN(1).ensuring(latch2.succeed(()))
                    )
              snapshots <- s
                .process
                .use(as =>
                  for {
                    _ <- latch1.succeed(())
                    _ <- as.flatMap(a => ref.update(a.toList ::: _)).repeatN(7)
                    snapshot1 <- ref.get
                    _ <- latch3.succeed(())
                    _ <- latch4.await
                    _ <- as.flatMap(a => ref.update(a.toList ::: _)).repeatN(7)
                    snapshot2 <- ref.get
                  } yield (zero, snapshot1, snapshot2)
                )
            } yield assert(snapshots._1)(equalTo(Chunk.single(0))) &&
              assert(snapshots._2)(equalTo(List(8, 7, 6, 5, 4, 3, 2, 1))) &&
              assert(snapshots._3)(
                equalTo(
                  List(24, 23, 22, 21, 20, 19, 18, 17, 8, 7, 6, 5, 4, 3, 2, 1)
                )
              )
          )
        )
      )
    )

}
<<< keep function in braces if contains nested function with multi-stat block
maxColumn = 80
newlines.avoidForSimpleOverflow = all
rewrite {
  rules = [RedundantBraces]
  redundantBraces.preset = all
  redundantBraces.oneStatApply.parensMaxSpan = 500
}
===
object a {
  def ignoreAfterCancellation[T]: Flow[T, T, Future[Done]] = {
    Flow.fromGraph(GraphDSL.createGraph(Sink.ignore) { implicit builder => ignore =>
      import GraphDSL.Implicits._
      // This pattern is an effective way to absorb cancellation, Sink.ignore will keep the broadcast always flowing
      // even after sink.inlet cancels.
      val broadcast = builder.add(Broadcast[T](2, eagerCancel = false))
      broadcast.out(0) ~> ignore.in
      FlowShape(broadcast.in, broadcast.out(1))
    })
  }
}
>>>
object a {
  def ignoreAfterCancellation[T]: Flow[T, T, Future[Done]] = Flow.fromGraph(
    GraphDSL.createGraph(Sink.ignore) { implicit builder => ignore =>
      import GraphDSL.Implicits._
      // This pattern is an effective way to absorb cancellation, Sink.ignore will keep the broadcast always flowing
      // even after sink.inlet cancels.
      val broadcast = builder.add(Broadcast[T](2, eagerCancel = false))
      broadcast.out(0) ~> ignore.in
      FlowShape(broadcast.in, broadcast.out(1))
    }
  )
}
<<< detect rewritten parens-to-braces in nested opens rule
maxColumn = 74
rewrite {
  rules = [RedundantBraces]
  redundantBraces {
    preset = all
    oneStatApply {
      parensMaxSpan = 100
      bracesMinSpan = 100
    }
  }
}
===
val bypasser = Flow.fromGraph(GraphDSL.create[FlowShape[Either[FlowIn, Out], Out]]() { implicit builder =>
  import GraphDSL.Implicits._

  FlowShape(broadcast.in, merge.out)
})
>>>
val bypasser = Flow.fromGraph {
  GraphDSL.create[FlowShape[Either[FlowIn, Out], Out]]() {
    implicit builder =>
      import GraphDSL.Implicits._

      FlowShape(broadcast.in, merge.out)
  }
}
<<< #4704 Decl.Def with refined decltpe
maxColumn = 90
===
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  }
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  }
}
>>>
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  }
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  }
}
<<< #4704 Defn.Def with refined decltpe
maxColumn = 90
===
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = foo
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = foo
}
>>>
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = foo
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = foo
}
<<< #4704 Defn.DefMacro with refined decltpe
maxColumn = 90
===
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = macro foo
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = macro foo
}
>>>
object ops {
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = macro foo
  implicit def toAllConsKOps[F[_], A](target: F[A])(implicit_tc: ConsK[F]): AllOps[F, A] {
    type TypeClassType = ConsK[F]
  } = macro foo
}
<<< #4705 term=src, type=many
newlines.infix.typeSite.style = many
===
object Foo {
  def oldStyle: Traverse[Option] with MonadError[Option, Unit] with Alternative[Option] with CommutativeMonad[Option] with CoflatMap[Option] with Align[Option] =
    ???

  def newStyle: Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option] =
    Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option]
}
>>>
object Foo {
  def oldStyle: Traverse[Option]
    with MonadError[Option, Unit]
    with Alternative[Option]
    with CommutativeMonad[Option]
    with CoflatMap[Option]
    with Align[Option] = ???

  def newStyle: Traverse[Option] &
    MonadError[Option, Unit] &
    Alternative[Option] &
    CommutativeMonad[Option] &
    CoflatMap[Option] & Align[Option] =
    Traverse[Option] &
      MonadError[Option, Unit] &
      Alternative[Option] &
      CommutativeMonad[Option] &
      CoflatMap[Option] & Align[Option]
}
<<< #4705 term=some, type=keep
maxColumn = 80
newlines.infix.termSite.style = some
newlines.infix.typeSite.maxCountPerFileForKeep = 0
===
object Foo {
  def oldStyle: Traverse[Option] with MonadError[Option, Unit] with Alternative[Option] with CommutativeMonad[Option] with CoflatMap[Option] with Align[Option] =
    ???

  def newStyle: Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option] =
    Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option]
}
>>>
object Foo {
  def oldStyle: Traverse[Option]
    with MonadError[Option, Unit]
    with Alternative[Option]
    with CommutativeMonad[Option]
    with CoflatMap[Option]
    with Align[Option] = ???

  def newStyle: Traverse[Option] & MonadError[Option, Unit] &
    Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] &
    Align[Option] =
    Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] &
      CommutativeMonad[Option] & CoflatMap[Option] & Align[Option]
}
<<< #4705 term=keep, type=some
maxColumn = 80
newlines.infix.termSite.maxCountPerFileForKeep = 0
newlines.infix.typeSite.style = some
===
object Foo {
  def oldStyle: Traverse[Option] with MonadError[Option, Unit] with Alternative[Option] with CommutativeMonad[Option] with CoflatMap[Option] with Align[Option] =
    ???

  def newStyle: Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option] =
    Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] & Align[Option]
}
>>>
object Foo {
  def oldStyle: Traverse[Option]
    with MonadError[Option, Unit]
    with Alternative[Option]
    with CommutativeMonad[Option]
    with CoflatMap[Option]
    with Align[Option] = ???

  def newStyle: Traverse[Option] & MonadError[Option, Unit] &
    Alternative[Option] & CommutativeMonad[Option] & CoflatMap[Option] &
    Align[Option] =
    Traverse[Option] & MonadError[Option, Unit] & Alternative[Option] &
      CommutativeMonad[Option] & CoflatMap[Option] & Align[Option]
}
<<< consistency between string and interpolation: stripMargin, ignoreInSyntax
maxColumn = 40
align.stripMargin = true
newlines.ignoreInSyntax = true
assumeStandardLibraryStripMargin = true
===
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i = s"""bar
   baz
   qux"""
  val foo2s = """|bar
   |baz
   |qux""".stripMargin
  val foo2i = s"""|bar
   |baz
   |qux""".stripMargin
  val foo3si = """|bar
   |baz
   |qux""".stripMargin + s"""|bar
   |baz
   |qux""".stripMargin
  val foo3is = s"""|bar
   |baz
   |qux""".stripMargin + """|bar
   |baz
   |qux""".stripMargin
}
>>>
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i =
    s"""bar
   baz
   qux"""
  val foo2s =
    """|bar
       |baz
       |qux""".stripMargin
  val foo2i =
    s"""|bar
        |baz
        |qux""".stripMargin
  val foo3si =
    """|bar
       |baz
       |qux""".stripMargin +
      s"""|bar
          |baz
          |qux""".stripMargin
  val foo3is =
    s"""|bar
        |baz
        |qux""".stripMargin +
      """|bar
         |baz
         |qux""".stripMargin
}
<<< consistency between string and interpolation: stripMargin, !ignoreInSyntax
maxColumn = 40
align.stripMargin = true
newlines.ignoreInSyntax = false
assumeStandardLibraryStripMargin = true
===
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i = s"""bar
   baz
   qux"""
  val foo2s = """|bar
   |baz
   |qux""".stripMargin
  val foo2i = s"""|bar
   |baz
   |qux""".stripMargin
  val foo3si = """|bar
   |baz
   |qux""".stripMargin + s"""|bar
   |baz
   |qux""".stripMargin
  val foo3is = s"""|bar
   |baz
   |qux""".stripMargin + """|bar
   |baz
   |qux""".stripMargin
}
>>>
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i =
    s"""bar
   baz
   qux"""
  val foo2s =
    """|bar
       |baz
       |qux""".stripMargin
  val foo2i =
    s"""|bar
        |baz
        |qux""".stripMargin
  val foo3si =
    """|bar
       |baz
       |qux""".stripMargin +
      s"""|bar
          |baz
          |qux""".stripMargin
  val foo3is =
    s"""|bar
        |baz
        |qux""".stripMargin +
      """|bar
         |baz
         |qux""".stripMargin
}
<<< consistency between string and interpolation: !stripMargin, ignoreInSyntax
maxColumn = 40
align.stripMargin = false
newlines.ignoreInSyntax = true
assumeStandardLibraryStripMargin = true
===
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i = s"""bar
   baz
   qux"""
  val foo2s = """|bar
   |baz
   |qux""".stripMargin
  val foo2i = s"""|bar
   |baz
   |qux""".stripMargin
  val foo3si = """|bar
   |baz
   |qux""".stripMargin + s"""|bar
   |baz
   |qux""".stripMargin
  val foo3is = s"""|bar
   |baz
   |qux""".stripMargin + """|bar
   |baz
   |qux""".stripMargin
}
>>>
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i =
    s"""bar
   baz
   qux"""
  val foo2s =
    """|bar
      |baz
      |qux""".stripMargin
  val foo2i =
    s"""|bar
      |baz
      |qux""".stripMargin
  val foo3si =
    """|bar
      |baz
      |qux""".stripMargin + s"""|bar
      |baz
      |qux""".stripMargin
  val foo3is =
    s"""|bar
      |baz
      |qux""".stripMargin + """|bar
      |baz
      |qux""".stripMargin
}
<<< consistency between string and interpolation: !stripMargin, !ignoreInSyntax
maxColumn = 40
align.stripMargin = false
newlines.ignoreInSyntax = false
assumeStandardLibraryStripMargin = true
===
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i = s"""bar
   baz
   qux"""
  val foo2s = """|bar
   |baz
   |qux""".stripMargin
  val foo2i = s"""|bar
   |baz
   |qux""".stripMargin
  val foo3si = """|bar
   |baz
   |qux""".stripMargin + s"""|bar
   |baz
   |qux""".stripMargin
  val foo3is = s"""|bar
   |baz
   |qux""".stripMargin + """|bar
   |baz
   |qux""".stripMargin
}
>>>
object a {
  val foo1s = """bar
   baz
   qux"""
  val foo1i =
    s"""bar
   baz
   qux"""
  val foo2s =
    """|bar
      |baz
      |qux""".stripMargin
  val foo2i =
    s"""|bar
      |baz
      |qux""".stripMargin
  val foo3si =
    """|bar
      |baz
      |qux""".stripMargin +
      s"""|bar
        |baz
        |qux""".stripMargin
  val foo3is =
    s"""|bar
      |baz
      |qux""".stripMargin +
      """|bar
        |baz
        |qux""".stripMargin
}
<<< `do` starts a new statement, narrow, danglingParentheses.ctrlSite
danglingParentheses.ctrlSite = true
===
def foo = {
    next.offset = begCharOffset
    do putCharAndNext()
    while (ch != CR && ch != LF && ch != FF && ch != SU)
}
>>>
def foo = {
  next.offset = begCharOffset
  do putCharAndNext() while (
    ch != CR && ch != LF && ch != FF &&
      ch != SU
  )
}
<<< `do` starts a new statement, wide, danglingParentheses.ctrlSite
maxColumn = 60
danglingParentheses.ctrlSite = true
===
def foo = {
    next.offset = begCharOffset
    do putCharAndNext()
    while (ch != CR && ch != LF && ch != FF && ch != SU)
}
>>>
def foo = {
  next.offset = begCharOffset
  do putCharAndNext() while (
    ch != CR && ch != LF && ch != FF && ch != SU
  )
}
<<< `do` starts a new statement, narrow, !danglingParentheses.ctrlSite
danglingParentheses.ctrlSite = false
===
def foo = {
    next.offset = begCharOffset
    do putCharAndNext()
    while (ch != CR && ch != LF && ch != FF && ch != SU)
}
>>>
def foo = {
  next.offset = begCharOffset
  do putCharAndNext()
  while (ch != CR && ch != LF &&
      ch != FF && ch != SU)
}
<<< `do` starts a new statement, wide, !danglingParentheses.ctrlSite
maxColumn = 60
danglingParentheses.ctrlSite = false
===
def foo = {
    next.offset = begCharOffset
    do putCharAndNext()
    while (ch != CR && ch != LF && ch != FF && ch != SU)
}
>>>
def foo = {
  next.offset = begCharOffset
  do putCharAndNext()
  while (ch != CR && ch != LF && ch != FF && ch != SU)
}
<<< splits: `after equals` or `before statement` 1
maxColumn = 80
===
 object ScriptRunner {
   def apply(settings: GenericRunnerSettings): ScriptRunner =
     settings.Yscriptrunner.value match {
       case custom =>
         val loader =
           new ClassLoader(getClass.getClassLoader) with ScalaClassLoader
         loader.create[ScriptRunner](custom, settings.errorFn)(settings)
     }
 }
>>>
object ScriptRunner {
  def apply(settings: GenericRunnerSettings): ScriptRunner =
    settings.Yscriptrunner.value match {
      case custom =>
        val loader =
          new ClassLoader(getClass.getClassLoader) with ScalaClassLoader
        loader.create[ScriptRunner](custom, settings.errorFn)(settings)
    }
}
<<< splits: `after right paren` or `before statement` 1
maxColumn = 80
===
 object a {
    override def safeToString =
      if (sym.isOmittablePrefix)
        s"${if (sym.isPackageObjectOrClass || sym.isJavaDefined)
            sym.fullNameString
          else sym.nameString}.type"
      else s"${prefixString}type"
 }
>>>
object a {
  override def safeToString =
    if (sym.isOmittablePrefix)
      s"${if (sym.isPackageObjectOrClass || sym.isJavaDefined)
          sym.fullNameString
        else
          sym.nameString}.type"
    else
      s"${prefixString}type"
}
<<< splits: `after right paren` or `before statement` 2
maxColumn = 80
===
 object a {
    def foo =
        if (args.size == params.size)
          if (untouchable) new AppliedTypeVar(origin, constr, params, args)
            with UntouchableTypeVar
          else new AppliedTypeVar(origin, constr, params, args)
        else if (args.isEmpty)
          if (untouchable)
            new HKTypeVar(origin, constr, params) with UntouchableTypeVar
          else new HKTypeVar(origin, constr, params)
        else throw new Error(
          "Invalid TypeVar construction: " + ((origin, constr, args, params))
        )
 }
>>>
object a {
  def foo =
    if (args.size == params.size)
      if (untouchable)
        new AppliedTypeVar(origin, constr, params, args) with UntouchableTypeVar
      else
        new AppliedTypeVar(origin, constr, params, args)
    else if (args.isEmpty)
      if (untouchable)
        new HKTypeVar(origin, constr, params) with UntouchableTypeVar
      else
        new HKTypeVar(origin, constr, params)
    else
      throw new Error(
        "Invalid TypeVar construction: " + ((origin, constr, args, params))
      )
}
<<< splits: `after right paren` or `before statement` 3
maxColumn = 80
===
 object a {
    while (it.hasNext) it.next() match {
      case vi: VarInsnNode if isNull(vi, vi.`var`) =>
        if (vi.getOpcode == ALOAD) toReplace(vi) = List(new InsnNode(ACONST_NULL))
        else if (vi.getOpcode == ASTORE)
          for (frame <- frameAt(vi) if frame.peekStack(0) == NullValue)
            toReplace(vi) = List(getPop(1))

      case ji: JumpInsnNode =>
        val isIfNull = ji.getOpcode == IFNULL
    }
 }
>>>
object a {
  while (it.hasNext)
    it.next() match {
      case vi: VarInsnNode if isNull(vi, vi.`var`) =>
        if (vi.getOpcode == ALOAD)
          toReplace(vi) = List(new InsnNode(ACONST_NULL))
        else if (vi.getOpcode == ASTORE)
          for (
            frame <- frameAt(vi)
            if frame.peekStack(0) == NullValue
          )
            toReplace(vi) = List(getPop(1))

      case ji: JumpInsnNode =>
        val isIfNull = ji.getOpcode == IFNULL
    }
}
<<< splits: `after ident` or `before brace` in infix
maxColumn = 80
===
object a {
  Example[{
    val foo: Int
  } :+: { val bar: String } :+: { val baz: Boolean } :+:
    { val buzz: Double } :+: { val booze: Float } :+: End].apply(_.foo)
}
>>>
object a {
  Example[{
    val foo: Int
  } :+: {
    val bar: String
  } :+: {
    val baz: Boolean
  } :+: {
    val buzz: Double
  } :+: {
    val booze: Float
  } :+: End].apply(_.foo)
}
<<< splits: `after ident` or `before brace` in infix 2
maxColumn = 78
===
object a {
    val totalSize = headerBuffer.length + lengthWithLength(nameBuffer) +
      {
        for ((nameRef, buf) <- sections) yield natSize(nameRef.index) +
          lengthWithLength(buf)
      }.sum
}
>>>
object a {
  val totalSize =
    headerBuffer.length + lengthWithLength(nameBuffer) +
      {
        for ((nameRef, buf) <- sections)
          yield natSize(nameRef.index) + lengthWithLength(buf)
      }.sum
}
<<< splits: `after right paren` or `before for`
maxColumn = 70
===
object a {
  if (sym.isPrimaryConstructor) for (
    cpa <- sym.owner.constrParamAccessors if cpa.isPrivateLocal
  ) params += cpa
  else if (sym.isSynthetic && sym.isImplicit) return
}
>>>
object a {
  if (sym.isPrimaryConstructor)
    for (
      cpa <- sym.owner.constrParamAccessors
      if cpa.isPrivateLocal
    )
      params += cpa
  else if (sym.isSynthetic && sym.isImplicit)
    return
}
<<< lambda with implicit parameter, scala213
maxColumn = 80
runner.dialect = scala213
===
Zone.acquire { implicit z: Zone =>
    import scalanative.libc.string
    assertEquals("case 2", 0, string.strcmp(buf2, c"1"))
}
>>>
Zone.acquire { implicit z: Zone =>
  import scalanative.libc.string
  assertEquals("case 2", 0, string.strcmp(buf2, c"1"))
}
<<< lambda with implicit parameter, scala3
maxColumn = 80
runner.dialect = scala3
===
Zone.acquire { implicit z: Zone =>
    import scalanative.libc.string
    assertEquals("case 2", 0, string.strcmp(buf2, c"1"))
}
>>>
Zone.acquire { implicit z: Zone =>
  import scalanative.libc.string
  assertEquals("case 2", 0, string.strcmp(buf2, c"1"))
}
<<< if cond in braces, danglingParentheses.ctrlSite
maxColumn = 80
danglingParentheses.ctrlSite = true
===
if ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
}) baos.write(buffer, 0, nread)
>>>
if ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
})
  baos.write(buffer, 0, nread)
<<< if cond in braces, !danglingParentheses.ctrlSite
maxColumn = 80
danglingParentheses.ctrlSite = false
===
if ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
}) baos.write(buffer, 0, nread)
>>>
if ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
})
  baos.write(buffer, 0, nread)
<<< while cond in braces, danglingParentheses.ctrlSite
maxColumn = 80
danglingParentheses.ctrlSite = true
===
while ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
}) baos.write(buffer, 0, nread)
>>>
while ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
})
  baos.write(buffer, 0, nread)
<<< while cond in braces, !danglingParentheses.ctrlSite
maxColumn = 80
danglingParentheses.ctrlSite = false
===
while ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
}) baos.write(buffer, 0, nread)
>>>
while ({
  nread = is.read(buffer, 0, buffer.length)
  nread != -1
})
  baos.write(buffer, 0, nread)
<<< binpack type args
maxColumn = 70
binPack.defnSite = always
binPack.callSite = always
newlines.configStyle.fallBack.prefer = false
===
object a {
  builder
    .add[T.Interpolation.Id, T.Interpolation.Part, T.Interpolation.SpliceStart,
      T.Xml.Part, T.MacroSplice, T.MacroQuote,
    ](SplitsNoSplit)
  builder.add[T.Interpolation.Id, T.Interpolation.Part, T.Interpolation.SpliceStart,
      T.Xml.Part, T.MacroSplice, T.MacroQuote,
    ](SplitsNoSplit)
}
>>>
object a {
  builder.add[
    T.Interpolation.Id, T.Interpolation.Part,
    T.Interpolation.SpliceStart, T.Xml.Part, T.MacroSplice,
    T.MacroQuote
  ](SplitsNoSplit)
  builder.add[
    T.Interpolation.Id, T.Interpolation.Part,
    T.Interpolation.SpliceStart, T.Xml.Part, T.MacroSplice,
    T.MacroQuote
  ](SplitsNoSplit)
}
<<< binpack term args
maxColumn = 70
binPack.defnSite = always
binPack.callSite = always
newlines.configStyle.fallBack.prefer = false
===
object a {
  builder
    .add(T.Interpolation.Id, T.Interpolation.Part, T.Interpolation.SpliceStart,
      T.Xml.Part, T.MacroSplice, T.MacroQuote,
    )(SplitsNoSplit)
  builder.add(T.Interpolation.Id, T.Interpolation.Part, T.Interpolation.SpliceStart,
      T.Xml.Part, T.MacroSplice, T.MacroQuote,
    )(SplitsNoSplit)
}
>>>
object a {
  builder.add(
    T.Interpolation.Id, T.Interpolation.Part,
    T.Interpolation.SpliceStart, T.Xml.Part, T.MacroSplice,
    T.MacroQuote
  )(SplitsNoSplit)
  builder.add(
    T.Interpolation.Id, T.Interpolation.Part,
    T.Interpolation.SpliceStart, T.Xml.Part, T.MacroSplice,
    T.MacroQuote
  )(SplitsNoSplit)
}
<<< #4887
maxColumn = 100
binPack.callSite = onelinesjs
newlines.configStyleCallSite.prefer = false
===
object a {
  Seq(
    (1, 2),
    (3, 4),
    (5, 6)
  )

  Seq(
    1 -> 2,
    3 -> 4,
    5 -> 6
  )

  Seq(
    Seq(1, 2),
    Seq(3, 4),
    Seq(5, 6)
  )

  Seq(
    1,
    2,
    3
  )
}
>>>
object a {
  Seq((1, 2), (3, 4), (5, 6))

  Seq(1 -> 2, 3 -> 4, 5 -> 6)

  Seq(Seq(1, 2), Seq(3, 4), Seq(5, 6))

  Seq(1, 2, 3)
}
<<< #4976
danglingParentheses.callSite = false
===
a(A(
  b = B,
  c = C
))
>>>
a(A(b = B, c = C))
<<< from scala-native: newlines.afterCurlyLambdaParams=never
newlines.afterCurlyLambdaParams = never
===
object a {
  foo { implicit z =>

    /* Requirement:
     */
     bar
     baz
  }
}
>>>
object a {
  foo { implicit z =>
    /* Requirement:
     */
    bar
    baz
  }
}
<<< from scala-native: newlines.afterCurlyLambdaParams=squash
newlines.afterCurlyLambdaParams = squash
===
object a {
  foo { implicit z =>

    /* Requirement:
     */
     bar
     baz
  }
}
>>>
object a {
  foo { implicit z =>
    /* Requirement:
     */
    bar
    baz
  }
}
<<< from scala-native: newlines.afterCurlyLambdaParams=always
newlines.afterCurlyLambdaParams = always
===
object a {
  foo { implicit z =>

    /* Requirement:
     */
     bar
     baz
  }
}
>>>
object a {
  foo { implicit z =>

    /* Requirement:
     */
    bar
    baz
  }
}
<<< #5009 RemoveSemicolons block
rewrite.rules = [RemoveSemicolons]
===
def main = {
  if (true) bar += 1
  else bar = 2; shouldBeFalse = true
}
>>>
def main = {
  if (true)
    bar += 1
  else
    bar = 2
  shouldBeFalse = true
}
<<< #5009 RemoveSemicolons template
rewrite.rules = [RemoveSemicolons]
===
object foo {
  if (true) bar += 1
  else bar = 2; shouldBeFalse = true
}
>>>
object foo {
  if (true)
    bar += 1
  else
    bar = 2
  shouldBeFalse = true
}
<<< #5009 RemoveSemicolons for-clause 1
rewrite.rules = [RemoveSemicolons]
===
for {
  a <-
  as1 ++ as2; b <-
  bs1 ++ bs2; if a < b; c <- cs
} yield a + b + c
>>>
for {
  a <- as1 ++ as2
  b <- bs1 ++ bs2
  if a < b
  c <- cs
} yield a + b + c
<<< #5009 RemoveSemicolons for-clause 2
rewrite.rules = [RemoveSemicolons]
===
for {
  a <- as1 ++
    as2; b <- bs1 ++
    bs2; if a < b; c <- cs
} yield a + b + c
>>>
for {
  a <- as1 ++ as2
  b <- bs1 ++ bs2
  if a < b
  c <- cs
} yield a + b + c
<<< #5009 !RemoveSemicolons block
def main = {
  if (true) bar += 1
  else bar = 2; shouldBeFalse = true
}
>>>
def main = {
  if (true)
    bar += 1
  else
    bar = 2;
  shouldBeFalse = true
}
<<< #5009 !RemoveSemicolons template
object foo {
  if (true) bar += 1
  else bar = 2; shouldBeFalse = true
}
>>>
object foo {
  if (true)
    bar += 1
  else
    bar = 2;
  shouldBeFalse = true
}
<<< #5009 !RemoveSemicolons for-clause 1
for {
  a <-
  as1 ++ as2; b <-
  bs1 ++ bs2; if a < b; c <- cs
} yield a + b + c
>>>
for {
  a <- as1 ++ as2;
  b <- bs1 ++ bs2;
  if a < b;
  c <- cs
} yield a + b + c
<<< #5009 !RemoveSemicolons for-clause 2
for {
  a <- as1 ++
    as2; b <- bs1 ++
    bs2; if a < b; c <- cs
} yield a + b + c
>>>
for {
  a <- as1 ++ as2;
  b <- bs1 ++ bs2;
  if a < b;
  c <- cs
} yield a + b + c
<<< break, danglingParentheses.importSite = false
maxColumn = 20
danglingParentheses.importSite = false
===
import ref.{
  foo, bar, baz, qux}
>>>
import ref.{
  foo,
  bar,
  baz,
  qux
}
<<< no break, danglingParentheses.importSite = false
maxColumn = 20
danglingParentheses.importSite = false
===
import ref.{foo, bar, baz, qux}
>>>
import ref.{
  foo,
  bar,
  baz,
  qux
}
<<< #5027 forceBeforeMultilineAssign
maxColumn = 100
newlines.forceBeforeMultilineAssign = def
===
def chars(s: String): List[Int] = for c <- s.toList yield c.toInt
>>>
def chars(s: String): List[Int] =
  for c <- s.toList
  yield c.toInt
<<< #5027 !forceBeforeMultilineAssign
maxColumn = 100
newlines.forceBeforeMultilineAssign = never
===
def chars(s: String): List[Int] = for c <- s.toList yield c.toInt
>>>
def chars(s: String): List[Int] =
  for c <- s.toList
  yield c.toInt
<<< for-yield with multiline, ignoreInSyntax
newlines.ignoreInSyntax = true
assumeStandardLibraryStripMargin = true
===
for {
  foo <- """|
    |bar
    |baz""".stripMargin
  foo <- s"""|
    |bar
    |baz""".stripMargin
} yield foo
>>>
for {
  foo <-
    """|
      |bar
      |baz""".stripMargin
  foo <-
    s"""|
      |bar
      |baz""".stripMargin
} yield foo
<<< for-yield with multiline, !ignoreInSyntax
newlines.ignoreInSyntax = false
assumeStandardLibraryStripMargin = true
===
for {
  foo <- """|
    |bar
    |baz""".stripMargin
  foo <- s"""|
    |bar
    |baz""".stripMargin
} yield foo
>>>
for {
  foo <-
    """|
      |bar
      |baz""".stripMargin
  foo <-
    s"""|
      |bar
      |baz""".stripMargin
} yield foo
<<< apply with multiline, ignoreInSyntax
align.stripMargin = true
newlines.ignoreInSyntax = true
assumeStandardLibraryStripMargin = true
===
bar(
  "bar" -> """|qux
               |xyzzy
               |""".stripMargin,
  "bar" -> s"""|qux
               |xyzzy
               |""".stripMargin,
)
>>>
bar(
  "bar" -> """|qux
              |xyzzy
              |""".stripMargin,
  "bar" -> s"""|qux
               |xyzzy
               |""".stripMargin
)
<<< apply with multiline, !ignoreInSyntax
align.stripMargin = true
newlines.ignoreInSyntax = false
assumeStandardLibraryStripMargin = true
===
bar(
  "bar" -> """|qux
               |xyzzy
               |""".stripMargin,
  "bar" -> s"""|qux
               |xyzzy
               |""".stripMargin,
)
>>>
bar(
  "bar" ->
    """|qux
       |xyzzy
       |""".stripMargin,
  "bar" ->
    s"""|qux
        |xyzzy
        |""".stripMargin
)
<<< apply with nested interpolations, !ignoreInSyntax
maxColumn = 50
align.stripMargin = true
newlines.ignoreInSyntax = false
assumeStandardLibraryStripMargin = true
===
bar(
  "bar" -> s"""|qux ${foo}""".stripMargin,
  "bar" -> s"""|qux ${"""aaa
               |xyzzy
               |""".stripMargin}""".stripMargin,
  "bar" -> s"""|qux ${s"foo"}""".stripMargin,
  "bar" -> s"""|qux ${s"""foo
               |xyzzy
               |""".stripMargin}""".stripMargin
)
>>>
bar(
  "bar" -> s"""|qux ${foo}""".stripMargin,
  "bar" ->
    s"""|qux ${"""aaa
                 |xyzzy
                 |""".stripMargin}""".stripMargin,
  "bar" -> s"""|qux ${s"foo"}""".stripMargin,
  "bar" ->
    s"""|qux ${s"""foo
                  |xyzzy
                  |""".stripMargin}""".stripMargin
)
<<< expr before multiline, !ignoreInSyntax
newlines.ignoreInSyntax = false
===
object a {
  val cursor = (" " * index) + "^"
   s"""|$desc near index $index
       |$regex
       |$cursor""".stripMargin
}
>>>
object a {
  val cursor = (" " * index) + "^"
  s"""|$desc near index $index
       |$regex
       |$cursor""".stripMargin
}
<<< `if` as single-arg of apply, openParenCallSite
align.openParenCallSite = true
newlines.configStyle.callSite.prefer = false
===
res.append(if (next('*')) {
      i += 1
      ".*"
    } else s"[^$sep]*")
>>>
res.append(
  if (next('*')) {
    i += 1
    ".*"
  } else
    s"[^$sep]*"
)
<<< `if` as single-arg of apply, !openParenCallSite
align.openParenCallSite = false
===
res.append(if (next('*')) {
      i += 1
      ".*"
    } else s"[^$sep]*")
>>>
res.append(
  if (next('*')) {
    i += 1
    ".*"
  } else
    s"[^$sep]*"
)
<<< `for` as single-arg of apply, openParenCallSite
align.openParenCallSite = true
newlines.configStyle.callSite.prefer = false
===
res.append(for {
      a <- b
      c <- d
    } yield a + c)
>>>
res.append(
  for {
    a <- b
    c <- d
  } yield a + c
)
<<< `for` as single-arg of apply, !openParenCallSite
align.openParenCallSite = false
===
res.append(for {
      a <- b
      c <- d
    } yield a + c)
>>>
res.append(
  for {
    a <- b
    c <- d
  } yield a + c
)
<<< `try` as single-arg of apply, openParenCallSite
align.openParenCallSite = true
newlines.configStyle.callSite.prefer = false
===
res.append(try {
      foo
      bar
    } finally { baz })
>>>
res.append(
  try {
    foo
    bar
  } finally {
    baz
  }
)
<<< `try` as single-arg of apply, !openParenCallSite
align.openParenCallSite = false
===
res.append(try {
      foo
      bar
    } finally { baz })
>>>
res.append(
  try {
    foo
    bar
  } finally {
    baz
  }
)
<<< import with binPack.importSelectors unspecified
maxColumn = 60
===
import packagename1.{
  AVeryLongClass1, AVeryLongClass2,
  AVeryLongClass3, AVeryLongClass4
}, packagename2.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   },
   packagename3.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   }
>>>
import packagename1.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}, packagename2.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}, packagename3.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}
<<< import with binPack.importSelectors = fold
maxColumn = 60
binPack.importSelectors = fold
===
import packagename1.{
  AVeryLongClass1, AVeryLongClass2,
  AVeryLongClass3, AVeryLongClass4
}, packagename2.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   },
   packagename3.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   }
>>>
import packagename1.{
  AVeryLongClass1, AVeryLongClass2, AVeryLongClass3,
  AVeryLongClass4
}, packagename2.{
  AVeryLongClass1, AVeryLongClass2, AVeryLongClass3,
  AVeryLongClass4
}, packagename3.{
  AVeryLongClass1, AVeryLongClass2, AVeryLongClass3,
  AVeryLongClass4
}
<<< import with binPack.importSelectors = unfold
maxColumn = 60
binPack.importSelectors = unfold
===
import packagename1.{
  AVeryLongClass1, AVeryLongClass2,
  AVeryLongClass3, AVeryLongClass4
}, packagename2.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   },
   packagename3.{
     AVeryLongClass1, AVeryLongClass2,
     AVeryLongClass3, AVeryLongClass4
   }
>>>
import packagename1.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}, packagename2.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}, packagename3.{
  AVeryLongClass1,
  AVeryLongClass2,
  AVeryLongClass3,
  AVeryLongClass4
}
<<< mixed nested infixes, with breakOnNested 1
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if (foo > bar && bar.baz && baz > qux && qux > xyz) {}
  a = foo > bar && bar.baz && baz > qux && qux > xyz
  b = (foo > bar && bar.baz && baz > qux && qux > xyz)
  c = {foo > bar && bar.baz && baz > qux && qux > xyz}
}
>>>
object a {
  if (
    foo > bar && bar.baz && baz > qux &&
    qux > xyz
  ) {}
  a =
    foo > bar && bar.baz && baz > qux &&
      qux > xyz
  b = (
    foo > bar && bar.baz && baz > qux &&
      qux > xyz
  )
  c = {
    foo > bar && bar.baz && baz > qux &&
    qux > xyz
  }
}
<<< mixed nested infixes, with breakOnNested 2
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if ((foo > bar) && bar.baz && baz > qux && qux > xyz) {}
  a = (foo > bar) && bar.baz && baz > qux && qux > xyz
  b = ((foo > bar) && bar.baz && baz > qux && qux > xyz)
  c = {(foo > bar) && bar.baz && baz > qux && qux > xyz}
}
>>>
object a {
  if (
    (foo > bar) &&
    bar.baz && baz > qux && qux > xyz
  ) {}
  a = (foo > bar) &&
    bar.baz && baz > qux && qux > xyz
  b = (
    (foo > bar) &&
      bar.baz && baz > qux && qux > xyz
  )
  c = {
    (foo > bar) &&
    bar.baz && baz > qux && qux > xyz
  }
}
<<< mixed nested infixes, with breakOnNested 3
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if (foo > bar && (bar.baz) && baz > qux && qux > xyz) {}
  a = foo > bar && (bar.baz) && baz > qux && qux > xyz
  b = (foo > bar && (bar.baz) && baz > qux && qux > xyz)
  c = {foo > bar && (bar.baz) && baz > qux && qux > xyz}
}
>>>
object a {
  if (
    foo > bar && (bar.baz) && baz > qux &&
    qux > xyz
  ) {}
  a =
    foo > bar && (bar.baz) && baz > qux &&
      qux > xyz
  b = (
    foo > bar && (bar.baz) && baz > qux &&
      qux > xyz
  )
  c = {
    foo > bar && (bar.baz) && baz > qux &&
    qux > xyz
  }
}
<<< mixed nested infixes, with breakOnNested 4
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if (foo > bar && bar.baz && (baz > qux) && qux > xyz) {}
  a = foo > bar && bar.baz && (baz > qux) && qux > xyz
  b = (foo > bar && bar.baz && (baz > qux) && qux > xyz)
  c = {foo > bar && bar.baz && (baz > qux) && qux > xyz}
}
>>>
object a {
  if (
    foo > bar && bar.baz &&
    (baz > qux) &&
    qux > xyz
  ) {}
  a =
    foo > bar && bar.baz &&
      (baz > qux) &&
      qux > xyz
  b = (
    foo > bar && bar.baz &&
      (baz > qux) &&
      qux > xyz
  )
  c = {
    foo > bar && bar.baz &&
    (baz > qux) &&
    qux > xyz
  }
}
<<< mixed nested infixes, with breakOnNested 5
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if (foo > bar && bar.baz && baz > qux && (qux > xyz)) {}
  a = foo > bar && bar.baz && baz > qux && (qux > xyz)
  b = (foo > bar && bar.baz && baz > qux && (qux > xyz))
  c = {foo > bar && bar.baz && baz > qux && (qux > xyz)}
}
>>>
object a {
  if (
    foo > bar && bar.baz && baz > qux &&
    (qux > xyz)
  ) {}
  a =
    foo > bar && bar.baz && baz > qux &&
      (qux > xyz)
  b = (
    foo > bar && bar.baz && baz > qux &&
      (qux > xyz)
  )
  c = {
    foo > bar && bar.baz && baz > qux &&
    (qux > xyz)
  }
}
<<< mixed nested infixes, with breakOnNested 6
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if ((foo > bar) && (bar.baz) && baz > qux && qux > xyz) {}
  a = (foo > bar) && (bar.baz) && baz > qux && qux > xyz
  b = ((foo > bar) && (bar.baz) && baz > qux && qux > xyz)
  c = {(foo > bar) && (bar.baz) && baz > qux && qux > xyz}
}
>>>
object a {
  if (
    (foo > bar) &&
    (bar.baz) && baz > qux && qux > xyz
  ) {}
  a = (foo > bar) &&
    (bar.baz) && baz > qux && qux > xyz
  b = (
    (foo > bar) &&
      (bar.baz) && baz > qux && qux > xyz
  )
  c = {
    (foo > bar) &&
    (bar.baz) && baz > qux && qux > xyz
  }
}
<<< mixed nested infixes, with breakOnNested 7
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if ((foo > bar) && (bar.baz) && baz > qux && (qux > xyz)) {}
  a = (foo > bar) && (bar.baz) && baz > qux && (qux > xyz)
  b = ((foo > bar) && (bar.baz) && baz > qux && (qux > xyz))
  c = {(foo > bar) && (bar.baz) && baz > qux && (qux > xyz)}
}
>>>
object a {
  if (
    (foo > bar) &&
    (bar.baz) && baz > qux &&
    (qux > xyz)
  ) {}
  a = (foo > bar) &&
    (bar.baz) && baz > qux &&
    (qux > xyz)
  b = (
    (foo > bar) &&
      (bar.baz) && baz > qux &&
      (qux > xyz)
  )
  c = {
    (foo > bar) &&
    (bar.baz) && baz > qux &&
    (qux > xyz)
  }
}
<<< mixed nested infixes, with breakOnNested 8
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if ((foo > bar) && bar.baz && (baz > qux) && (qux > xyz)) {}
  a = (foo > bar) && bar.baz && (baz > qux) && (qux > xyz)
  b = ((foo > bar) && bar.baz && (baz > qux) && (qux > xyz))
  c = {(foo > bar) && bar.baz && (baz > qux) && (qux > xyz)}
}
>>>
object a {
  if (
    (foo > bar) &&
    bar.baz &&
    (baz > qux) &&
    (qux > xyz)
  ) {}
  a = (foo > bar) &&
    bar.baz &&
    (baz > qux) &&
    (qux > xyz)
  b = (
    (foo > bar) &&
      bar.baz &&
      (baz > qux) &&
      (qux > xyz)
  )
  c = {
    (foo > bar) &&
    bar.baz &&
    (baz > qux) &&
    (qux > xyz)
  }
}
<<< mixed nested infixes, with breakOnNested 9
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if (foo > bar && (bar.baz) && (baz > qux) && (qux > xyz)) {}
  a = foo > bar && (bar.baz) && (baz > qux) && (qux > xyz)
  b = (foo > bar && (bar.baz) && (baz > qux) && (qux > xyz))
  c = {foo > bar && (bar.baz) && (baz > qux) && (qux > xyz)}
}
>>>
object a {
  if (
    foo > bar && (bar.baz) &&
    (baz > qux) &&
    (qux > xyz)
  ) {}
  a =
    foo > bar && (bar.baz) &&
      (baz > qux) &&
      (qux > xyz)
  b = (
    foo > bar && (bar.baz) &&
      (baz > qux) &&
      (qux > xyz)
  )
  c = {
    foo > bar && (bar.baz) &&
    (baz > qux) &&
    (qux > xyz)
  }
}
<<< mixed nested infixes, with breakOnNested 10
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  if ((foo > bar) && (bar.baz) && (baz > qux) && (qux > xyz)) {}
  a = (foo > bar) && (bar.baz) && (baz > qux) && (qux > xyz)
  b = ((foo > bar) && (bar.baz) && (baz > qux) && (qux > xyz))
  c = {(foo > bar) && (bar.baz) && (baz > qux) && (qux > xyz)}
}
>>>
object a {
  if (
    (foo > bar) &&
    (bar.baz) &&
    (baz > qux) &&
    (qux > xyz)
  ) {}
  a = (foo > bar) &&
    (bar.baz) &&
    (baz > qux) &&
    (qux > xyz)
  b = (
    (foo > bar) &&
      (bar.baz) &&
      (baz > qux) &&
      (qux > xyz)
  )
  c = {
    (foo > bar) &&
    (bar.baz) &&
    (baz > qux) &&
    (qux > xyz)
  }
}
<<< mixed nested infixes, with breakOnNested 11
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
!sym.isStaticOwner || (
  sym.isModuleClass &&
  sym.hasAnnotation(JSTypeAnnot) &&
   !sym.hasAnnotation(JSNativeAnnotation)
 )
>>>
!sym.isStaticOwner || (
  sym.isModuleClass &&
    sym.hasAnnotation(JSTypeAnnot) &&
    !sym.hasAnnotation(JSNativeAnnotation)
)
<<< blank before nested infix, with breakOnNested 12
maxColumn = 49
newlines.infix.termSite {
  style = some
  breakOnNested = true
}
===
object a {
  !sym.isStaticOwner

  (
    sym.isModuleClass &&
    sym.hasAnnotation(JSTypeAnnot) &&
     !sym.hasAnnotation(JSNativeAnnotation)
  )
}
>>>
object a {
  !sym.isStaticOwner

  (
    sym.isModuleClass &&
      sym.hasAnnotation(JSTypeAnnot) &&
      !sym.hasAnnotation(JSNativeAnnotation)
  )
}
<<< nested infix as a statement
maxColumn = 49
newlines.infix.termSite {
  style = some
}
===
object a {
   val thisFile = this.symbol.associatedFile
   val thatFile = other.associatedFile
   (  thisFile == null
   || thatFile == null
   || thisFile.path == thatFile.path // Cheap possibly wrong check, then expensive normalization
   || thisFile.canonicalPath == thatFile.canonicalPath
   )
}
>>>
object a {
  val thisFile = this.symbol.associatedFile
  val thatFile = other.associatedFile
  (
    thisFile == null || thatFile == null ||
      thisFile.path ==
      thatFile
        .path // Cheap possibly wrong check, then expensive normalization
      ||
      thisFile.canonicalPath ==
      thatFile.canonicalPath
  )
}
<<< tucked try-catch
object a {
  val foo = try {
    bar
  } catch {
    case baz => qux
  }
  foo = try {
    bar
  } catch {
    case baz => qux
  }
  val foo =
  try {
    bar
  } catch {
    case baz => qux
  }
  foo =
  try {
    bar
  } catch {
    case baz => qux
  }
}
>>>
object a {
  val foo =
    try {
      bar
    } catch {
      case baz =>
        qux
    }
  foo =
    try {
      bar
    } catch {
      case baz =>
        qux
    }
  val foo =
    try {
      bar
    } catch {
      case baz =>
        qux
    }
  foo =
    try {
      bar
    } catch {
      case baz =>
        qux
    }
}
<<< tucked for-yield
object a {
  val foo = for {
    bar <- baz
  } yield {
    qux
  }
  foo = for {
    bar <- baz
  } yield {
    qux
  }
  val foo =
  for {
    bar <- baz
  } yield {
    qux
  }
  foo =
  for {
    bar <- baz
  } yield {
    qux
  }
}
>>>
object a {
  val foo =
    for {
      bar <- baz
    } yield {
      qux
    }
  foo =
    for {
      bar <- baz
    } yield {
      qux
    }
  val foo =
    for {
      bar <- baz
    } yield {
      qux
    }
  foo =
    for {
      bar <- baz
    } yield {
      qux
    }
}
<<< tucked if-else
object a {
  val foo = if (bar) {
    baz
  } else {
    qux
  }
  foo = if (bar) {
    baz
  } else {
    qux
  }
  val foo =
  if (bar) {
    baz
  } else {
    qux
  }
  foo =
  if (bar) {
    baz
  } else {
    qux
  }
}
>>>
object a {
  val foo =
    if (bar) {
      baz
    } else {
      qux
    }
  foo =
    if (bar) {
      baz
    } else {
      qux
    }
  val foo =
    if (bar) {
      baz
    } else {
      qux
    }
  foo =
    if (bar) {
      baz
    } else {
      qux
    }
}
<<< trailing comment in case body, indent more, body empty
comments.indentTrailingInCaseBody = more
===
foo match {
  case bar =>
    // bar1

    // bar2
  case baz =>
    // baz1

    // baz2

  case qux =>
    // qux1
  case quux =>
    // quux1

    // quux2
}
>>>
foo match {
  case bar =>
    // bar1

  // bar2
  case baz =>
    // baz1

    // baz2

  case qux =>
    // qux1
  case quux =>
    // quux1

    // quux2
}
<<< trailing comment in case body, indent less, body empty
comments.indentTrailingInCaseBody = less
===
foo match {
  case bar =>
    // bar1

    // bar2
  case baz =>
    // baz1

    // baz2

  case qux =>
    // qux1
  case quux =>
    // quux1

    // quux2
}
>>>
foo match {
  case bar =>
    // bar1

  // bar2
  case baz =>
    // baz1

  // baz2

  case qux =>
    // qux1
  case quux =>
    // quux1

  // quux2
}
<<< trailing comment in case body, indent more, body one line
comments.indentTrailingInCaseBody = more
===
foo match {
  case bar => bbar
    // bar1

    // bar2
  case baz => bbaz
    // baz1

    // baz2

  case qux => bqux
    // qux1
  case quux => bquux
    // quux1

    // quux2
}
>>>
foo match {
  case bar =>
    bbar
    // bar1

  // bar2
  case baz =>
    bbaz
    // baz1

    // baz2

  case qux =>
    bqux
    // qux1
  case quux =>
    bquux
    // quux1

    // quux2
}
<<< trailing comment in case body, indent less, body one line
comments.indentTrailingInCaseBody = less
===
foo match {
  case bar => bbar
    // bar1

    // bar2
  case baz => bbaz
    // baz1

    // baz2

  case qux => bqux
    // qux1
  case quux => bquux
    // quux1

    // quux2
}
>>>
foo match {
  case bar =>
    bbar
    // bar1

  // bar2
  case baz =>
    bbaz
    // baz1

  // baz2

  case qux =>
    bqux
    // qux1
  case quux =>
    bquux
    // quux1

  // quux2
}
<<< infix with comment
maxColumn = 70
===
 val needSbt = cfg.getVersion < ScalafmtVersion(3, 0, 0, 7) && {
   val extension = getExtension(file.toString)
   extension == "md" || // added in 3.0.0-RC7
   cfg.getVersion < ScalafmtVersion(2, 6, 3) && extension == "sbt" ||
   extension == "sc" // added in 2.6.3
 }
>>>
val needSbt =
  cfg.getVersion < ScalafmtVersion(3, 0, 0, 7) && {
    val extension = getExtension(file.toString)
    extension == "md" || // added in 3.0.0-RC7
    cfg.getVersion < ScalafmtVersion(2, 6, 3) && extension == "sbt" ||
    extension == "sc" // added in 2.6.3
  }
<<< infix with unary
maxColumn = 24
===
object a {
  foo + bar + (baz + quxQuxQuxQux)
  foo + bar + !(baz + quxQuxQuxQux)
}
>>>
object a {
  foo + bar +
    (baz + quxQuxQuxQux)
  foo + bar + !(
    baz + quxQuxQuxQux
  )
}
<<< infix with unary, comment
maxColumn = 54
===
object a {
  foo + bar + /* c1 */ (baz + /* c2 */ quxQuxQuxQuxQuxQuxQuxQuxQuxQuxQux)
  foo + bar + /* c1 */ !(baz + /* c2 */ quxQuxQuxQuxQuxQuxQuxQuxQuxQuxQux)
}
>>>
object a {
  foo + bar + /* c1 */
    (baz + /* c2 */ quxQuxQuxQuxQuxQuxQuxQuxQuxQuxQux)
  foo + bar + /* c1 */
    !(
      baz + /* c2 */ quxQuxQuxQuxQuxQuxQuxQuxQuxQuxQux
    )
}
