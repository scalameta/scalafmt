
<<< With curly
if (true) {
      println(aaaaaaaaaaaaaaaaaaaaaaaaaa)
}
>>>
if (true) {
  println(aaaaaaaaaaaaaaaaaaaaaaaaaa)
}
<<< Long if condition
if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
bbbbbbbbbbbbbbbbbb)
  println("a")
>>>
if (
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
    bbbbbbbbbbbbbbbbbb
)
  println("a")
<<< Long if condition with inline comment
if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
      bbbbbbbbbbbbbbbbbb) // comment
  println("a")
>>>
if (
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
    bbbbbbbbbbbbbbbbbb
) // comment
  println("a")
<<< If assignment
val newColumn = if(split == Newline) newIndent
                else column + split.length
>>>
val newColumn =
  if (split == Newline) newIndent
  else column + split.length
<<< Egyptian curlies
if (optimalAt.contains(tok.left)) {
println("hello") }
>>>
if (optimalAt.contains(tok.left)) {
  println("hello")
}
<<< No-Egyptian curlies
if (optimalAt.contains(tok.left))
{
println("hello") }
>>>
if (optimalAt.contains(tok.left)) {
  println("hello")
}
<<< if else throw
if (result.isEmpty) true else throw new TestFailedException("")
>>>
if (result.isEmpty) true
else throw new TestFailedException("")
<<< assignment with paren
val newColumn = tok.length + (
if(split == Newline) newIndent
else column + split.length
)
>>>
val newColumn = tok.length + (
    if (split == Newline) newIndent
    else column + split.length
)
<<< no newline
val policy =
 if (right) SingleLineBlock(close)
 else   NoPolicy
>>>
val policy =
  if (right) SingleLineBlock(close)
  else NoPolicy
<<< bang ! binds to right
if ((gets2x(tok) ||
lines(tok.between) > 1) &&
     !(isDocstring(left) && between)) 1
>>>
if (
    (gets2x(tok) ||
      lines(tok.between) > 1) &&
    !(isDocstring(left) && between)
) 1
<<< == unary nosplit literal, scalameta/scalameta#344
if   (firstNewline == -1) tokLength
>>>
if (firstNewline == -1) tokLength
<<< Gimme newline
  if (isBracket)   Constants.BracketPenalty
  else 0
>>>
if (isBracket) Constants.BracketPenalty
else 0
<<< Tuple body is OK
if (left.is[Interpolation.Start])
  (StateColumn,
  matchingParentheses())
>>>
if (left.is[Interpolation.Start])
  (StateColumn, matchingParentheses())
<<< single line
if (true) 1  else 2
>>>
if (true) 1 else 2
<<< no single line
if (true) 1
  else 2
>>>
if (true) 1
else 2
<<< if/else
object Bar {
  if (cond) a else {
    // body
  }
}
>>>
object Bar {
  if (cond) a
  else {
    // body
  }
}
<<< #271 curly
if (true) { a }
else { 2 }
>>>
if (true) { a }
else { 2 }
<<< #930 return
if (true) return
else println(1)
>>>
if (true) return
else println(1)
<<< #1043
      if ('0' <= c && c <= '9') { c - '0' }
      else if ('A' <= c && c <= 'F') { c - 'A' + 10 }
      else if ('a' <= c && c <= 'f') { c - 'a' + 10 }
      else { -1 }
>>>
if ('0' <= c && c <= '9') { c - '0' }
else if ('A' <= c && c <= 'F') {
  c - 'A' + 10
} else if ('a' <= c && c <= 'f') {
  c - 'a' + 10
} else { -1 }
<<< #1043 with lines joined
      if ('0' <= c && c <= '9') { c - '0' }      else if ('A' <= c && c <= 'F') { c - 'A' + 10 }
      else if ('a' <= c && c <= 'f') { c - 'a' + 10 }
      else { -1 }
>>>
if ('0' <= c && c <= '9') { c - '0' }
else if ('A' <= c && c <= 'F') {
  c - 'A' + 10
} else if ('a' <= c && c <= 'f') {
  c - 'a' + 10
} else { -1 }
<<< insert braces in if-else, last qualifies
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo)
  tfoo
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else {
  qux
  quux
}
>>>
if (cfoo) {
  tfoo
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  qux
  quux
}
<<< insert braces in if-else, first qualifies
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo) {
  tfoo1
  tfoo2
}
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  qux
>>>
if (cfoo) {
  tfoo1
  tfoo2
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, multiline cond first
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  nonBlocksMinBreaks = 1
  allBlocks = true
}
===
if (
  cfoo1 &&
  cfoo2
)
  tfoo
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  qux
>>>
if (
    cfoo1 &&
    cfoo2
) {
  tfoo
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, multiline cond last
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  nonBlocksMinBreaks = 1
  allBlocks = true
}
===
if (cfoo1)
  tfoo
else if (cbar)
  tbar
else if (
  cbaz1 &&
  cbaz2
)
  tbaz
else
  qux
>>>
if (cfoo1) {
  tfoo
} else if (cbar) {
  tbar
} else if (
    cbaz1 &&
    cbaz2
) {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, last qualifies, using then
newlines.source = keep
runner.dialect = scala3
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if cfoo then
  tfoo
else if cbar then
  tbar
else if cbaz then
  tbaz
else
  qux
  quux
>>>
if cfoo then {
  tfoo
} else if cbar then {
  tbar
} else if cbaz then {
  tbaz
} else {
  qux
  quux
}
<<< insert braces in if-else, first qualifies, using then
newlines.source = keep
runner.dialect = scala3
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if cfoo then
  tfoo1
  tfoo2
else if cbar then
  tbar
else if cbaz then
  tbaz
else
  qux
>>>
if cfoo then {
  tfoo1
  tfoo2
} else if cbar then {
  tbar
} else if cbaz then {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, last qualifies, using then and parens
newlines.source = keep
runner.dialect = scala3
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo) then
  tfoo
else if (cbar) then
  tbar
else if (cbaz) then
  tbaz
else
  qux
  quux
>>>
if (cfoo) then {
  tfoo
} else if (cbar) then {
  tbar
} else if (cbaz) then {
  tbaz
} else {
  qux
  quux
}
<<< insert braces in if-else, first qualifies, using then and parens
newlines.source = keep
runner.dialect = scala3
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo) then
  tfoo1
  tfoo2
else if (cbar) then
  tbar
else if (cbaz) then
  tbaz
else
  qux
>>>
if (cfoo) then {
  tfoo1
  tfoo2
} else if (cbar) then {
  tbar
} else if (cbaz) then {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, first qualifies with comments
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo)
  // tfoo1
  tfoo2
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  qux
>>>
if (cfoo) {
  // tfoo1
  tfoo2
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, last qualifies with comments
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
if (cfoo)
  tfoo1
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  // qux
  quux
>>>
if (cfoo) {
  tfoo1
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  // qux
  quux
}
<<< insert braces in if-else, first qualifies, count break before
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 2
  allBlocks = true
  countBreakBeforeFor = [{ parents = ["Term.If", "Nothing"] }]
}
===
if (cfoo)
  // tfoo1
  tfoo2
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  qux
>>>
if (cfoo) {
  // tfoo1
  tfoo2
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  qux
}
<<< insert braces in if-else, last qualifies, count break before
newlines.source = keep
maxColumn = 80
rewrite.insertBraces {
  minBreaks = 2
  allBlocks = true
  countBreakBeforeFor = [{ parents = ["Term.If", "Nothing"] }]
}
===
if (cfoo)
  tfoo1
else if (cbar)
  tbar
else if (cbaz)
  tbaz
else
  // qux
  quux
>>>
if (cfoo) {
  tfoo1
} else if (cbar) {
  tbar
} else if (cbaz) {
  tbaz
} else {
  // qux
  quux
}
<<< insert braces in try-catch with multiple cases
newlines.source = keep
rewrite.insertBraces {
  minBreaks = 2
  allBlocks = true
}
===
try
  foo
catch {
   case bar => baz
   case qux => quux
} finally
  xyzzy
>>>
try {
  foo
} catch {
  case bar => baz
  case qux => quux
} finally {
  xyzzy
}
<<< insert braces in try-catch handler, multiple in finally
newlines.source = keep
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
try
  foo
catch
  handler
finally {
  bar
  baz
}
>>>
try {
  foo
} catch {
  handler
} finally {
  bar
  baz
}
<<< insert braces in try-catch handler, multiple in try
newlines.source = keep
rewrite.insertBraces {
  minBreaks = 1
  allBlocks = true
}
===
try {
  foo
  bar
}
catch
  handler
finally
  baz
>>>
try {
  foo
  bar
} catch {
  handler
} finally {
  baz
}
