
<<< Massive 1
List(Split(Space, 0).withPolicy(SingleLineBlock(close)),
           Split(nl, 1).withPolicy({
             case Decision(t@FormatToken(_, `close`, _), s) =>
               Decision(t, List(Split(Newline, 0)))
           }).withIndent(2, close, Right))
>>> { stateVisits = 626, stateVisits2 = 626 }
List(Split(Space, 0).withPolicy(SingleLineBlock(close)),
     Split(nl, 1)
       .withPolicy({ case Decision(t @ FormatToken(_, `close`, _), s) =>
         Decision(t, List(Split(Newline, 0)))
       })
       .withIndent(2, close, Right))
<<< Massive 2
 List(Split(Space,
            0,
            policy = SingleLineBlock(close),
            ignoreIf = blockSize > style.maxColumn),
      Split(nl,
            1,
            policy = {
            case Decision(t@FormatToken(_, `close`, _), s) =>
            Decision(t, List(Split(Newline, 0)))
            }))
>>>
List(Split(Space,
           0,
           policy = SingleLineBlock(close),
           ignoreIf = blockSize > style.maxColumn),
     Split(nl,
           1,
           policy = { case Decision(t @ FormatToken(_, `close`, _), s) =>
             Decision(t, List(Split(Newline, 0)))
           }))
<<< Massive 2 with spaces inside parens
spaces.inParentheses = true
===
 List(Split(Space,
            0,
            policy = SingleLineBlock(close),
            ignoreIf = blockSize > style.maxColumn),
      Split(nl,
            1,
            policy = {
            case Decision(t@FormatToken(_, `close`, _), s) =>
            Decision(t, List(Split(Newline, 0)))
            }))
>>>
List( Split( Space,
             0,
             policy = SingleLineBlock( close ),
             ignoreIf = blockSize > style.maxColumn ),
      Split( nl,
             1,
             policy = { case Decision( t @ FormatToken( _, `close`, _ ), s ) =>
               Decision( t, List( Split( Newline, 0 ) ) )
             } ) )
<<< Massive (good API) 3
Split(Space, 0).withPolicy {
    // Following case:
    // package foo // this is cool
    //
    // object a
    case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
        if !between.exists(_.isInstanceOf[`\n`]) =>
      Decision(t, splits.map(_.withModification(Space)))
    case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
      Decision(t, splits.map(_.withModification(Newline2x)))
}
>>>
Split(Space, 0).withPolicy {
  // Following case:
  // package foo // this is cool
  //
  // object a
  case Decision(t @ FormatToken(`lastRef`, _: Comment, between), splits)
      if !between.exists(_.isInstanceOf[`\n`]) =>
    Decision(t, splits.map(_.withModification(Space)))
  case Decision(t @ FormatToken(`lastRef`, _, _), splits) =>
    Decision(t, splits.map(_.withModification(Newline2x)))
}
<<< Massive (bad API) 3
Split(Space, 0, policy = {
    // Following case:
    // package foo // this is cool
    //
    // object a
    case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
        if !between.exists(_.isInstanceOf[`\n`]) =>
      Decision(t, splits.map(_.withModification(Space)))
    case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
      Decision(t, splits.map(_.withModification(Newline2x)))
})
>>>
Split(Space,
      0,
      policy = {
        // Following case:
        // package foo // this is cool
        //
        // object a
        case Decision(t @ FormatToken(`lastRef`, _: Comment, between), splits)
            if !between.exists(_.isInstanceOf[`\n`]) =>
          Decision(t, splits.map(_.withModification(Space)))
        case Decision(t @ FormatToken(`lastRef`, _, _), splits) =>
          Decision(t, splits.map(_.withModification(Newline2x)))
      })
<<< Looong
Seq(
  Split(modification, 0, policy = singleLine)
    .withIndent(indent, close, Left)
     .withOptimal(optimalTok),
  Split(Newline, 1 + nestedPenalty + lhsPenalty, policy = singleLine)
    .withIndent(indent, close, Left)
    .withOptimal(optimalTok),
  Split(modification, 2 + lhsPenalty, policy = oneArgOneLine, ignoreIf = singleArgument)
    .withIndent(StateColumn, close, Right)
    .withOptimal(optimalTok),
  Split(Newline,
    3 + nestedPenalty + lhsPenalty,
    policy = oneArgOneLine, ignoreIf = singleArgument)
    .withIndent(indent, close, Left)

)
>>>
Seq(
    Split(modification, 0, policy = singleLine)
      .withIndent(indent, close, Left)
      .withOptimal(optimalTok),
    Split(Newline, 1 + nestedPenalty + lhsPenalty, policy = singleLine)
      .withIndent(indent, close, Left)
      .withOptimal(optimalTok),
    Split(modification,
          2 + lhsPenalty,
          policy = oneArgOneLine,
          ignoreIf = singleArgument)
      .withIndent(StateColumn, close, Right)
      .withOptimal(optimalTok),
    Split(Newline,
          3 + nestedPenalty + lhsPenalty,
          policy = oneArgOneLine,
          ignoreIf = singleArgument).withIndent(indent, close, Left)
)
<<< continuation indent
Seq(
            // Either everything fits in one line or break on =>
            Split(Space, 0).withPolicy(SingleLineBlock(lastToken)),
            Split(Space, 1).withPolicy(Policy({
                  case Decision(t@FormatToken(`arrow`, _, _), s) =>
                    Decision(t, s.filter(_.modification.isNewline))
                },
                expire = lastToken.end))
              .withIndent(2, lastToken, Left) // case body indented by 2.
              .withIndent(2, arrow, Left) // cond body indented by 4.
        )
>>> { stateVisits = 703, stateVisits2 = 703 }
Seq(
    // Either everything fits in one line or break on =>
    Split(Space, 0).withPolicy(SingleLineBlock(lastToken)),
    Split(Space, 1)
      .withPolicy(Policy({ case Decision(t @ FormatToken(`arrow`, _, _), s) =>
                           Decision(t, s.filter(_.modification.isNewline))
                         },
                         expire = lastToken.end))
      .withIndent(2, lastToken, Left) // case body indented by 2.
      .withIndent(2, arrow, Left) // cond body indented by 4.
)
<<< breaking on ( is cheaper than [
val ret = new mutable.MapBuilder[TokenHash, Tree, Map[TokenHash, Tree]](Map[TokenHash, Tree]())
>>>
val ret = new mutable.MapBuilder[TokenHash, Tree, Map[TokenHash, Tree]](
    Map[TokenHash, Tree]())
<<< . is cheaper
{{{{
        Seq(
            Split(
                  // This split needs to have an optimalAt field.
                  Space,
                  0,
                  ignoreIf = !spaceCouldBeOk,
                  optimalAt = Some(expire_______________a)).withPolicy(SingleLineBlockAAAA(
                expire))
        )
}}}}
>>>
{
  {
    {
      {
        Seq(
            Split(
                // This split needs to have an optimalAt field.
                Space,
                0,
                ignoreIf = !spaceCouldBeOk,
                optimalAt = Some(expire_______________a))
              .withPolicy(SingleLineBlockAAAA(expire))
        )
      }
    }
  }
}
<<< penalize newlines inside apply 1
val ret = new mutable.MapBuilder[TokenHash, Token, Map[TokenHash, Token]](Map
             .empty[TokenHash, Token])
>>>
val ret = new mutable.MapBuilder[TokenHash, Token, Map[TokenHash, Token]](
    Map.empty[TokenHash, Token])
<<< penalize newlines inside apply 2
{{
val result = new scala.collection.mutable.SetBuilder[Token, Set[Token]](Set.empty[Token])
}}
>>>
{
  {
    val result = new scala.collection.mutable.SetBuilder[Token, Set[Token]](
        Set.empty[Token])
  }
}
<<< property scalding
  writeRead(
    // Use list because Array has a shitty toString
    { (b: List[Byte], os) => os.writePosVarInt(b.size); os.writeBytes(b.toArray) },
    { is =>
      val bytes = new Array[Byte](is.readPosVarInt)
      is.readFully(bytes)
      bytes.toList
    })
>>>
writeRead(
    // Use list because Array has a shitty toString
    { (b: List[Byte], os) =>
      os.writePosVarInt(b.size); os.writeBytes(b.toArray)
    },
    { is =>
      val bytes = new Array[Byte](is.readPosVarInt)
      is.readFully(bytes)
      bytes.toList
    })
<<< resolution copier
class ResolutionCopier(x: Int) {

  def visitClassDeclaration(node: ClassDeclaration): Boolean = {
    val toNode = this._toNode.asInstanceOf[ClassDeclaration];
    javaBooleanAnd(
        javaBooleanAnd(
            javaBooleanAnd(
                javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(
                        javaBooleanAnd(javaBooleanAnd(
                            javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(
                                    _isEqualNodes(node.documentationComment,
                                        toNode.documentationComment),
                                    _isEqualNodeLists(
                                        node.metadata, toNode.metadata)),
                                _isEqualTokens(node.abstractKeyword,
                                    toNode.abstractKeyword)), _isEqualTokens(
                                node.classKeyword, toNode.classKeyword)),
                            _isEqualNodes(
                                node.name, toNode.name)), _isEqualNodes(
                            node.typeParameters, toNode.typeParameters)),
                        _isEqualNodes(
                            node.extendsClause, toNode.extendsClause)),
                    _isEqualNodes(
                        node.withClause, toNode.withClause)), _isEqualNodes(
                    node.implementsClause, toNode.implementsClause)),
                _isEqualTokens(node.leftBracket, toNode.leftBracket)),
            _isEqualNodeLists(
                node.members,
                toNode.members)),
        _isEqualTokens(
            node.rightBracket,
            toNode.rightBracket));
  }
}
>>> { stateVisits = 57387, stateVisits2 = 57387 }
class ResolutionCopier(x: Int) {

  def visitClassDeclaration(node: ClassDeclaration): Boolean = {
    val toNode = this._toNode.asInstanceOf[ClassDeclaration];
    javaBooleanAnd(
        javaBooleanAnd(
            javaBooleanAnd(
                javaBooleanAnd(
                    javaBooleanAnd(
                        javaBooleanAnd(
                            javaBooleanAnd(
                                javaBooleanAnd(
                                    javaBooleanAnd(
                                        javaBooleanAnd(
                                            javaBooleanAnd(
                                                _isEqualNodes(
                                                    node.documentationComment,
                                                    toNode.documentationComment),
                                                _isEqualNodeLists(
                                                    node.metadata,
                                                    toNode.metadata)),
                                            _isEqualTokens(
                                                node.abstractKeyword,
                                                toNode.abstractKeyword)),
                                        _isEqualTokens(node.classKeyword,
                                                       toNode.classKeyword)),
                                    _isEqualNodes(node.name, toNode.name)),
                                _isEqualNodes(node.typeParameters,
                                              toNode.typeParameters)),
                            _isEqualNodes(node.extendsClause,
                                          toNode.extendsClause)),
                        _isEqualNodes(node.withClause, toNode.withClause)),
                    _isEqualNodes(node.implementsClause,
                                  toNode.implementsClause)),
                _isEqualTokens(node.leftBracket, toNode.leftBracket)),
            _isEqualNodeLists(node.members, toNode.members)),
        _isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
}
<<< single arg breaking #160
   implicit class IterableW[+A](it: JSIterable[A]) {
     def iterator(): Iterator[A] =
      toIterator(it
            .asInstanceOf[IteratorMethodAccess]
            .bracketCall[JSIterator[A]](iteratorSymbol)())
   }
>>>
implicit class IterableW[+A](it: JSIterable[A]) {
  def iterator(): Iterator[A] =
    toIterator(
        it.asInstanceOf[IteratorMethodAccess]
          .bracketCall[JSIterator[A]](iteratorSymbol)())
}
<<< => {, #224
        foo.fold(
            err =>
              {
                logger.warn(s"Malformed request: $err\n${req.body}")
                BadRequest(jsonError(JsError toJson err)).fuccess
            },
            data => data)
>>>
foo.fold(err => {
           logger.warn(s"Malformed request: $err\n${req.body}")
           BadRequest(jsonError(JsError toJson err)).fuccess
         },
         data => data)
<<< quirk in 0.2.4-RC1, #233
{{{{{
          compileInputs in (It, compile) <<= (compileInputs in (It, compile)) dependsOn
          }}}}}
>>>
{
  {
    {
      {
        {
          compileInputs in (It, compile) <<= (compileInputs in (
              It,
              compile)) dependsOn
        }
      }
    }
  }
}
<<< dequeue on Case.body, prevent state explosion
        Seq(
            Split(Space, 0),
            Split(Newline, 1).withPolicy(Policy({
              // Force template to be multiline.
              case d @ Decision(FormatToken(open: `{`, right, _), splits)
                  if !right.isInstanceOf[`}`] && // corner case, body is {}
                  childOf(template, owners(open)) =>
                d.copy(splits = splits.filter(_.modification.isNewline))
            }, expire.end))
        )
>>>
Seq(
    Split(Space, 0),
    Split(Newline, 1).withPolicy(
        Policy({
                 // Force template to be multiline.
                 case d @ Decision(FormatToken(open: `{`, right, _), splits)
                     if !right.isInstanceOf[`}`] && // corner case, body is {}
                       childOf(template, owners(open)) =>
                   d.copy(splits = splits.filter(_.modification.isNewline))
               },
               expire.end))
)
<<< #310
CreditCard(customerId = customerId,
               gatewayCustomerId = sCust.getId,
               gatewayCardId = card.getId,
               holderName = p.holderName,
               lastFour = p.lastFour,
               expMonth = p.expMonth,
               expYear = p.expYear,
               isDefault = p.isDefault,
               address1Check = card.getAddressLine1Check.some,
               zipCheck = card.getAddressZipCheck.some,
               regionId = a.regionId,
               addressName = a.name,
               address1 = a.address1,
               address2 = a.address2,
               city = a.city,
               zip = a.zip,
               brand = card.getBrand)
>>>
CreditCard(customerId = customerId,
           gatewayCustomerId = sCust.getId,
           gatewayCardId = card.getId,
           holderName = p.holderName,
           lastFour = p.lastFour,
           expMonth = p.expMonth,
           expYear = p.expYear,
           isDefault = p.isDefault,
           address1Check = card.getAddressLine1Check.some,
           zipCheck = card.getAddressZipCheck.some,
           regionId = a.regionId,
           addressName = a.name,
           address1 = a.address1,
           address2 = a.address2,
           city = a.city,
           zip = a.zip,
           brand = card.getBrand)
<<< #318
foo(
    new Bar {
      def stuff = 42
    })
>>>
foo(new Bar {
  def stuff = 42
})
<<< wat #318
Ok(
      Json.obj("api" -> Json.obj("current" -> api.currentVersion,
                                 "olds" -> api.oldVersions.map { old =>
                           Json.obj("version" -> old.version,
                                    "deprecatedAt" -> old.deprecatedAt,
                                    "unsupportedAt" -> old.unsupportedAt)
                         }))) as JSON
>>>
Ok(
    Json.obj("api" -> Json.obj("current" -> api.currentVersion,
                               "olds" -> api.oldVersions.map { old =>
                                 Json.obj("version" -> old.version,
                                          "deprecatedAt" -> old.deprecatedAt,
                                          "unsupportedAt" -> old.unsupportedAt)
                               }))) as JSON
<<< router explosion
        Seq(
            Split(modification,
                  0,
                  policy = singleLine(6),
                  ignoreIf = !fitsOnOneLine)
              .withOptimalToken(expirationToken)
              .withIndent(indent, close, Left),
            Split(newlineModification,
                  (1 + nestedPenalty + lhsPenalty) * bracketMultiplier,
                  policy = singleLine(5),
                  ignoreIf = !fitsOnOneLine || isTuple)
              .withOptimalToken(expirationToken)
              .withIndent(indent, close, Left),
            // TODO(olafur) singleline per argument!
            Split(modification,
                  (2 + lhsPenalty) * bracketMultiplier,
                  policy = oneArgOneLine,
                  ignoreIf = singleArgument || tooManyArguments)
              .withOptimalToken(expirationToken)
              .withIndent(StateColumn, close, Right),
            Split(Newline,
                  (3 + nestedPenalty + lhsPenalty) * bracketMultiplier,
                  policy = oneArgOneLine,
                  ignoreIf = singleArgument || isTuple)
              .withOptimalToken(expirationToken)
              .withIndent(indent, close, Left)
        )
>>>
Seq(
    Split(modification, 0, policy = singleLine(6), ignoreIf = !fitsOnOneLine)
      .withOptimalToken(expirationToken)
      .withIndent(indent, close, Left),
    Split(newlineModification,
          (1 + nestedPenalty + lhsPenalty) * bracketMultiplier,
          policy = singleLine(5),
          ignoreIf = !fitsOnOneLine || isTuple)
      .withOptimalToken(expirationToken)
      .withIndent(indent, close, Left),
    // TODO(olafur) singleline per argument!
    Split(modification,
          (2 + lhsPenalty) * bracketMultiplier,
          policy = oneArgOneLine,
          ignoreIf = singleArgument || tooManyArguments)
      .withOptimalToken(expirationToken)
      .withIndent(StateColumn, close, Right),
    Split(Newline,
          (3 + nestedPenalty + lhsPenalty) * bracketMultiplier,
          policy = oneArgOneLine,
          ignoreIf = singleArgument || isTuple)
      .withOptimalToken(expirationToken)
      .withIndent(indent, close, Left)
)
<<< qualified super #275
   def fillInStackTrace(): Throwable =
    super[Error].fillInStackTrace()
>>>
def fillInStackTrace(): Throwable =
  super[Error].fillInStackTrace()
<<< #263
{
    val safeHasOwnProperty = Dynamic.global.Object.prototype.hasOwnProperty
        .asInstanceOf[ThisFunction1[Dictionary[_], String, Boolean]]
        }
>>>
{
  val safeHasOwnProperty = Dynamic.global.Object.prototype.hasOwnProperty
    .asInstanceOf[ThisFunction1[Dictionary[_], String, Boolean]]
}
<<< weird 0.2.9 fix
{{
    handlefiles(files, cache, logfun("formatting %s %s ..."), files =>
          files.par.foreach(handlefile(writeformatted)))
}}
>>>
{
  {
    handlefiles(files,
                cache,
                logfun("formatting %s %s ..."),
                files => files.par.foreach(handlefile(writeformatted)))
  }
}
<<< #323
def startSharding(system: ActorSystem, mediator: ActorRef, shardCount: Int): Unit = ClusterSharding(system).start(
  className[Flow],
  props(mediator),
  ClusterShardingSettings(system),
  { case (name: String, payload) => (name, payload) },
  { case (name: String, _) => (name.hashCode % shardCount).toString }
)
>>>
def startSharding(system: ActorSystem,
                  mediator: ActorRef,
                  shardCount: Int): Unit = ClusterSharding(system).start(
    className[Flow],
    props(mediator),
    ClusterShardingSettings(system),
    { case (name: String, payload) => (name, payload) },
    { case (name: String, _) => (name.hashCode % shardCount).toString }
)
<<< spray example
newlines.avoidForSimpleOverflow = [punct]
===
{{{
      get {
        respondWithMediaType(MediaTypes.`application/json`) {
          complete {
            Map("plugins" -> Map(
                    "outputblockers" -> pluginContext.outputBlockers.map {
                  case (n, p) =>
                    n -> Map(
                        "name" -> p.pluginName,
                        "description" -> p.pluginDescription,
                        "class" -> p.getClass.getName,
                        "params" -> pluginContext.pluginParams(p.pluginName))
                },
                    "outputsniffers" -> pluginContext.outputSniffers.map {
                  case (n, p) =>
                    n -> Map(
                        "name" -> p.pluginName,
                        "description" -> p.pluginDescription,
                        "class" -> p.getClass.getName,
                        "params" -> pluginContext.pluginParams(p.pluginName))
                }
                ))
          }
        }
      }
}}}
>>> { stateVisits = 1126, stateVisits2 = 1123 }
{
  {
    {
      get {
        respondWithMediaType(MediaTypes.`application/json`) {
          complete {
            Map(
                "plugins" -> Map(
                    "outputblockers" -> pluginContext.outputBlockers.map {
                      case (n, p) =>
                        n -> Map(
                            "name" -> p.pluginName,
                            "description" -> p.pluginDescription,
                            "class" -> p.getClass.getName,
                            "params" -> pluginContext.pluginParams(p.pluginName))
                    },
                    "outputsniffers" -> pluginContext.outputSniffers.map {
                      case (n, p) =>
                        n -> Map(
                            "name" -> p.pluginName,
                            "description" -> p.pluginDescription,
                            "class" -> p.getClass.getName,
                            "params" -> pluginContext.pluginParams(p.pluginName))
                    }
                ))
          }
        }
      }
    }
  }
}
<<< nested apply with assign
newlines.avoidForSimpleOverflow = [punct]
===
opt[String]("json-extractor") action { (x, c) =>
    c.copy(         common =
            c.common.copy(
            jsonExtractor = JsonExtractorOption.withName(x)))
}
>>>
opt[String]("json-extractor") action { (x, c) =>
  c.copy(common = c.common.copy(jsonExtractor = JsonExtractorOption.withName(x)))
}
<<< nested apply with assign 2
 {
       val config =
         WSClientConfig(          ssl =
            SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages = None)))
        val game = Game(              castleLastMoveTime =
                CastleLastMoveTime.init.copy(castles = game.board.history.castles),
                    daysPerTurn = daysPerTurn
                    )
                    }
>>>
{
  val config =
    WSClientConfig(ssl =
      SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages = None)))
  val game = Game(
      castleLastMoveTime =
        CastleLastMoveTime.init.copy(castles = game.board.history.castles),
      daysPerTurn = daysPerTurn)
}
<<< #1604 1: apply with then without assign, and attached comments
{
       val config =         WSClientConfig(          ssl =
SSLConfig(SSLLooseConfig(allowLegacyHelloMessages = None)/*comment 123 comment 234*/)) //comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(ssl =
    SSLConfig(
        SSLLooseConfig(allowLegacyHelloMessages =
          None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
<<< #1604 1: apply with then without assign, and attached comments, with breaks before paren/comment
{
  val config = WSClientConfig(ssl =
    SSLConfig(
        SSLLooseConfig(allowLegacyHelloMessages =
          None) /*comment 123 comment 234*/
    )
  ) // comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(ssl =
    SSLConfig(
        SSLLooseConfig(allowLegacyHelloMessages =
          None) /*comment 123 comment 234*/
    )
  ) // comment 345 comment 456
}
<<< #1604 2: apply without then with assign, and attached comments
{
       val config =         WSClientConfig(
SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages = None)/*comment 123 comment 234*/)) //comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(
      SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages =
        None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
<<< #1604 2: apply without then with assign, and attached comments, with breaks before paren/comment
{
  val config = WSClientConfig(
      SSLConfig(loose =
        SSLLooseConfig(allowLegacyHelloMessages =
          None) /*comment 123 comment 234*/
      )
  ) // comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(
      SSLConfig(loose =
        SSLLooseConfig(allowLegacyHelloMessages =
          None) /*comment 123 comment 234*/
      )
  ) // comment 345 comment 456
}
<<< #1604 3: apply with assign and attached comments
{
       val config =         WSClientConfig(ssl =
SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages = None)/*comment 123 comment 234*/)) //comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(ssl =
    SSLConfig(loose = SSLLooseConfig(allowLegacyHelloMessages =
      None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
<<< #1604 3: apply with assign and attached comments, with breaks before paren/comment
{
  val config = WSClientConfig(ssl = SSLConfig(loose =
    SSLLooseConfig(allowLegacyHelloMessages = None) /*comment 123 comment 234*/
  )) // comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(ssl = SSLConfig(loose =
    SSLLooseConfig(allowLegacyHelloMessages = None) /*comment 123 comment 234*/
  )) // comment 345 comment 456
}
<<< #1604 4: apply without assign and attached comments
{
       val config =         WSClientConfig(
SSLConfig(SSLLooseConfig(None)/*comment 123 comment 234*/)) //comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(
      SSLConfig(SSLLooseConfig(None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
<<< #1604 4: apply without assign and attached comments, with breaks before paren/comment
{
  val config = WSClientConfig(
      SSLConfig(SSLLooseConfig(None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
>>>
{
  val config = WSClientConfig(
      SSLConfig(SSLLooseConfig(None) /*comment 123 comment 234*/ )
  ) // comment 345 comment 456
}
<<< comment in first arg, no newline
maxColumn = 28
===
val a = b(  /* comment */ arg1,
   arg2)
>>>
val a = b(
    /* comment */ arg1,
    arg2)
<<< comment in first arg, newline
maxColumn = 28
===
val a = b(
  /* comment */ arg1,    arg2)
>>>
val a = b(
    /* comment */ arg1,
    arg2)
<<< init with multiple curried parameters and comment, long
align.preset = none
===
val a = new b(/*c1*/c => d)(/*c2*/e => f, g => h)
>>>
val a = new b( /*c1*/ c => d)( /*c2*/ e => f, g => h)
<<< init with multiple curried parameters and comment, short
align.preset = none
maxColumn = 30
===
val a = new b(/*c1*/c => dddddddd)(/*c2*/e => f, g => h)
>>>
val a = new b( /*c1*/ c =>
  dddddddd)(
    /*c2*/ e => f,
    g => h)
<<< def with multiple curried single parameters
newlines.avoidForSimpleOverflow = [punct]
===
 object ThreadPoolConfigDispatcherBuilder {
  def conf_?[T](opt: Option[T])(
      fun: (
          T) => ThreadPoolConfigDispatcherBuilder => ThreadPoolConfigDispatcherBuilder)
       : Option[
         (ThreadPoolConfigDispatcherBuilder) => ThreadPoolConfigDispatcherBuilder] =
     opt map fun
 }
>>>
object ThreadPoolConfigDispatcherBuilder {
  def conf_?[T](opt: Option[T])(
      fun: (T) => ThreadPoolConfigDispatcherBuilder => ThreadPoolConfigDispatcherBuilder)
      : Option[(ThreadPoolConfigDispatcherBuilder) => ThreadPoolConfigDispatcherBuilder] =
    opt map fun
}
<<< implicit with single argument
align.preset = none
===
  def apply(throughput: Int)(implicit context: ExecutionContext)
      : SerializedSuspendableExecutionContext =
     new SerializedSuspendableExecutionContext(throughput)
>>>
def apply(throughput: Int)(implicit
    context: ExecutionContext): SerializedSuspendableExecutionContext =
  new SerializedSuspendableExecutionContext(throughput)
<<< config style with empty arg list 1
object a {
  foo(
  )
}
>>>
object a {
  foo(
  )
}
<<< config style with empty arg list 2
object a {
  foo( // c1
  )
}
>>>
object a {
  foo( // c1
  )
}
<<< config style with empty arg list 3
object a {
  foo(
    // c1
  )
}
>>>
object a {
  foo(
      // c1
  )
}
<<< #1798
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
===
  commonConfig(
      debugConfig(on = false)
        .withFallback(ConfigFactory.parseString("""
      akka.cluster.periodic-tasks-initial-delay = 300 s # turn off all periodic tasks
      akka.cluster.publish-stats-interval = 0 s # always, when it happens
      """))
        .withFallback(
            MultiNodeClusterSpec.clusterConfigWithFailureDetectorPuppet))
>>>
commonConfig(
  debugConfig(on = false)
    .withFallback(ConfigFactory.parseString("""
      akka.cluster.periodic-tasks-initial-delay = 300 s # turn off all periodic tasks
      akka.cluster.publish-stats-interval = 0 s # always, when it happens
      """))
    .withFallback(MultiNodeClusterSpec.clusterConfigWithFailureDetectorPuppet)
)
<<< #1799
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
===
override final def next(): To =
  if (hasNext) {
    val ret = _next
    _next = null.asInstanceOf[To] // Mark as consumed aaaaaaaaaaaaaaaaaa(nice to the GC, don't leak the last returned value)
    _hasNext = false // Mark as consumed (we need to look for the next value)
    ret
  } else throw new java.util.NoSuchElementException("next")
>>>
override final def next(): To =
  if (hasNext) {
    val ret = _next
    _next = null
      .asInstanceOf[To] // Mark as consumed aaaaaaaaaaaaaaaaaa(nice to the GC, don't leak the last returned value)
    _hasNext = false // Mark as consumed (we need to look for the next value)
    ret
  } else throw new java.util.NoSuchElementException("next")
<<< #1800
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
===
final case class StreamedEntityCreator[
    -A <: ParserOutput, +B >: HttpEntity.Strict <: HttpEntity](
    creator: Source[A, NotUsed] ⇒ B)
    extends EntityCreator[A, B] {
  def apply(parts: Source[A, NotUsed]) = creator(parts)
}
>>>
final case class StreamedEntityCreator[
  -A <: ParserOutput,
  +B >: HttpEntity.Strict <: HttpEntity
](creator: Source[A, NotUsed] ⇒ B)
    extends EntityCreator[A, B] {
  def apply(parts: Source[A, NotUsed]) = creator(parts)
}
<<< #1801
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
newlines.avoidForSimpleOverflow = [tooLong]
===
pushInput(closeFrame(
                Protocol.CloseCodes.UnexpectedCondition,
                mask = true,
                msg = "This alien landing came quite unexpected. Communication has been garbled."))
>>>
pushInput(
  closeFrame(
    Protocol.CloseCodes.UnexpectedCondition,
    mask = true,
    msg = "This alien landing came quite unexpected. Communication has been garbled."
  )
)
<<< #1802
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
===
`WWW-Authenticate`(
          HttpChallenge("Digest",
                        "testrealm@host.com",
                        Map("qop" -> "auth,auth-int",
                            "nonce" -> "dcd98b7102dd2f0e8b11d0f600bfb0c093",
                            "opaque" -> "5ccc069c403ebaf9f0171e9517f40e41")))
        .renderedTo(
          "Digest realm=\"testrealm@host.com\",qop=\"auth,auth-int\",nonce=dcd98b7102dd2f0e8b11d0f600bfb0c093,opaque=5ccc069c403ebaf9f0171e9517f40e41")
>>>
`WWW-Authenticate`(
  HttpChallenge(
    "Digest",
    "testrealm@host.com",
    Map(
      "qop" -> "auth,auth-int",
      "nonce" -> "dcd98b7102dd2f0e8b11d0f600bfb0c093",
      "opaque" -> "5ccc069c403ebaf9f0171e9517f40e41"
    )
  )
)
  .renderedTo(
    "Digest realm=\"testrealm@host.com\",qop=\"auth,auth-int\",nonce=dcd98b7102dd2f0e8b11d0f600bfb0c093,opaque=5ccc069c403ebaf9f0171e9517f40e41"
  )
<<< #1803
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = true
===
Await
          .result(
              Unmarshal(HttpEntity(
                      `multipart/mixed` withBoundary "XYZABC" withCharset `UTF-8`,
                      """this is
            |just preamble text""".stripMarginWithNewline("\r\n")))
                .to[Multipart.General]
                .failed,
              1.second)
          .getMessage
>>>
Await
  .result(
    Unmarshal(
      HttpEntity(
        `multipart/mixed` withBoundary "XYZABC" withCharset `UTF-8`,
        """this is
            |just preamble text""".stripMarginWithNewline("\r\n")
      )
    )
      .to[Multipart.General]
      .failed,
    1.second
  )
  .getMessage
<<< #1803, no breakChainOnFirstMethodDot
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
===
Await
          .result(
              Unmarshal(HttpEntity(
                      `multipart/mixed` withBoundary "XYZABC" withCharset `UTF-8`,
                      """this is
            |just preamble text""".stripMarginWithNewline("\r\n")))
                .to[Multipart.General]
                .failed,
              1.second)
          .getMessage
>>>
Await
  .result(
    Unmarshal(
      HttpEntity(
        `multipart/mixed` withBoundary "XYZABC" withCharset `UTF-8`,
        """this is
            |just preamble text""".stripMarginWithNewline("\r\n")
      )
    ).to[Multipart.General].failed,
    1.second
  )
  .getMessage
<<< #1804
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = true
===
object a {
  lazy val mod = project(
      "mod",
      Seq(common, db, user, hub, security, game, analyse, evaluation, report))
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
>>>
object a {
  lazy val mod = project(
    "mod",
    Seq(common, db, user, hub, security, game, analyse, evaluation, report)
  )
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
    )
}
<<< #1804, no breakChainOnFirstMethodDot
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
===
object a {
  lazy val mod = project(
      "mod",
      Seq(common, db, user, hub, security, game, analyse, evaluation, report))
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
>>>
object a {
  lazy val mod = project(
    "mod",
    Seq(common, db, user, hub, security, game, analyse, evaluation, report)
  ).settings(
    libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
<<< #1804 bis
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = true
===
object a {
  lazy val mod = project(
      "mod",
      Seq(common, db, user, hub, security, game, analyse, evaluation, report))
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
>>>
object a {
  lazy val mod = project(
    "mod",
    Seq(common, db, user, hub, security, game, analyse, evaluation, report)
  )
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
    )
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
    )
}
<<< #1804 bis, no breakChainOnFirstMethodDot
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
===
object a {
  lazy val mod = project(
      "mod",
      Seq(common, db, user, hub, security, game, analyse, evaluation, report))
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
    .settings(
      libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
>>>
object a {
  lazy val mod = project(
    "mod",
    Seq(common, db, user, hub, security, game, analyse, evaluation, report)
  ).settings(
    libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  ).settings(
    libraryDependencies ++= provided(play.api, play.test, RM, PRM)
  )
}
<<< #1400, breaksInsideChains T, noBB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = true
===
object Test {
  Try {
    "something1"
  }.recover { // no break
      case NonFatal(_) => "something2"
    }
    .getOrElse{ // break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // no break
    case NonFatal(_) => "something2"
  }
    .getOrElse { // break
      "something3"
    }
}
<<< #1400, breaksInsideChains T, noBnoB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = true
===
object Test {
  Try {
    "something1"
  }.recover { // no break
      case NonFatal(_) => "something2"
    }.getOrElse{ // no break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // no break
    case NonFatal(_) => "something2"
  }.getOrElse { // no break
      "something3"
    }
}
<<< #1400, breaksInsideChains T, BB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = true
===
object Test {
  Try {
    "something1"
  }
    .recover { // break
      case NonFatal(_) => "something2"
    }
    .getOrElse{ // break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // break
    case NonFatal(_) => "something2"
  }
    .getOrElse { // break
      "something3"
    }
}
<<< #1400, breaksInsideChains T, BnoB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = true
===
object Test {
  Try {
    "something1"
  }
    .recover { // break
      case NonFatal(_) => "something2"
    }.getOrElse{ // no break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // break
    case NonFatal(_) => "something2"
  }.getOrElse { // no break
      "something3"
    }
}
<<< #1400, breaksInsideChains F, noBB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = false
===
object Test {
  Try {
    "something1"
  }.recover { // no break
      case NonFatal(_) => "something2"
    }
    .getOrElse{ // break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // no break
    case NonFatal(_) => "something2"
  }.getOrElse { // break
    "something3"
  }
}
<<< #1400, breaksInsideChains F, noBnoB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = false
===
object Test {
  Try {
    "something1"
  }.recover { // no break
      case NonFatal(_) => "something2"
    }.getOrElse{ // no break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // no break
    case NonFatal(_) => "something2"
  }.getOrElse { // no break
    "something3"
  }
}
<<< #1400, breaksInsideChains F, BB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = false
===
object Test {
  Try {
    "something1"
  }
    .recover { // break
      case NonFatal(_) => "something2"
    }
    .getOrElse{ // break
      "something3"
    }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // break
    case NonFatal(_) => "something2"
  }.getOrElse { // break
    "something3"
  }
}
<<< #1400, breaksInsideChains F, BnoB
preset = intellij
danglingParentheses.preset = true
optIn.configStyleArguments = true
optIn.breakChainOnFirstMethodDot = false
optIn.breaksInsideChains = false
===
object Test {
    Try {
      "something1"
    }
      .recover { // break
        case NonFatal(_) => "something2"
      }.getOrElse{ // no break
        "something3"
      }
}
>>>
object Test {
  Try {
    "something1"
  }.recover { // break
    case NonFatal(_) => "something2"
  }.getOrElse { // no break
    "something3"
  }
}
<<< #1505 1
maxColumn = 75
align.preset = none
newlines.avoidForSimpleOverflow = [toolong]
===
object a {
         Seq(
           "HTTP/1.1 204 12345678",
           "90123456789012\r\n") should generalMultiParseTo(
           Left(MessageStartError(
             400: StatusCode,
             ErrorInfo(
               "Response reason phrase exceeds the configured limit of 21 characters"))))
}
>>>
object a {
  Seq(
      "HTTP/1.1 204 12345678",
      "90123456789012\r\n") should generalMultiParseTo(
      Left(MessageStartError(
          400: StatusCode,
          ErrorInfo("Response reason phrase exceeds the configured limit of 21 characters"))))
}
<<< #1505 2 skip multiple args
maxColumn = 75
align.preset = none
newlines.avoidForSimpleOverflow = [toolong]
===
object a {
   response shouldEqual HttpResponse(
     status = 302,
     entity = HttpEntity(
       ContentTypes.`text/html(UTF-8)`,
       "The requested resource temporarily resides under <a href=\"/foo\">this URI</a>."),
     headers = Location("/foo") :: Nil
   )
}
>>>
object a {
  response shouldEqual HttpResponse(
      status = 302,
      entity = HttpEntity(
          ContentTypes.`text/html(UTF-8)`,
          "The requested resource temporarily resides under <a href=\"/foo\">this URI</a>."),
      headers = Location("/foo") :: Nil
  )
}
<<< #1505 3
maxColumn = 75
align.preset = none
newlines.avoidForSimpleOverflow = [toolong]
===
object a {
   "allow mapping the response" in {
     val timeoutResponse = HttpResponse(
       StatusCodes.EnhanceYourCalm,
       entity =
         "Unable to serve response within time limit, please enhance your calm.")
   }
}
>>>
object a {
  "allow mapping the response" in {
    val timeoutResponse = HttpResponse(
        StatusCodes.EnhanceYourCalm,
        entity = "Unable to serve response within time limit, please enhance your calm.")
  }
}
<<< #1505 4 short unchanged
maxColumn = 75
align.preset = none
newlines.avoidForSimpleOverflow = [toolong]
===
object a {
        val boss = system.actorOf(Props(new Actor {
          def receive = {
            case "run" ⇒
              for (_ ← 1 to num)(context.watch(
                context.actorOf(props))) ! cachedMessage
            case Terminated(child) ⇒ stopLatch.countDown()
          }
        }).withDispatcher("boss"))
}
>>>
object a {
  val boss = system.actorOf(Props(new Actor {
    def receive = {
      case "run" ⇒
        for (_ ← 1 to num)
          (context.watch(context.actorOf(props))) ! cachedMessage
      case Terminated(child) ⇒ stopLatch.countDown()
    }
  }).withDispatcher("boss"))
}
<<< #1505 5 two args, second single letter
newlines.avoidForSimpleOverflow = [toolong]
===
object a {
  notifyError(
    "Startup timed out. This is usually related to actor system host setting or host name resolution misconfiguration.",
    e)
}
>>>
object a {
  notifyError(
      "Startup timed out. This is usually related to actor system host setting or host name resolution misconfiguration.",
      e)
}
<<< #2033
align.openParenCallSite = true
===
class Test {
  val testCases = List(
    ("Old state", "Campaign data", "Expected state"),
    (
      1,
      2,
      3
    )
  )
}
>>>
class Test {
  val testCases = List(
      ("Old state", "Campaign data", "Expected state"),
      (
          1,
          2,
          3
      )
  )
}
<<< #2175 1 nested assign with apply and long comment
preset = default
===
object a {
  def i: Item =
    i.copy(
      name = b(c) // Very long comment here because I need to have more than 80 characters
    )
}
>>>
object a {
  def i: Item =
    i.copy(
      name = b(
        c
      ) // Very long comment here because I need to have more than 80 characters
    )
}
<<< #2175 2 nested assign with apply and long comment
preset = default
===
object a {
  def i: Item =
    i.copy(
      name = b(
        c
      ) // Very long comment here because I need to have more than 80 characters
    )
}
>>>
object a {
  def i: Item =
    i.copy(
      name = b(
        c
      ) // Very long comment here because I need to have more than 80 characters
    )
}
<<< #2257 oveflow with interpolation, long
maxColumn = 110
newlines.avoidForSimpleOverflow = [tooLong,punct]
===
val request = Request(
  applicationid = appId.some,
  description = s"Very ${call.session.callType.description} loooong closed with caaare request ${param(call.countt)} ${AnotherParam.code}",
  siteinfo = None,
)
>>>
val request = Request(
    applicationid = appId.some,
    description = s"Very ${call.session.callType.description} loooong closed with caaare request ${param(call.countt)} ${AnotherParam.code}",
    siteinfo = None
)
<<< #2257 oveflow with interpolation, short
maxColumn = 90
newlines.avoidForSimpleOverflow = [tooLong,punct]
===
val request = Request(
  applicationid = appId.some,
  description = s"Very ${call.session.callType.description} loooong closed with caaare request ${param(call.countt)} ${AnotherParam.code}",
  siteinfo = None,
)
>>>
val request = Request(
    applicationid = appId.some,
    description = s"Very ${call.session.callType.description} loooong closed with caaare request ${param(call.countt)} ${AnotherParam.code}",
    siteinfo = None
)
<<< #2290 apply no break
val i =
          foo( //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  foo( // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4)
<<< #2290 apply break
val i =
          foo(
            //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  foo(
      // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4)
<<< #2290 tuple no break
val i =
          ( //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  ( // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4)
<<< #2290 tuple break
val i =
          (
                   //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  (
      // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4)
<<< #2562 tuple no break
danglingParentheses.tupleSite = true
===
val i =
          ( //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  ( // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4
  )
<<< #2562 tuple break
danglingParentheses.tupleSite = true
===
val i =
          (
                   //hello scalafmt, please don't blow up
                   (1, 2),
                   1,
                   3,
                   4,
                   4)
>>>
val i =
  (
      // hello scalafmt, please don't blow up
      (1, 2),
      1,
      3,
      4,
      4
  )
<<< enclosed apply with single-arg lambda 1
object a {
  val columnQueriesForInsert = {
    (
      mappedColumnInfo
        .filter(c => !(c._2.dbPrimaryKey_? && c._2.dbAutogenerated_?))
        .map(p => "?"))
        .toList
        .mkString(",")
  }
}
>>>
object a {
  val columnQueriesForInsert = {
    (mappedColumnInfo
      .filter(c => !(c._2.dbPrimaryKey_? && c._2.dbAutogenerated_?))
      .map(p => "?"))
      .toList
      .mkString(",")
  }
}
<<< enclosed apply with single-arg lambda 2
align.preset = none
===
object a {
  val numbers = (
    ((-3 to 3) ++ List(17, 127, Int.MaxValue, Int.MinValue + 1)).distinct
      .sortBy(n => (math.abs(n), n))) :+ Int.MinValue
}
>>>
object a {
  val numbers =
    (((-3 to 3) ++ List(17, 127, Int.MaxValue, Int.MinValue + 1)).distinct
      .sortBy(n => (math.abs(n), n))) :+ Int.MinValue
}
<<< enclosed apply with single-arg lambda 3
align.preset = none
danglingParentheses.preset = true
===
object a {
  val numbers = (
    ((-3 to 3) ++ List(17, 127, Int.MaxValue, Int.MinValue + 1)).distinct
      .sortBy(n => (math.abs(n), n))) :+ Int.MinValue
}
>>>
object a {
  val numbers =
    (((-3 to 3) ++ List(17, 127, Int.MaxValue, Int.MinValue + 1)).distinct
      .sortBy(n => (math.abs(n), n))) :+ Int.MinValue
}
<<< multi-arg apply with multiline constants
maxColumn = 60
===
  fails("'this' expected but unquotee found", """
     val q"def this(..$params) = $rhs2" = q"def this(x: Int) = this(0)"
   """)
>>>
fails("'this' expected but unquotee found",
      """
     val q"def this(..$params) = $rhs2" = q"def this(x: Int) = this(0)"
   """)
<<< #2633 binPack one arg per line with braces, config style 1
binPack.preset = true
===
cache.getOrElseUpdate(
  name, { x
    y
    z }, foo, bar
)
>>>
cache.getOrElseUpdate(
    name, {
      x
      y
      z
    },
    foo,
    bar
)
<<< #2633 binPack one arg per line with braces, config style 2
binPack.preset = true
===
cache.getOrElseUpdate(
  name, { x =>
    y
    z }, foo, bar
)
>>>
cache.getOrElseUpdate(
    name,
    { x =>
      y
      z
    },
    foo,
    bar
)
<<< #2633 binPack one arg per line with braces 2
binPack.preset = true
===
cache.getOrElseUpdate(name, { x; y; z }, foo, bar)
>>>
cache.getOrElseUpdate(name, { x; y; z }, foo, bar)
<<< #2633 binPack one arg per line with braces 3
maxColumn = 40
binPack.preset = true
===
cache.getOrElseUpdate(name, { x; y; z }, foo, bar)
>>>
cache.getOrElseUpdate(name, { x; y; z },
                      foo, bar)
<<< #2633 binPack one arg per line with braces 3
maxColumn = 60
binPack.preset = true
===
cache.getOrElseUpdate(name, { x; y; z }, { x => y; z }, foo, bar)
>>>
cache.getOrElseUpdate(name, { x; y; z }, { x => y; z }, foo,
                      bar)
<<< #2633 binPack with multiline arg, always
maxColumn = 80
indent.callSite = 2
binPack.unsafeCallSite = Always
===
object a {
  val cls = Select(Select(Select(Select(Select(Select(Ident(nme.ROOTPKG),
    nme.scala_), scalajs), js), nme.annotation, x, y, z), internal_, a, b, c),
    wasPublicBeforeTyperXxx)
}
>>>
object a {
  val cls =
    Select(Select(Select(Select(Select(Select(Ident(nme.ROOTPKG), nme.scala_),
                                       scalajs), js), nme.annotation, x, y, z),
                  internal_, a, b, c), wasPublicBeforeTyperXxx)
}
<<< #2633 binPack with multiline arg, oneline
maxColumn = 80
indent.callSite = 2
binPack.unsafeCallSite = Oneline
===
object a {
  val cls = Select(Select(Select(Select(Select(Select(Ident(nme.ROOTPKG),
    nme.scala_), scalajs), js), nme.annotation, x, y, z), internal_, a, b, c),
    wasPublicBeforeTyperXxx)
}
>>> { stateVisits = 1321 }
object a {
  val cls = Select(
    Select(
      Select(
        Select(Select(Select(Ident(nme.ROOTPKG), nme.scala_), scalajs), js),
        nme.annotation, x, y, z),
      internal_, a, b, c),
    wasPublicBeforeTyperXxx)
}
<<< #2633 with binPack always
maxColumn = 70
indent.callSite = 2
binPack.unsafeCallSite = always
optIn.breaksInsideChains = true
optIn.breakChainOnFirstMethodDot = false
===
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName.getAnnotation(JSNameAnnotation).fold {
      sym.addAnnotation(JSNameAnnotation,
          Literal(Constant(jsInterop.defaultJSNameOf(symForName))))
    } { annot =>
      sym.addAnnotation(annot)
    }
  }
}
>>>
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName
      .getAnnotation(JSNameAnnotation).fold {
        sym.addAnnotation(JSNameAnnotation,
                          Literal(Constant(jsInterop.defaultJSNameOf(
                                             symForName))))
      } { annot =>
        sym.addAnnotation(annot)
      }
  }
}
<<< #2633 with binPack oneline
maxColumn = 70
indent.callSite = 2
binPack.unsafeCallSite = oneline
optIn.breaksInsideChains = true
optIn.breakChainOnFirstMethodDot = false
===
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName.getAnnotation(JSNameAnnotation).fold {
      sym.addAnnotation(JSNameAnnotation,
          Literal(Constant(jsInterop.defaultJSNameOf(symForName))))
    } { annot =>
      sym.addAnnotation(annot)
    }
  }
}
>>>
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName
      .getAnnotation(JSNameAnnotation).fold {
        sym.addAnnotation(JSNameAnnotation,
                          Literal(Constant(
                            jsInterop.defaultJSNameOf(symForName))))
      } { annot =>
        sym.addAnnotation(annot)
      }
  }
}
<<< #2633 without binPack
maxColumn = 70
indent.callSite = 2
binPack.unsafeCallSite = false
optIn.breaksInsideChains = true
optIn.breakChainOnFirstMethodDot = false
===
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName.getAnnotation(JSNameAnnotation).fold {
      sym.addAnnotation(JSNameAnnotation,
          Literal(Constant(jsInterop.defaultJSNameOf(symForName))))
    } { annot =>
      sym.addAnnotation(annot)
    }
  }
}
>>>
object a {
  def addAnnots(sym: Symbol, symForName: Symbol): Unit = {
    symForName
      .getAnnotation(JSNameAnnotation).fold {
        sym.addAnnotation(
          JSNameAnnotation,
          Literal(Constant(jsInterop.defaultJSNameOf(symForName))))
      } { annot =>
        sym.addAnnotation(annot)
      }
  }
}
<<< #3274
object a {
  def createFoo(rs: ResultSet): Foo = {
    new Foo(
      rs.getDouble(1),
      rs.getDouble(2),
      rs.getDouble(3),
      rs.getDouble(4),
      rs.getDouble(5),
      rs.getDouble(6),
      rs.getDouble(7),
      rs.getDouble(8),
      rs.getDouble(9),
      rs.getDouble(10),
      rs.getDouble(11),
      rs.getDouble(12),
      rs.getDouble(13),
      rs.getDouble(14),
      rs.getDouble(15),
      rs.getDouble(16),
      rs.getDouble(17),
      rs.getDouble(18),
      rs.getDouble(19),
      rs.getDouble(20),
      rs.getDouble(21),
      rs.getDouble(22),
      rs.getDouble(23),
      rs.getDouble(24),
      rs.getDouble(25),
      rs.getDouble(26),
      rs.getDouble(27),
      rs.getDouble(28),
      rs.getDouble(29),
      rs.getDouble(30),
      rs.getDouble(31),
      rs.getDouble(32),
      rs.getDouble(33),
      rs.getDouble(34),
      rs.getDouble(35),
      rs.getDouble(36)
    )
  }
}
>>>
object a {
  def createFoo(rs: ResultSet): Foo = {
    new Foo(
        rs.getDouble(1),
        rs.getDouble(2),
        rs.getDouble(3),
        rs.getDouble(4),
        rs.getDouble(5),
        rs.getDouble(6),
        rs.getDouble(7),
        rs.getDouble(8),
        rs.getDouble(9),
        rs.getDouble(10),
        rs.getDouble(11),
        rs.getDouble(12),
        rs.getDouble(13),
        rs.getDouble(14),
        rs.getDouble(15),
        rs.getDouble(16),
        rs.getDouble(17),
        rs.getDouble(18),
        rs.getDouble(19),
        rs.getDouble(20),
        rs.getDouble(21),
        rs.getDouble(22),
        rs.getDouble(23),
        rs.getDouble(24),
        rs.getDouble(25),
        rs.getDouble(26),
        rs.getDouble(27),
        rs.getDouble(28),
        rs.getDouble(29),
        rs.getDouble(30),
        rs.getDouble(31),
        rs.getDouble(32),
        rs.getDouble(33),
        rs.getDouble(34),
        rs.getDouble(35),
        rs.getDouble(36)
    )
  }
}
<<< #3309 init
preset = default
align.preset = none
danglingParentheses.preset = true
maxColumn = 100
runner.optimizer.forceConfigStyleMinArgCount = 5
===
class a {
  private[BlazeClientBuilder] def this(foo: Int) = this(
    asynchronousChannelGroup = asynchronousChannelGroup,
    channelOptions = channelOptions,
    customDnsResolver = customDnsResolver,
    retries = 0,
    maxIdleDuration = Duration.Inf
  )(F)
}
>>>
class a {
  private[BlazeClientBuilder] def this(foo: Int) = this(
    asynchronousChannelGroup = asynchronousChannelGroup,
    channelOptions = channelOptions,
    customDnsResolver = customDnsResolver,
    retries = 0,
    maxIdleDuration = Duration.Inf
  )(F)
}
<<< #3309 apply
preset = default
align.preset = none
danglingParentheses.preset = true
maxColumn = 100
runner.optimizer.forceConfigStyleMinArgCount = 5
===
class a {
  private[BlazeClientBuilder] def thiz(foo: Int) = thiz(
    asynchronousChannelGroup = asynchronousChannelGroup,
    channelOptions = channelOptions,
    customDnsResolver = customDnsResolver,
    retries = 0,
    maxIdleDuration = Duration.Inf
  )(F)
}
>>>
class a {
  private[BlazeClientBuilder] def thiz(foo: Int) = thiz(
    asynchronousChannelGroup = asynchronousChannelGroup,
    channelOptions = channelOptions,
    customDnsResolver = customDnsResolver,
    retries = 0,
    maxIdleDuration = Duration.Inf
  )(F)
}
<<< binPack unsafeCallSite, !indentOnce, indentCallSiteSingleArg
binPack.unsafeCallSite = always
binPack.indentCallSiteOnce = false
binPack.indentCallSiteSingleArg = true
indent.callSite = 2
align.preset = none
===
object a {
  val ref = foo(bar((_, _) =>
    baz1 { qux1 =>
      noop1
    } baz2 { qux2 =>
      noop2
    } baz3 //
      { qux3 =>
        noop3
      } baz4 { qux4 =>
        noop4
      }))
}
>>>
object a {
  val ref = foo(bar((_, _) =>
      baz1 { qux1 =>
        noop1
      } baz2 { qux2 =>
        noop2
      } baz3 //
        { qux3 =>
          noop3
        } baz4 { qux4 =>
          noop4
        }))
}
<<< binPack unsafeCallSite, indentOnce, indentCallSiteSingleArg
binPack.unsafeCallSite = always
binPack.indentCallSiteOnce = true
binPack.indentCallSiteSingleArg = true
indent.callSite = 2
align.preset = none
===
object a {
  val ref = foo(bar((_, _) =>
    baz1 { qux1 =>
      noop1
    } baz2 { qux2 =>
      noop2
    } baz3 //
      { qux3 =>
        noop3
      } baz4 { qux4 =>
        noop4
      }))
}
>>>
object a {
  val ref = foo(bar((_, _) =>
      baz1 { qux1 =>
        noop1
      } baz2 { qux2 =>
        noop2
      } baz3 //
        { qux3 =>
          noop3
        } baz4 { qux4 =>
          noop4
        }))
}
<<< binPack unsafeCallSite, indentOnce, !indentCallSiteSingleArg
binPack.unsafeCallSite = always
binPack.indentCallSiteOnce = true
binPack.indentCallSiteSingleArg = false
indent.callSite = 2
align.preset = none
===
object a {
  val ref = foo(bar((_, _) =>
    baz1 { qux1 =>
      noop1
    } baz2 { qux2 =>
      noop2
    } baz3 //
      { qux3 =>
        noop3
      } baz4 { qux4 =>
        noop4
      }))
}
>>>
object a {
  val ref = foo(bar((_, _) =>
    baz1 { qux1 =>
      noop1
    } baz2 { qux2 =>
      noop2
    } baz3 //
      { qux3 =>
        noop3
      } baz4 { qux4 =>
        noop4
      }))
}
